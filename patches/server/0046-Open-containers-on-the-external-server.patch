From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 18 Nov 2021 00:00:34 +1000
Subject: [PATCH] Open containers on the external server


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 744f7b717f14a070d5a4be0b35e7f422694fb407..3de37fade12077fc7836ef01d8f930dae969267c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -214,6 +214,7 @@ import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import puregero.multipaper.MultiPaperInteractHandler;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
@@ -1803,6 +1804,8 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
         }
         // Paper end - move check up
 
+        if (MultiPaperInteractHandler.handleInteractEvent(this.player, packet)) return; // MultiPaper - send to external server if necessary
+
         this.player.resetLastActionTime();
         int i = this.player.level.getMaxBuildHeight();
 
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 214acb5313ca5c29ede83b69c8e1cf557d7edd26..2e550dfee672e6ecacd9444d34f0732a1f5f8173 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -3,15 +3,14 @@ package puregero.multipaper;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtIo;
+import net.minecraft.nbt.Tag;
 import net.minecraft.network.ConnectionProtocol;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
-import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
@@ -119,6 +118,7 @@ public class ExternalServerConnection extends Thread implements Closeable {
                     for (int id : ids) {
                         ServerPlayer player = getPlayerById(id);
                         if (player != null) {
+                            MultiPaperInteractHandler.handlePacket(externalServer, player, packet);
                             player.connection.send(packet);
                         }
                     }
@@ -169,6 +169,26 @@ public class ExternalServerConnection extends Thread implements Closeable {
                             MultiPaper.runSync(newChunk::loadCallback);
                         }
                     }
+                } else if (message.equals("playerAction")) {
+                    int id = in.readInt();
+                    int length = in.readInt();
+                    byte[] bytes = new byte[length];
+                    in.readFully(bytes);
+                    ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+                    FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+                    int packetId = friendlyByteBuf.readVarInt();
+                    Packet<ServerGamePacketListener> packet = (Packet<ServerGamePacketListener>) ConnectionProtocol.PLAY.createPacket(PacketFlow.SERVERBOUND, packetId, friendlyByteBuf);
+                    ServerPlayer player = getPlayerById(id);
+                    player.server.execute(() -> packet.handle(player.connection));
+                } else if (message.equals("playerInventory")) {
+                    int id = in.readInt();
+                    int length = in.readInt();
+                    byte[] bytes = new byte[length];
+                    in.readFully(bytes);
+                    CompoundTag tag = MultiPaper.nbtDecompressFromBytes(bytes);
+                    ServerPlayer player = getPlayerById(id);
+                    player.getInventory().load(tag.getList("Inventory", Tag.TAG_COMPOUND));
+                    player.getInventory().selected = tag.getInt("SelectedItemSlot");
                 }
             }
         } catch (EOFException e) {
@@ -380,6 +400,43 @@ public class ExternalServerConnection extends Thread implements Closeable {
         }
     }
 
+    public void sendPlayerInventory(ServerPlayer player) {
+        try {
+            CompoundTag nbt = new CompoundTag();
+            nbt.put("Inventory", player.getInventory().save(new ListTag()));
+            nbt.putInt("SelectedItemSlot", player.getInventory().selected);
+            byte[] bytes = MultiPaper.nbtCompressToBytes(nbt);
+            PacketBuffer buffer = new PacketBuffer(socket);
+            buffer.writeUTF("playerInventory");
+            buffer.writeInt(player.getId());
+            buffer.writeInt(bytes.length);
+            buffer.write(bytes);
+            buffer.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void sendPlayerAction(ServerPlayer player, Packet<?> packet) {
+        try {
+            PacketBuffer buffer = new PacketBuffer(socket);
+            buffer.writeUTF("playerAction");
+            buffer.writeInt(player.getId());
+            ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+            Integer id = protocol.getPacketId(PacketFlow.SERVERBOUND, packet);
+            ByteBuf buf = Unpooled.buffer();
+            FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+            friendlyByteBuf.writeVarInt(id);
+            packet.write(friendlyByteBuf);
+            byte[] bytes = buf.array();
+            buffer.writeInt(bytes.length);
+            buffer.write(bytes);
+            buffer.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
     private static class PacketBuffer extends DataOutputStream {
         private final Socket socket;
 
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 2a766af0cbc6e7772eb2bde6e2fb9d084816779a..899e47de1b54fd98df03ea72666ae1e795f122c4 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -22,6 +22,7 @@ import java.util.HashSet;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
     // You'll want to increase this if you have more than 250 servers
@@ -208,6 +209,10 @@ public class MultiPaper {
         return buffer.toByteArray();
     }
 
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
     public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
         ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
         ChunkAccess chunkAccess = level.getChunkIfLoaded(cx, cz);
diff --git a/src/main/java/puregero/multipaper/MultiPaperInteractHandler.java b/src/main/java/puregero/multipaper/MultiPaperInteractHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0b9602dd4a538e19e66c64951143e79251909ae
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperInteractHandler.java
@@ -0,0 +1,33 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ServerboundUseItemOnPacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.Container;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.LevelChunk;
+
+public class MultiPaperInteractHandler {
+
+    public static void handlePacket(ExternalServer server, ServerPlayer player, Packet<?> packet) {
+        // TODO: Intercept open and close window packets, then while a window is open, forward window packets to that server
+    }
+
+    /**
+     * Returns true if the even should be cancelled
+     */
+    public static boolean handleInteractEvent(ServerPlayer player, ServerboundUseItemOnPacket packet) {
+        BlockEntity blockEntity = player.level.getBlockEntity(packet.getHitResult().getBlockPos());
+
+        if (blockEntity instanceof Container) {
+            LevelChunk chunk = player.level.getChunkIfLoaded(packet.getHitResult().getBlockPos());
+            if (chunk.externalOwner != null && !chunk.externalOwner.isMe()) {
+                chunk.externalOwner.getConnection().sendPlayerInventory(player);
+                chunk.externalOwner.getConnection().sendPlayerAction(player, packet);
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
