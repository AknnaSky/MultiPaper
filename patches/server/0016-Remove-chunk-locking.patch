From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sat, 27 Mar 2021 02:06:50 +1000
Subject: [PATCH] Remove chunk locking


diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index 9b192db10d7fdc5ecf7d8b938e3d93675426fe5f..4fad3caf8cd0bcc57b87223df6005a9388319ac8 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -929,8 +929,6 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
                 mutableboolean.setFalse();
                 list.stream().map((playerchunk) -> {
-                    MultiPaper.releaseChunk(playerchunk.location, playerchunk.getWorld());
-
                     CompletableFuture completablefuture;
 
                     do {
@@ -1096,8 +1094,6 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     }
                     this.autoSaveQueue.remove(playerchunk); // Paper
 
-                    MultiPaper.releaseChunk(ichunkaccess.getPos(), this.world); // MultiPaper
-
                     try {
                         this.asyncSave(ichunkaccess); // Paper - async chunk saving
                     } catch (Throwable ex) {
diff --git a/src/main/java/net/minecraft/server/network/PlayerConnection.java b/src/main/java/net/minecraft/server/network/PlayerConnection.java
index 5c17f52103637e7d5400a64b6882472fd061e771..a0b81a75f73c507f507c22b6dfeab738d4010b90 100644
--- a/src/main/java/net/minecraft/server/network/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/network/PlayerConnection.java
@@ -1397,12 +1397,6 @@ public class PlayerConnection implements PacketListenerPlayIn {
                                 float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
 
                                 if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isFrozen()) {
-                                    // MultiPaper start - Detect chunk movements
-                                    if ((int) lastPosX >> 4 != (int) to.getX() >> 4 || (int) lastPosZ >> 4 != (int) to.getZ() >> 4) {
-                                        MultiPaper.isChunkLocked((WorldServer) this.player.world, (int) to.getX() >> 4, (int) to.getZ() >> 4);
-                                    }
-                                    // MultiPaper end
-                                    
                                     this.lastPosX = to.getX();
                                     this.lastPosY = to.getY();
                                     this.lastPosZ = to.getZ();
@@ -1549,12 +1543,6 @@ public class PlayerConnection implements PacketListenerPlayIn {
             this.teleportAwait = 0;
         }
 
-        // MultiPaper start - Detect chunk movements
-        if ((int) lastPosX >> 4 != (int) teleportPos.x >> 4 || (int) lastPosZ >> 4 != (int) teleportPos.z >> 4) {
-            MultiPaper.isChunkLocked((WorldServer) this.player.world, (int) teleportPos.x >> 4, (int) teleportPos.z >> 4);
-        }
-        // MultiPaper end
-
         // CraftBukkit start - update last location
         this.lastPosX = this.teleportPos.x;
         this.lastPosY = this.teleportPos.y;
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index d17b1ae8d7683c05d94cf74e9041345fca4427c9..e9acefe789b7cf76085f00b311a87731d321ff26 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -612,8 +612,6 @@ public abstract class PlayerList {
         if (entityplayer.didPlayerJoinEvent) cserver.getPluginManager().callEvent(playerQuitEvent); // Paper - if we disconnected before join ever fired, don't fire quit
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
-        Zone.onPlayerDisconnect(entityplayer.getBukkitEntity()); // MultiPaper
-
         if (server.isMainThread()) entityplayer.playerTick(); // SPIGOT-924 // Paper - don't tick during emergency shutdowns (Watchdog)
         // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 20a3fccc968740f7974c1e7842907a6cdc51d498..d6e95e33d7e11fd4e9846136cd006900d5c79188 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -2679,16 +2679,6 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
             if (shapedetectorshape == null) {
                 return null;
             } else {
-                
-                // MultiPaper start - only teleport the entity if the destination chunk is locked
-                int cx = (int) shapedetectorshape.position.x >> 4;
-                int cz = (int) shapedetectorshape.position.z >> 4;
-                if (!MultiPaper.isChunkLocked(worldserver, cx, cz)) {
-                    MultiPaper.onChunkLock(worldserver, cx, cz, () -> teleportTo(shapedetectorshape.world, new BlockPosition(shapedetectorshape.position)));
-                    return null;
-                }
-                // MultiPaper end
-                
                 // CraftBukkit start
                 worldserver = shapedetectorshape.world;
                 this.decouple();
diff --git a/src/main/java/net/minecraft/world/level/chunk/Chunk.java b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
index d5eb3d7847ddd6c11e13b7976a543a13c65d4ebe..4b51fbc615ef6fd15fb20ab92a32d2a4a77e17c0 100644
--- a/src/main/java/net/minecraft/world/level/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
@@ -857,7 +857,6 @@ public class Chunk implements IChunkAccess {
         this.setNeighbourLoaded(0, 0, this);
         this.loadedTicketLevel = true;
         // Paper end - neighbour cache
-        MultiPaper.lockChunk(this.loc, this.world); // MultiPaper
         org.bukkit.Server server = this.world.getServer();
         ((WorldServer)this.world).getChunkProvider().addLoadedChunk(this); // Paper
         if (server != null) {
diff --git a/src/main/java/puregero/multipaper/BungeeCord.java b/src/main/java/puregero/multipaper/BungeeCord.java
deleted file mode 100644
index 8c2428891ce5e7345b721be6fc55ae1879e98d25..0000000000000000000000000000000000000000
--- a/src/main/java/puregero/multipaper/BungeeCord.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package puregero.multipaper;
-
-import com.google.common.io.ByteArrayDataOutput;
-import com.google.common.io.ByteStreams;
-import io.netty.buffer.Unpooled;
-import net.minecraft.network.PacketDataSerializer;
-import net.minecraft.network.protocol.game.PacketPlayOutCustomPayload;
-import net.minecraft.resources.MinecraftKey;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.entity.Player;
-
-public class BungeeCord {
-    private static final Logger LOGGER = LogManager.getLogger();
-
-    public static void connectPlayer(Player p, String server) {
-        LOGGER.info("Sending " + p.getName() + " to server: " + server);
-        ByteArrayDataOutput out = ByteStreams.newDataOutput();
-        out.writeUTF("Connect");
-        out.writeUTF(server);
-        PacketPlayOutCustomPayload packet = new PacketPlayOutCustomPayload(new MinecraftKey("bungeecord:main"), new PacketDataSerializer(Unpooled.wrappedBuffer(out.toByteArray())));
-        ((CraftPlayer) p).getHandle().playerConnection.sendPacket(packet);
-    }
-}
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index dd28e4186c26b43770ec4f2f7843450992ce4489..f3b147824896eaede61af72db2fc2095ef0dab2b 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -23,15 +23,15 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 
 import java.io.*;
 import java.nio.file.Files;
-import java.util.*;
+import java.util.UUID;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
@@ -41,8 +41,7 @@ public class MultiPaper {
     private static final Logger LOGGER = LogManager.getLogger();
     private static MultiPaperConnection multiPaperConnection = null;
     private static long last10Seconds = System.currentTimeMillis();
-    private static HashSet<ChunkKey> lockedChunks = new HashSet<>();
-    private static HashMap<ChunkKey, List<Runnable>> onChunkLockCallbacks = new HashMap<>();
+    private static MultiPaperPlugin plugin = null;
 
     private static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
@@ -53,6 +52,11 @@ public class MultiPaper {
     }
 
     private static void tick() {
+        if (plugin == null) {
+            plugin = new MultiPaperPlugin();
+            Bukkit.getPluginManager().registerEvents(new MultiPaperListener(), plugin);
+        }
+        
         boolean hasBeen10Seconds = last10Seconds < System.currentTimeMillis() - 10 * 1000;
 
         if (hasBeen10Seconds) last10Seconds = System.currentTimeMillis();
@@ -177,50 +181,16 @@ public class MultiPaper {
         getConnection().writeUid(world, data);
     }
 
-    public static void lockChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
+    public static void willSaveChunk(World world, int cx, int cz) {
         try {
-            if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair)) {
-                return;
-            }
-
-            getConnection().lockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z).thenAccept(holder -> {
-                if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair)) {
-                    releaseChunk(chunkcoordintpair, worldServer);
-                    return;
-                }
-                
-                if (holder == null) {
-                    ChunkKey key = new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
-
-                    lockedChunks.add(key);
-
-                    List<Runnable> callbacks = onChunkLockCallbacks.remove(key);
-
-                    if (callbacks != null) {
-                        callbacks.forEach(callback -> ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(callback, 0, "onChunkLockCallback-" + callback.getClass().getName()));
-                    }
-                }
-                
-                new Thread(() -> {
-                    if (holder != null) {
-                        Zone.doMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z), holder);
-                    } else {
-                        Zone.checkIfShouldMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z));
-                    }
-                }).start();
-            });
+            getConnection().willSaveChunk(world.getName(), cx, cz);
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
-    
-    public static void releaseChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
-        try {
-            lockedChunks.remove(new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z));
-            getConnection().releaseChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
+
+    public static void willSaveChunk(org.bukkit.Chunk chunk) {
+        willSaveChunk(chunk.getWorld(), chunk.getX(), chunk.getZ());
     }
 
     public static void notifyChunkNotSaving(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
@@ -405,32 +375,7 @@ public class MultiPaper {
             return true;
         }
         
-        return !Zone.isBeingSentToAnotherServer(((EntityPlayer) player).getBukkitEntity()) && isChunkLocked((WorldServer) player.world, player.chunkX, player.chunkZ);
-    }
-
-    public static boolean isChunkLocked(WorldServer world, int chunkX, int chunkZ) {
-        boolean isLocked = lockedChunks.contains(new ChunkKey(world.worldDataServer.getName(), chunkX, chunkZ));
-        
-        if (isLocked) {
-            return true;
-        }
-        
-        if (world.isChunkLoaded(chunkX, chunkZ)) {
-            // The chunk is loaded, so why isn't it locked?
-            lockChunk(new ChunkCoordIntPair(chunkX, chunkZ), world);
-        }
-        
-        return false;
-    }
-
-    public static void onChunkLock(WorldServer world, int chunkX, int chunkZ, Runnable runnable) {
-        ChunkKey key = new ChunkKey(world.worldDataServer.getName(), chunkX, chunkZ);
-        
-        if (lockedChunks.contains(key)) {
-            runnable.run();
-        } else {
-            onChunkLockCallbacks.computeIfAbsent(key, key2 -> new ArrayList<>()).add(runnable);
-        }    
+        return !Zone.isBeingSentToAnotherServer(((EntityPlayer) player).getBukkitEntity());
     }
 
     public static boolean shouldTickEntity(WorldServer worldServer, Entity entity) {
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 3ef5aaec633baf912841156968df2ebe61c1cd0f..426b80b4113c87e5d138736b337a1ba8db0b84f9 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -523,29 +523,9 @@ public class MultiPaperConnection extends Thread {
         out.send(null);
     }
 
-    public CompletableFuture<String> lockChunk(String world, int cx, int cz) throws IOException {
-        CompletableFuture<String> future = new CompletableFuture<>();
-
-        DataOutputSender out = new DataOutputSender(this);
-        out.writeUTF("lockChunk");
-        out.writeUTF(world);
-        out.writeInt(cx);
-        out.writeInt(cz);
-        out.send(in -> {
-            try {
-                String holder = in.readUTF();
-                future.complete(holder.isEmpty() ? null : holder);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        });
-
-        return future;
-    }
-
-    public void releaseChunk(String world, int cx, int cz) throws IOException {
+    public void willSaveChunk(String world, int cx, int cz) throws IOException {
         DataOutputSender out = new DataOutputSender(this);
-        out.writeUTF("releaseChunk");
+        out.writeUTF("willSaveChunk");
         out.writeUTF(world);
         out.writeInt(cx);
         out.writeInt(cz);
diff --git a/src/main/java/puregero/multipaper/MultiPaperListener.java b/src/main/java/puregero/multipaper/MultiPaperListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..75f4049ba0643018fbab17d6954d1736f685d231
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperListener.java
@@ -0,0 +1,37 @@
+package puregero.multipaper;
+
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+
+import java.util.HashSet;
+
+public class MultiPaperListener implements Listener {
+
+    private HashSet<Player> kickedPlayers = new HashSet<>();
+    
+    @EventHandler(priority = EventPriority.LOWEST)
+    public void onPlayerQuit(PlayerQuitEvent e) {
+        if (!kickedPlayers.remove(e.getPlayer())) {
+            willSaveChunks(e.getPlayer());
+        }
+    }
+
+    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
+    public void onPlayerQuit(PlayerKickEvent e) {
+        willSaveChunks(e.getPlayer());
+        kickedPlayers.add(e.getPlayer());
+    }
+
+    /**
+     * Mark the loaded chunks around the player as will be saved
+     * @param player Player to mark the chunks around
+     */
+    private void willSaveChunks(Player player) {
+        Zone zone = new Zone(player.getWorld(), player.getLocation().getBlockX() >> 4, player.getLocation().getBlockZ() >> 4);
+        zone.forEach(MultiPaper::willSaveChunk);
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperPlugin.java b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..c00c227819e0f0b02abbe6e555a4afcfb461653c
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
@@ -0,0 +1,129 @@
+package puregero.multipaper;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.logging.Logger;
+
+public class MultiPaperPlugin implements Plugin {
+    
+    private JavaPluginLoader loader = new JavaPluginLoader(Bukkit.getServer());
+
+    @Override
+    public @NotNull File getDataFolder() {
+        return null;
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getDescription() {
+        return null;
+    }
+
+    @Override
+    public @NotNull FileConfiguration getConfig() {
+        return null;
+    }
+
+    @Override
+    public @Nullable InputStream getResource(@NotNull String filename) {
+        return null;
+    }
+
+    @Override
+    public void saveConfig() {
+
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+
+    }
+
+    @Override
+    public void saveResource(@NotNull String resourcePath, boolean replace) {
+
+    }
+
+    @Override
+    public void reloadConfig() {
+
+    }
+
+    @Override
+    public @NotNull PluginLoader getPluginLoader() {
+        return loader;
+    }
+
+    @Override
+    public @NotNull Server getServer() {
+        return null;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return true;
+    }
+
+    @Override
+    public void onDisable() {
+
+    }
+
+    @Override
+    public void onLoad() {
+
+    }
+
+    @Override
+    public void onEnable() {
+        
+    }
+
+    @Override
+    public boolean isNaggable() {
+        return false;
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+
+    }
+
+    @Override
+    public @Nullable ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id) {
+        return null;
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        return null;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return "MultiPaper";
+    }
+
+    @Override
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        return false;
+    }
+
+    @Override
+    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
+        return null;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
index 0eee94b63f326c8bf90331344e97cbc96a4f9c90..1fd658967de55adb5f38cefe500263c49470b74e 100644
--- a/src/main/java/puregero/multipaper/Zone.java
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -1,31 +1,24 @@
 package puregero.multipaper;
 
-import net.minecraft.server.level.Ticket;
-import net.minecraft.server.level.TicketType;
-import net.minecraft.server.level.WorldServer;
-import net.minecraft.util.ArraySetSorted;
-import net.minecraft.world.level.ChunkCoordIntPair;
+import net.kyori.adventure.text.Component;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
-import org.bukkit.Location;
 import org.bukkit.World;
-import org.bukkit.craftbukkit.CraftChunk;
-import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
 
 import java.util.*;
 import java.util.function.Consumer;
 
-public class Zone {
+public class Zone implements Iterable<Chunk> {
     private static final Logger LOGGER = LogManager.getLogger();
     private static final int SHOULD_MERGE_CHUNK_LIMIT = 15;
 
     private static HashSet<Player> beingSentToAnotherServer = new HashSet<>();
-    private static HashMap<Player, Zone> zonesToUnload = new HashMap<>();
 
     private static List<Consumer<Chunk>> chunkSaveHandlers = new ArrayList<>();
 
@@ -33,58 +26,6 @@ public class Zone {
         chunkSaveHandlers.add(handler);
     }
 
-    public static boolean shouldLockChunk(String worldName, ChunkCoordIntPair coordIntPair) {
-        World world = Bukkit.getWorld(worldName);
-        ArraySetSorted<Ticket<?>> tickets = ((CraftWorld) world).getHandle().chunkProvider.chunkMapDistance.tickets.get(coordIntPair.pair());
-        for (Player player : world.getPlayers()) {
-            if (!beingSentToAnotherServer.contains(player) &&
-                    Math.abs((player.getLocation().getBlockX() >> 4) - coordIntPair.x) <= Bukkit.getViewDistance() + 6 &&
-                    Math.abs((player.getLocation().getBlockZ() >> 4) - coordIntPair.z) <= Bukkit.getViewDistance() + 6) {
-                return true;
-            }
-        }
-
-        if (tickets == null) {
-            return false;
-        }
-
-        for (Ticket<?> ticket : tickets) {
-            if (ticket.getTicketType() == TicketType.PLAYER
-                    || ticket.getTicketType() == TicketType.PLUGIN
-                    || ticket.getTicketType() == TicketType.ASYNC_LOAD) {
-                return false;
-            }
-        }
-        
-        // Check opposite world for players
-        
-        World oppositeWorld = null;
-        int cx = 0;
-        int cz = 0;
-
-        if (world.getEnvironment() == World.Environment.NORMAL) {
-            oppositeWorld = Bukkit.getWorld(world.getName() + "_nether");
-            cx = coordIntPair.x / 8;
-            cz = coordIntPair.z / 8;
-        } else if (world.getEnvironment() == World.Environment.NETHER) {
-            oppositeWorld = Bukkit.getWorld(world.getName().split("_")[0]);
-            cx = coordIntPair.x * 8;
-            cz = coordIntPair.z * 8;
-        }
-        
-        if (oppositeWorld != null) {
-            for (Player player : oppositeWorld.getPlayers()) {
-                if (!beingSentToAnotherServer.contains(player) &&
-                        Math.abs((player.getLocation().getBlockX() >> 4) - cx) <= Bukkit.getViewDistance() + 6 &&
-                        Math.abs((player.getLocation().getBlockZ() >> 4) - cz) <= Bukkit.getViewDistance() + 6) {
-                    return true;
-                }
-            }
-        }
-        
-        return false;
-    }
-
     public static boolean isBeingSentToAnotherServer(Player player) {
         return beingSentToAnotherServer.contains(player);
     }
@@ -95,40 +36,8 @@ public class Zone {
         if (zone.players.size() > 0) {
             return doMerge(chunk, zone, server);
         } else {
-            return doMergeOppositeDimension(chunk, server);
-        }
-    }
-    
-    private static Collection<Player> doMergeOppositeDimension(Chunk chunk, String server) {
-        Chunk oppositeChunk = null;
-        
-        if (chunk.getWorld().getEnvironment() == World.Environment.NORMAL) {
-            World world = Bukkit.getWorld(chunk.getWorld().getName() + "_nether");
-            int cx = chunk.getX() / 8;
-            int cz = chunk.getZ() / 8;
-            if (world.isChunkLoaded(cx, cz)) {
-                oppositeChunk = world.getChunkAt(cx, cz);
-            }
-        } else if (chunk.getWorld().getEnvironment() == World.Environment.NETHER) {
-            World world = Bukkit.getWorld(chunk.getWorld().getName().split("_")[0]);
-            int cx = chunk.getX() * 8;
-            int cz = chunk.getZ() * 8;
-            if (world.isChunkLoaded(cx, cz)) {
-                oppositeChunk = world.getChunkAt(cx, cz);
-            }
-        }
-        
-        if (oppositeChunk == null) {
             return Collections.emptySet();
         }
-        
-        Zone zone = new Zone(oppositeChunk);
-        
-        if (zone.players.size() > 0) {
-            return doMerge(oppositeChunk, zone, server);
-        }
-
-        return zone.players;
     }
 
     private static Collection<Player> doMerge(Chunk chunk, Zone zone1, String server) {
@@ -137,41 +46,32 @@ public class Zone {
         HashSet<Player> toSend = new HashSet<>();
         for (Player player : zone1.players) {
             if (beingSentToAnotherServer.add(player)) {
-                zonesToUnload.put(player, zone1);
                 toSend.add(player);
             }
         }
 
-        try {
-            Thread.sleep(50);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
-
         Zone zone = new Zone(chunk);
 
         for (Chunk c : zone.chunks) {
-            net.minecraft.world.level.chunk.Chunk nmsChunk = ((CraftChunk) c).getHandle();
-            MultiPaper.releaseChunk(nmsChunk.getPos(), nmsChunk.world);
-            chunkSaveHandlers.forEach(handler -> handler.accept(c));
-            nmsChunk.world.getChunkProvider().playerChunkMap.saveChunk(nmsChunk);
-        }
-
-        WorldServer worldServer = ((CraftChunk) chunk).getHandle().world;
-        if (worldServer.getMinecraftServer().hasStopped()) {
-            LOGGER.info("Server is stopping, running garbage collector before flushing chunk writes");
-            System.gc();
-            LOGGER.info("Server is stopping, flushing chunk writes");
-            worldServer.asyncChunkTaskManager.flush();
-            LOGGER.info("Server is stopping, running garbage collector after flushing chunk writes");
-            System.gc();
-        }
-
-        try {
-            Thread.sleep(50);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-        }
+            MultiPaper.willSaveChunk(c);
+        }
+
+//        for (Chunk c : zone.chunks) {
+//            net.minecraft.world.level.chunk.Chunk nmsChunk = ((CraftChunk) c).getHandle();
+//            MultiPaper.releaseChunk(nmsChunk.getPos(), nmsChunk.world);
+//            chunkSaveHandlers.forEach(handler -> handler.accept(c));
+//            nmsChunk.world.getChunkProvider().playerChunkMap.saveChunk(nmsChunk);
+//        }
+//
+//        WorldServer worldServer = ((CraftChunk) chunk).getHandle().world;
+//        if (worldServer.getMinecraftServer().hasStopped()) {
+//            LOGGER.info("Server is stopping, running garbage collector before flushing chunk writes");
+//            System.gc();
+//            LOGGER.info("Server is stopping, flushing chunk writes");
+//            worldServer.asyncChunkTaskManager.flush();
+//            LOGGER.info("Server is stopping, running garbage collector after flushing chunk writes");
+//            System.gc();
+//        }
 
         for (Player player : toSend) {
             ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
@@ -180,41 +80,14 @@ public class Zone {
                 player.setItemOnCursor(null);
             }
             player.saveData();
-            BungeeCord.connectPlayer(player, server);
-            
-            // Check back in 15 seconds to see if they've moved servers yet
-            ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> ensureMovedServer(player), 15 * 20, "Ensure player moved servers");
+            player.kick(Component.text("sendto:" + server));
         }
-
+        
         ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> zone.chunks.forEach(Chunk::unload), 0, "Unload Chunks");
 
         return toSend;
     }
 
-    /** 
-     * Ensure a player has been moved to another server. If they haven't, put
-     * them back on this server and check if they still need to be moved.
-     */
-    private static void ensureMovedServer(Player player) {
-        // Remove the player from beingSentToAnotherServer will put them back on the server
-        if (player.isOnline() && beingSentToAnotherServer.remove(player)) {
-            ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = false;
-            zonesToUnload.remove(player);
-            
-            LOGGER.info(player.getName() + " failed to move servers, checking if they still need to");
-            
-            // If the chunk isn't loaded, paper'll load it and do these checks later
-            if (player.getLocation().isChunkLoaded()) {
-                CraftChunk chunk = (CraftChunk) player.getChunk();
-                
-                // Check if the chunk should merge, and if it shouldn't, try to lock the chunk
-                if (!checkIfShouldMerge(chunk)) {
-                    MultiPaper.lockChunk(chunk.getHandle().getPos(), chunk.getCraftWorld().getHandle());
-                }
-            }
-        }
-    }
-
     public static boolean checkIfShouldMerge(Chunk chunk) {
         ExternalServer serverTo = MultiPaper.getMe();
 
@@ -264,45 +137,25 @@ public class Zone {
         return true;
     }
 
-    public static void onPlayerDisconnect(Player player) {
-        Location location = player.getLocation();
-        String name = player.getName();
-        ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
-            beingSentToAnotherServer.remove(player);
-
-            Zone zone = zonesToUnload.remove(player);
-            if (zone != null) {
-                Zone zone2 = new Zone(location.getWorld(), location.getBlockX() >> 4, location.getBlockZ() >> 4);
-
-                zone.chunks.forEach(zone2::mapChunks);
-
-                if (zone2.players.isEmpty()) {
-                    LOGGER.info(name + " has left: Unloading zone with " + zone2.chunks.size() + " loaded chunks");
-                    zone2.chunks.forEach(Chunk::unload);
-                }
-            }
-        }, 1, "Remove player from beingSentToAnotherServer");
-    }
-
     private final HashSet<Chunk> chunks = new HashSet<>();
     private final HashSet<Player> players = new HashSet<>();
     private final int chunkLimit;
 
-    private Zone(Chunk chunk) {
+    public Zone(Chunk chunk) {
         this(chunk, Integer.MAX_VALUE);
     }
 
-    private Zone(Chunk chunk, int chunkLimit) {
+    public Zone(Chunk chunk, int chunkLimit) {
         this.chunkLimit = chunkLimit;
         mapChunks(chunk);
         mapPlayers(chunk.getWorld());
     }
 
-    private Zone(World world, int cx, int cz) {
+    public Zone(World world, int cx, int cz) {
         this(world, cx, cz, Integer.MAX_VALUE);
     }
 
-    private Zone(World world, int cx, int cz, int chunkLimit) {
+    public Zone(World world, int cx, int cz, int chunkLimit) {
         this.chunkLimit = chunkLimit;
         mapChunks(world, cx, cz);
         mapPlayers(world);
@@ -346,4 +199,10 @@ public class Zone {
             }
         }
     }
+
+    @NotNull
+    @Override
+    public Iterator<Chunk> iterator() {
+        return chunks.iterator();
+    }
 }
