From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Wed, 13 Jul 2022 12:14:11 +1000
Subject: [PATCH] Sync game events


diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index e359eb9ace40569e19820171ccd01349a95b666f..7bb51321167a53504a97bdd16591f7ac0a8feea9 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -175,6 +175,7 @@ import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
 import puregero.multipaper.MultiPaperEntitiesHandler;
+import puregero.multipaper.MultiPaperGameEventHandler;
 import puregero.multipaper.MultiPaperInactiveTracker;
 import puregero.multipaper.externalserverprotocol.SpawnUpdatePacket;
 import puregero.multipaper.externalserverprotocol.TimeUpdatePacket;
@@ -1657,6 +1658,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             GameEvent.Message gameevent_b = (GameEvent.Message) iterator.next();
             GameEventListener gameeventlistener = gameevent_b.recipient();
 
+            if (MultiPaperGameEventHandler.onGameEvent(gameeventlistener, this, gameevent_b)) continue; // MultiPaper
             gameeventlistener.handleGameEvent(this, gameevent_b);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
index 75811a1c66ee3249708d11ceef4c5190c6ca2a4b..cdfa7be3b80971060cd6187df0b46595816df3c3 100644
--- a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
@@ -68,7 +68,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationL
     protected static final ImmutableList<SensorType<? extends Sensor<? super Allay>>> SENSOR_TYPES = ImmutableList.of(SensorType.NEAREST_LIVING_ENTITIES, SensorType.NEAREST_PLAYERS, SensorType.HURT_BY, SensorType.NEAREST_ITEMS);
     protected static final ImmutableList<MemoryModuleType<?>> MEMORY_TYPES = ImmutableList.of(MemoryModuleType.PATH, MemoryModuleType.LOOK_TARGET, MemoryModuleType.NEAREST_VISIBLE_LIVING_ENTITIES, MemoryModuleType.WALK_TARGET, MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, MemoryModuleType.HURT_BY, MemoryModuleType.NEAREST_VISIBLE_WANTED_ITEM, MemoryModuleType.LIKED_PLAYER, MemoryModuleType.LIKED_NOTEBLOCK_POSITION, MemoryModuleType.LIKED_NOTEBLOCK_COOLDOWN_TICKS, MemoryModuleType.ITEM_PICKUP_COOLDOWN_TICKS, MemoryModuleType.IS_PANICKING);
     public static final ImmutableList<Float> THROW_SOUND_PITCHES = ImmutableList.of(0.5625F, 0.625F, 0.75F, 0.9375F, 1.0F, 1.0F, 1.125F, 1.25F, 1.5F, 1.875F, 2.0F, 2.25F, 2.5F, 3.0F, 3.75F, 4.0F);
-    private final DynamicGameEventListener<VibrationListener> dynamicGameEventListener;
+    private final DynamicGameEventListener<VibrationListener> dynamicGameEventListener; public VibrationListener getVibrationListener() { return dynamicGameEventListener.getListener(); } // MultiPaper - add getter
     private final SimpleContainer inventory = new SimpleContainer(1);
     private float holdingItemAnimationTicks;
     private float holdingItemAnimationTicks0;
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 27bd70dc30c8472e5a80f3273f9233a0392f831d..2ab710af5d9727b4c8a062e31b5def5cafd47ee6 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -107,7 +107,7 @@ public class Warden extends Monster implements VibrationListener.VibrationListen
     public AnimationState diggingAnimationState = new AnimationState();
     public AnimationState attackAnimationState = new AnimationState();
     public AnimationState sonicBoomAnimationState = new AnimationState();
-    private final DynamicGameEventListener<VibrationListener> dynamicGameEventListener = new DynamicGameEventListener<>(new VibrationListener(new EntityPositionSource(this, this.getEyeHeight()), 16, this, (VibrationListener.ReceivingEvent) null, 0.0F, 0));
+    private final DynamicGameEventListener<VibrationListener> dynamicGameEventListener = new DynamicGameEventListener<>(new VibrationListener(new EntityPositionSource(this, this.getEyeHeight()), 16, this, (VibrationListener.ReceivingEvent) null, 0.0F, 0)); public VibrationListener getVibrationListener() { return dynamicGameEventListener.getListener(); } // MultiPaper - add getter
     private AngerManagement angerManagement = new AngerManagement(this::canTargetEntity, Collections.emptyList());
 
     public Warden(EntityType<? extends Monster> type, Level world) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index 22c309343299e60ed8028229b7f134109001ff35..4c1515fe7d5c05f4f15007e7f06cc5a7d7377d90 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -18,6 +18,7 @@ import net.minecraft.world.level.gameevent.BlockPositionSource;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.gameevent.GameEventListener;
 import net.minecraft.world.level.gameevent.PositionSource;
+import puregero.multipaper.MultiPaperGameEventHandler;
 
 public class SculkCatalystBlockEntity extends BlockEntity implements GameEventListener {
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
index 579a96d2d6c99d6587ea182f52b6df918f595f17..977334a13d0feab3a498da69c41c9f630dcc59c6 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkSensorBlockEntity.java
@@ -19,7 +19,7 @@ import org.slf4j.Logger;
 
 public class SculkSensorBlockEntity extends BlockEntity implements VibrationListener.VibrationListenerConfig {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private VibrationListener listener;
+    private VibrationListener listener; public VibrationListener getVibrationListener() { return listener; } // MultiPaper - add getter
     public int lastVibrationFrequency;
 
     public SculkSensorBlockEntity(BlockPos pos, BlockState state) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
index b733c072246dbc602b24c6422867b164dcbdb779..2f0d7d18dbee45df5476699fd71cd8886d8a1a79 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/SculkShriekerBlockEntity.java
@@ -53,7 +53,7 @@ public class SculkShriekerBlockEntity extends BlockEntity implements VibrationLi
     });
     private static final int SHRIEKING_TICKS = 90;
     public int warningLevel;
-    private VibrationListener listener = new VibrationListener(new BlockPositionSource(this.worldPosition), 8, this, (VibrationListener.ReceivingEvent)null, 0.0F, 0);
+    private VibrationListener listener = new VibrationListener(new BlockPositionSource(this.worldPosition), 8, this, (VibrationListener.ReceivingEvent)null, 0.0F, 0); public VibrationListener getVibrationListener() { return listener; } // MultiPaper - add getter
 
     public SculkShriekerBlockEntity(BlockPos pos, BlockState state) {
         super(BlockEntityType.SCULK_SHRIEKER, pos, state);
diff --git a/src/main/java/net/minecraft/world/level/gameevent/vibrations/VibrationListener.java b/src/main/java/net/minecraft/world/level/gameevent/vibrations/VibrationListener.java
index e45f54534bbf054eaf0008546ff459d4c11ddd50..f2af1a52a4a36846f9db623ba8ad47c918a8e929 100644
--- a/src/main/java/net/minecraft/world/level/gameevent/vibrations/VibrationListener.java
+++ b/src/main/java/net/minecraft/world/level/gameevent/vibrations/VibrationListener.java
@@ -30,13 +30,14 @@ import net.minecraft.world.phys.Vec3;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockReceiveGameEvent;
+import puregero.multipaper.MultiPaperGameEventHandler;
 // CraftBukkit end
 
 public class VibrationListener implements GameEventListener {
 
     protected final PositionSource listenerSource;
     public int listenerRange;
-    protected final VibrationListener.VibrationListenerConfig config;
+    public final VibrationListener.VibrationListenerConfig config; // MultiPaper - make public
     @Nullable
     protected VibrationListener.ReceivingEvent receivingEvent;
     protected float receivingDistance;
@@ -207,6 +208,8 @@ public class VibrationListener implements GameEventListener {
         void onSignalReceive(ServerLevel world, GameEventListener listener, BlockPos pos, GameEvent event, @Nullable Entity entity, @Nullable Entity sourceEntity, float distance);
 
         default void onSignalSchedule() {}
+
+        VibrationListener getVibrationListener(); // MultiPaper
     }
 
     public static record ReceivingEvent(GameEvent gameEvent, float distance, Vec3 pos, @Nullable UUID uuid, @Nullable UUID projectileOwnerUuid, @Nullable Entity entity) {
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index f1f00071b97e5c95c31de81ab4485c2db3b4cc18..c8bd728b3e52b1390a5950c63b288eac4894af0c 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -103,6 +103,8 @@ public class MultiPaper {
                 } else {
                     externalPlayer.setSleepCounter(0);
                 }
+
+                externalPlayer.getWardenSpawnTracker().tick();
             }
 
             player.syncExperience();
diff --git a/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java b/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..00a3782bb34cf898602d730396931a6bdc960d0b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperGameEventHandler.java
@@ -0,0 +1,71 @@
+package puregero.multipaper;
+
+import com.mojang.datafixers.util.Either;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.gameevent.GameEventListener;
+import net.minecraft.world.level.gameevent.vibrations.VibrationListener;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.GameEventPacket;
+
+import java.util.Optional;
+
+public class MultiPaperGameEventHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperGameEventHandler.class.getSimpleName());
+
+    public static Either<Entity, BlockEntity> getEntity(Object object) {
+        if (object instanceof Entity entity) {
+            return Either.left(entity);
+        } else if (object instanceof BlockEntity blockEntity) {
+            return Either.right(blockEntity);
+        } else if (object instanceof VibrationListener vibrationListener) {
+            return getEntity(vibrationListener.config);
+        } else {
+            throw new IllegalArgumentException(object + " could not be converted to either an Entity or a BlockEntity!");
+        }
+    }
+
+    public static Optional<ExternalServer> getControllingServer(Either<Entity, BlockEntity> either) {
+        return either.map(
+                entity -> {
+                    Entity controller = MultiPaperEntitiesHandler.getControllingPassenger(entity);
+                    if (controller instanceof ExternalPlayer externalPlayer) {
+                        return Optional.of(externalPlayer.externalServerConnection.externalServer);
+                    } else if (controller instanceof ServerPlayer) {
+                        return Optional.empty();
+                    } else {
+                        LevelChunk chunk = entity.level.getChunkIfLoaded(entity.blockPosition());
+                        if (chunk != null && chunk.externalOwner != null && !chunk.externalOwner.isMe()) {
+                            return Optional.of(chunk.externalOwner);
+                        } else {
+                            return Optional.empty();
+                        }
+                    }
+                },
+                blockEntity -> {
+                    LevelChunk chunk = blockEntity.getLevel().getChunkIfLoaded(blockEntity.getBlockPos());
+                    if (chunk != null && chunk.externalOwner != null && !chunk.externalOwner.isMe()) {
+                        return Optional.of(chunk.externalOwner);
+                    } else {
+                        return Optional.empty();
+                    }
+                }
+        );
+    }
+
+    public static boolean onGameEvent(GameEventListener gameEventListener, ServerLevel world, GameEvent.Message event) {
+        Either<Entity, BlockEntity> either = getEntity(gameEventListener);
+        Optional<ExternalServer> controllingServer = getControllingServer(either);
+
+        controllingServer.ifPresent(
+                externalServer -> externalServer.getConnection().send(new GameEventPacket(either, world, event))
+        );
+        return controllingServer.isPresent();
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 3fe08e04f8669089f5cb64730401315808e78085..f560c927a712dea9f0e5b3900af402d3cb804604 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -74,6 +74,7 @@ public class ExternalServerPacketSerializer {
         addPacket(RaidJoinPacket.class, RaidJoinPacket::new);
         addPacket(SetPoiPacket.class, SetPoiPacket::new);
         addPacket(AddDeltaMovementPacket.class, AddDeltaMovementPacket::new);
+        addPacket(GameEventPacket.class, GameEventPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f8da79976831f83a8ad288d18f134ec591fbddd
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/GameEventPacket.java
@@ -0,0 +1,121 @@
+package puregero.multipaper.externalserverprotocol;
+
+import com.mojang.datafixers.util.Either;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.gameevent.GameEventListener;
+import net.minecraft.world.level.gameevent.vibrations.VibrationListener;
+import net.minecraft.world.phys.Vec3;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.Optional;
+import java.util.UUID;
+
+public class GameEventPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(GameEventPacket.class.getSimpleName());
+
+    private final UUID world;
+    private final Either<UUID, BlockPos> id;
+    private final GameEvent gameEvent;
+    private final Vec3 sourcePos;
+    private final Optional<UUID> sourceUuid;
+    private final Optional<BlockState> affectedState;
+
+    public GameEventPacket(Either<Entity, BlockEntity> either, ServerLevel level, GameEvent.Message gameEvent) {
+        this.world = level.getWorld().getUID();
+        this.id = either.mapBoth(
+                Entity::getUUID,
+                BlockEntity::getBlockPos
+        );
+        this.gameEvent = gameEvent.gameEvent();
+        this.sourcePos = gameEvent.source();
+        this.sourceUuid = Optional.ofNullable(gameEvent.context().sourceEntity()).map(Entity::getUUID);
+        this.affectedState = Optional.ofNullable(gameEvent.context().affectedState());
+    }
+
+    public GameEventPacket(FriendlyByteBuf in) {
+        this.world = in.readUUID();
+        if (in.readBoolean()) {
+            this.id = Either.left(in.readUUID());
+        } else {
+            this.id = Either.right(in.readBlockPos());
+        }
+        this.gameEvent = in.readById(Registry.GAME_EVENT);
+        this.sourcePos = new Vec3(in.readDouble(), in.readDouble(), in.readDouble());
+        this.sourceUuid = in.readOptional(FriendlyByteBuf::readUUID);
+        this.affectedState = in.readOptional(buf -> buf.readById(Block.BLOCK_STATE_REGISTRY));
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUUID(this.world);
+        out.writeBoolean(this.id.left().isPresent());
+        this.id.ifLeft(out::writeUUID);
+        this.id.ifRight(out::writeBlockPos);
+        out.writeId(Registry.GAME_EVENT, this.gameEvent);
+        out.writeDouble(this.sourcePos.x());
+        out.writeDouble(this.sourcePos.y());
+        out.writeDouble(this.sourcePos.z());
+        out.writeOptional(this.sourceUuid, FriendlyByteBuf::writeUUID);
+        out.writeOptional(this.affectedState, (buf, value) -> buf.writeId(Block.BLOCK_STATE_REGISTRY, value));
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(this.world)).getHandle();
+            Object entity = resolveId(level);
+            if (entity == null) {
+                LOGGER.warn("Could not find entity for " + this.id);
+            }
+
+            GameEventListener gameEventListener = getGameEventListener(entity);
+
+            gameEventListener.handleGameEvent(level, new GameEvent.Message(gameEvent, sourcePos, GameEvent.Context.of(sourceUuid.map(level::getEntity).orElse(null), affectedState.orElse(null)), gameEventListener, getPos(entity)));
+        });
+    }
+
+    private GameEventListener getGameEventListener(Object entity) {
+        if (entity instanceof GameEventListener gameEventListener) {
+            return gameEventListener;
+        } else if (entity instanceof VibrationListener.VibrationListenerConfig vibrationListenerConfig) {
+            return vibrationListenerConfig.getVibrationListener();
+        } else {
+            throw new IllegalArgumentException("Could not figure out how to convert " + entity + " to a GameEventListener");
+        }
+    }
+
+    private Vec3 getPos(Object object) {
+        if (object instanceof Entity entity) {
+            return entity.position();
+        } else if (object instanceof BlockEntity blockEntity) {
+            return new Vec3(blockEntity.getBlockPos().getX() + 0.5, blockEntity.getBlockPos().getY(), blockEntity.getBlockPos().getZ() + 0.5);
+        } else {
+            throw new IllegalArgumentException(object + " could not be converted to either an Entity or a BlockEntity to get it's position!");
+        }
+    }
+
+    private Object resolveId(ServerLevel level) {
+        return this.id.map(
+                level::getEntity,
+                blockPos -> {
+                    LevelChunk levelChunk = level.getChunkIfLoaded(blockPos);
+                    return levelChunk == null ? null : levelChunk.getBlockEntity(blockPos);
+                }
+        );
+    }
+}
