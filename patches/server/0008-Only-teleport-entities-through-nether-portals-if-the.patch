From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Feb 2021 00:11:10 +1000
Subject: [PATCH] Only teleport entities through nether portals if the other
 side is locked


diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 9f7d163dc4a542b7e23d08207f6cf4b3189593f1..9db03aa909714a5108e6b43b29ab4d6e1375e3d5 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -26,7 +26,7 @@ import puregero.multipaper.MultiPaper;
 public class ChunkProviderServer extends IChunkProvider {
 
     private static final List<ChunkStatus> b = ChunkStatus.a(); static final List<ChunkStatus> getPossibleChunkStatuses() { return ChunkProviderServer.b; } // Paper - OBFHELPER
-    private final ChunkMapDistance chunkMapDistance;
+    public final ChunkMapDistance chunkMapDistance; // MultiPaper - private -> public
     public final ChunkGenerator chunkGenerator;
     private final WorldServer world;
     public final Thread serverThread; // Paper - private -> public
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index da8d549423b038e1a5bcbacf30680ecd51bb2b13..166a0fd0e063985168eddc3330e2d42ffd8f9cc8 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -48,6 +48,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements INamableTileEntity, ICommandListener, KeyedObject { // Paper
@@ -2586,6 +2587,16 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             if (shapedetectorshape == null) {
                 return null;
             } else {
+                
+                // MultiPaper start - only teleport the entity if the destination chunk is locked
+                int cx = (int) shapedetectorshape.position.x >> 4;
+                int cz = (int) shapedetectorshape.position.z >> 4;
+                if (!MultiPaper.isChunkLocked(worldserver, cx, cz)) {
+                    MultiPaper.onChunkLock(worldserver, cx, cz, () -> teleportTo(shapedetectorshape.world, new BlockPosition(shapedetectorshape.position)));
+                    return null;
+                }
+                // MultiPaper end
+                
                 // CraftBukkit start
                 worldserver = shapedetectorshape.world;
                 this.decouple();
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index d0f128d0a3f514a9843cd5af40f8eb3478ba6b35..9f3a1eaa4eb506927aca4095e4e52beb64fca96a 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -8,20 +8,21 @@ import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 
 import java.io.*;
 import java.nio.file.Files;
-import java.util.HashSet;
-import java.util.UUID;
+import java.util.*;
 
 public class MultiPaper {
 
     private static final Logger LOGGER = LogManager.getLogger();
     private static MultiPaperConnection multiPaperConnection = null;
     private static long last10Seconds = System.currentTimeMillis();
-    private static HashSet<ChunkKey> lockedChunks = new HashSet<>();
+    public static HashSet<ChunkKey> lockedChunks = new HashSet<>();
+    private static HashMap<ChunkKey, List<Runnable>> onChunkLockCallbacks = new HashMap<>();
 
     private static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
@@ -126,23 +127,29 @@ public class MultiPaper {
 
     public static void lockChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
         try {
-            if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z)) {
+            if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair)) {
                 return;
             }
 
             getConnection().lockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z).thenAccept(holder -> {
-                if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z)) {
+                if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair)) {
                     releaseChunk(chunkcoordintpair, worldServer);
                     return;
                 }
-
-                lockedChunks.add(new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z));
-
+                
                 new Thread(() -> {
                     if (holder != null) {
                         Zone.doMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z), holder);
-                    } else {
-                        Zone.checkIfShouldMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z));
+                    } else if (!Zone.checkIfShouldMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z))) {
+                        ChunkKey key = new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
+
+                        lockedChunks.add(key);
+
+                        List<Runnable> callbacks = onChunkLockCallbacks.remove(key);
+                        
+                        if (callbacks != null) {
+                            callbacks.forEach(callback -> ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(callback, 0, "onChunkLockCallback-" + callback.getClass().getName()));
+                        }
                     }
                 }).start();
             });
@@ -342,6 +349,16 @@ public class MultiPaper {
         return false;
     }
 
+    public static void onChunkLock(WorldServer world, int chunkX, int chunkZ, Runnable runnable) {
+        ChunkKey key = new ChunkKey(world.worldDataServer.getName(), chunkX, chunkZ);
+        
+        if (lockedChunks.contains(key)) {
+            runnable.run();
+        } else {
+            onChunkLockCallbacks.computeIfAbsent(key, key2 -> new ArrayList<>()).add(runnable);
+        }    
+    }
+
     public static boolean shouldTickEntity(WorldServer worldServer, Entity entity) {
         for (EntityPlayer player : worldServer.players) {
             if (isPlayerSafe(player) && player.shouldTickEntities && chunkDistance(player, entity) <= Bukkit.getViewDistance()) {
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
index 959699e2aa6747c87b70c56974bc2ca58fc1e5a8..3b12508c2b798485ba20414375c0cb4c65ce0544 100644
--- a/src/main/java/puregero/multipaper/Zone.java
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -1,6 +1,6 @@
 package puregero.multipaper;
 
-import net.minecraft.server.WorldServer;
+import net.minecraft.server.*;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
@@ -8,6 +8,7 @@ import org.bukkit.Chunk;
 import org.bukkit.Location;
 import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.entity.Player;
@@ -28,16 +29,29 @@ public class Zone {
         chunkSaveHandlers.add(handler);
     }
 
-    public static boolean shouldLockChunk(String world, int cx, int cz) {
+    public static boolean shouldLockChunk(String world, ChunkCoordIntPair coordIntPair) {
+        ArraySetSorted<Ticket<?>> tickets = ((CraftWorld) Bukkit.getWorld(world)).getHandle().chunkProvider.chunkMapDistance.tickets.get(coordIntPair.pair());
         for (Player player : Bukkit.getWorld(world).getPlayers()) {
             if (!beingSentToAnotherServer.contains(player) &&
-                    Math.abs((player.getLocation().getBlockX() >> 4) - cx) <= Bukkit.getViewDistance() + 6 &&
-                    Math.abs((player.getLocation().getBlockZ() >> 4) - cz) <= Bukkit.getViewDistance() + 6) {
+                    Math.abs((player.getLocation().getBlockX() >> 4) - coordIntPair.x) <= Bukkit.getViewDistance() + 6 &&
+                    Math.abs((player.getLocation().getBlockZ() >> 4) - coordIntPair.x) <= Bukkit.getViewDistance() + 6) {
                 return true;
             }
         }
 
-        return false;
+        if (tickets == null) {
+            return false;
+        }
+
+        for (Ticket<?> ticket : tickets) {
+            if (ticket.getTicketType() == TicketType.PLAYER
+                    || ticket.getTicketType() == TicketType.PLUGIN
+                    || ticket.getTicketType() == TicketType.ASYNC_LOAD) {
+                return false;
+            }
+        }
+        
+        return true;
     }
 
     public static boolean isBeingSentToAnotherServer(Player player) {
@@ -49,6 +63,38 @@ public class Zone {
 
         if (zone.players.size() > 0) {
             return doMerge(chunk, zone, server);
+        } else {
+            return doMergeOppositeDimension(chunk, server);
+        }
+    }
+    
+    private static Collection<Player> doMergeOppositeDimension(Chunk chunk, String server) {
+        Chunk oppositeChunk = null;
+        
+        if (chunk.getWorld().getEnvironment() == World.Environment.NORMAL) {
+            World world = Bukkit.getWorld(chunk.getWorld().getName() + "_nether");
+            int cx = chunk.getX() / 8;
+            int cz = chunk.getZ() / 8;
+            if (world.isChunkLoaded(cx, cz)) {
+                oppositeChunk = world.getChunkAt(cx, cz);
+            }
+        } else if (chunk.getWorld().getEnvironment() == World.Environment.NETHER) {
+            World world = Bukkit.getWorld(chunk.getWorld().getName().split("_")[0]);
+            int cx = chunk.getX() * 8;
+            int cz = chunk.getZ() * 8;
+            if (world.isChunkLoaded(cx, cz)) {
+                oppositeChunk = world.getChunkAt(cx, cz);
+            }
+        }
+        
+        if (oppositeChunk == null) {
+            return Collections.emptySet();
+        }
+        
+        Zone zone = new Zone(oppositeChunk);
+        
+        if (zone.players.size() > 0) {
+            return doMerge(oppositeChunk, zone, server);
         }
 
         return zone.players;
@@ -80,11 +126,7 @@ public class Zone {
             nmsChunk.world.getChunkProvider().playerChunkMap.saveChunk(nmsChunk);
         }
 
-        WorldServer worldServer = ((CraftChunk) chunk).getHandle().world;
-        if (worldServer.getMinecraftServer().hasStopped()) {
-            LOGGER.info("Server is stopping, flushing chunk writes");
-            worldServer.asyncChunkTaskManager.flush();
-        }
+        ((CraftChunk) chunk).getHandle().world.asyncChunkTaskManager.flush();
 
         for (Player player : toSend) {
             ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
@@ -232,11 +274,16 @@ public class Zone {
     }
 
     private void mapChunks(World world, int cx, int cz) {
-        for (int dx = -2; dx <= 2; dx ++) {
-            for (int dz = -2; dz <= 2; dz ++) {
+        if (world == null) {
+            return;
+        }
+        
+        for (int dx = -4; dx <= 4; dx ++) {
+            for (int dz = -4; dz <= 4; dz ++) {
                 if (world.isChunkLoaded(cx + dx, cz + dz)) {
                     mapChunks(world.getChunkAt(cx + dx, cz + dz));
                 }
+                
             }
         }
     }
