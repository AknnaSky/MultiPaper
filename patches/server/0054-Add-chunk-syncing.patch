From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
index ef8dcbb6bbc0769e9ccfdadb05e6a46c070eda98..2f16f068e0c30a122eb6c2c76a8054b3bbccc483 100644
--- a/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
+++ b/src/main/java/ca/spottedleaf/starlight/common/light/StarLightInterface.java
@@ -373,6 +373,18 @@ public final class StarLightInterface {
         }
     }
 
+    // MultiPaper start
+    public CompletableFuture<Void> getChunkFuture(final ChunkPos chunkPos) {
+        LightQueue.ChunkTasks tasks = lightQueue.chunkTasks.get(chunkPos.longKey);
+
+        if (tasks == null) {
+            return CompletableFuture.completedFuture(null);
+        }
+
+        return tasks.onComplete;
+    }
+    // MultiPaper end
+
     public CompletableFuture<Void> blockChange(final BlockPos pos) {
         if (this.world == null || pos.getY() < WorldUtil.getMinBlockY(this.world) || pos.getY() > WorldUtil.getMaxBlockY(this.world)) { // empty world
             return null;
diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
index 7bab31a312463cc963d9621cdc543a281459bd32..7d49a0bdb11afd8616a97d6c7f043f9d2b0ce073 100644
--- a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Object.java
@@ -42,6 +42,12 @@ public class QueuedChangesMapLong2Object<V> {
         return this.updatingMap.remove(k);
     }
 
+    // MultiPaper start
+    public boolean isQueuedToRemove(final long k) {
+        return this.queuedChanges.get(k) == REMOVED;
+    }
+    // MultiPaper end
+
     public V getUpdating(final long k) {
         return this.updatingMap.get(k);
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index d271871563fa883efb77b35ec3b1dfbba87f0b62..9f8c73d3ad985160f82fb58bd28b37d4613ef07a 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -16,6 +16,7 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
@@ -38,6 +39,9 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
 public class ChunkHolder {
 
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
@@ -337,11 +341,19 @@ public class ChunkHolder {
             if (packet != null) {
                 this.broadcast(packet, false);
             }
+
+            MultiPaperChunkHandler.onBlockUpdate(this, ClientboundBlockEntityDataPacket.create(tileentity, BlockEntity::saveWithFullMetadata)); // MultiPaper - sync the full block with external servers
         }
 
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(this, packet);
+        }
+        // MultiPaper end
+        
         this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((entityplayer) -> {
             entityplayer.connection.send(packet);
         });
@@ -629,6 +641,7 @@ public class ChunkHolder {
             // Paper start - entity ticking chunk set
             LevelChunk chunkIfCached = this.getFullChunkUnchecked();
             if (chunkIfCached != null) {
+                if (chunkIfCached.hasExternalLockRequest) MultiPaper.unlockChunk(chunkIfCached); // MultiPaper
                 this.chunkMap.level.getChunkSource().entityTickingChunks.remove(chunkIfCached);
             }
             // Paper end - entity ticking chunk set
@@ -747,6 +760,40 @@ public class ChunkHolder {
         this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
     }
 
+    // MultiPaper start
+    public void replaceProtoChunk(ChunkAccess protoChunk) {
+        if (protoChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+            protoChunk = imposterProtoChunk.getWrapped();
+        }
+
+        for (int i = protoChunk.getStatus().getIndex() + 1; i < this.futures.length(); ++i) {
+            this.futures.set(i, null);
+        }
+
+        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.left(protoChunk);
+
+        for (int i = 0; i <= protoChunk.getStatus().getIndex(); ++i) {
+            this.futures.set(i, CompletableFuture.completedFuture(either));
+        }
+
+        this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(protoChunk)), "replaceProtoWithProto");
+    }
+
+    public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getLastAvailableChunkFuture() {
+        for (int i = ChunkHolder.CHUNK_STATUSES.size() - 1; i >= 0; --i) {
+            ChunkStatus chunkstatus = ChunkHolder.CHUNK_STATUSES.get(i);
+            CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> completablefuture = this.getFutureIfPresentUnchecked(chunkstatus);
+
+            if (completablefuture.getNow(Either.left(null)).right().isEmpty()) {
+                // If there's no error, this chunk must be loading
+                return completablefuture;
+            }
+        }
+
+        return ChunkHolder.UNLOADED_CHUNK_FUTURE;
+    }
+    // MultiPaper end
+
     @FunctionalInterface
     public interface LevelChangeListener {
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 83836acbef396958ff21ae6cffb4b247f1eec770..c55a727d09d95ae0a640e77f77961af74beb397f 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -110,6 +110,7 @@ import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -1019,6 +1020,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 // Paper start
                 boolean removed;
                 if ((removed = this.pendingUnloads.remove(pos, holder)) && ichunkaccess != null) {
+                    MultiPaperChunkHandler.onChunkUnload(level, holder.pos, ichunkaccess); // MultiPaper
                     for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
                         this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
                     }
@@ -1049,6 +1051,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     this.lightEngine.tryScheduleUpdate();
                     this.progressListener.onStatusChange(ichunkaccess.getPos(), (ChunkStatus) null);
                 } else if (removed) { // Paper start
+                    MultiPaperChunkHandler.onChunkUnload(level, holder.pos, ichunkaccess); // MultiPaper
                     for (int index = 0, len = this.regionManagers.size(); index < len; ++index) {
                         this.regionManagers.get(index).removeChunk(holder.pos.x, holder.pos.z);
                     }
@@ -1228,6 +1231,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         return this.protoChunkToFullChunk(holder);
                     }, list, false);
 
+                    MultiPaper.chunkChangedStatus(level, chunkcoordintpair, requiredStatus); // MultiPaper
+
                     this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
                     return completablefuture1;
                 } catch (Exception exception) {
@@ -1668,6 +1673,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, level); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1679,6 +1685,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, level, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1722,6 +1734,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index c710b4ef9eef02c050dd7e3a6e0824690522d502..7e5872cd67119eeb9f3d5d16c4b74c7a1984e86e 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -50,6 +50,7 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
 import java.util.function.Function; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -1046,6 +1047,13 @@ public class ServerChunkCache extends ChunkSource {
                 // Paper end - optimise chunk tick iteration
                 ChunkPos chunkcoordintpair = chunk1.getPos();
 
+                // MultiPaper start - Don't tick this chunk if we don't own it
+                boolean isTicking = chunkMap.getDistanceManager().inEntityTickingRange(chunkcoordintpair.longKey);
+                if (isTicking && !chunk1.hasExternalLockRequest) MultiPaper.lockChunk(chunk1);
+                if (!isTicking && chunk1.hasExternalLockRequest) MultiPaper.unlockChunk(chunk1);
+                if (!MultiPaper.isChunkLocal(chunk1)) continue;
+                // MultiPaper end - Don't tick this chunk if we don't own it
+
                 if ((true || this.level.isPositionEntityTicking(chunkcoordintpair)) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
                     chunk1.incrementInhabitedTime(j);
                     if (flag2 && (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || _pufferfish_spawnCountsReady.get()) && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning & optimise chunk tick iteration
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 3e9979de1a49c49e3ac12c54d2c177b4972ff481..bc66aaae62488f187dc23cfe379d20561e019ec1 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -161,6 +161,8 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -487,8 +489,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // CraftBukkit end
         this.players = Lists.newArrayList();
         this.entityTickList = new EntityTickList();
-        this.blockTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
-        this.fluidTicks = new LevelTicks<>(this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier());
+        this.blockTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
+        this.fluidTicks = new LevelTicks<>(this, this::isPositionTickingWithEntitiesLoaded, this.getProfilerSupplier()); // MultiPaper - add level
         this.navigatingMobs = new ObjectOpenHashSet();
         this.blockEvents = new ObjectLinkedOpenHashSet();
         this.blockEventsToReschedule = new ArrayList(64);
@@ -2237,6 +2239,11 @@ public class ServerLevel extends Level implements WorldGenLevel {
                 return;
             }
             // CraftBukkit end
+            // MultiPaper start - run neighbour updates later if we're handling block changes
+            if (MultiPaperChunkHandler.blockUpdateChunk != null) {
+                MCUtil.ensureMain(() -> this.updateNeighborsAt(pos, block));
+            } else
+            // MultiPaper end - run neighbour updates later if we're handling block changes
             this.updateNeighborsAt(pos, block);
         }
 
diff --git a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
index ef898d7735504809e9187becb7a1471640de4845..b76176f217c69847ea5e3d41624ca02644bc49d8 100644
--- a/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
+++ b/src/main/java/net/minecraft/server/level/ThreadedLevelLightEngine.java
@@ -171,7 +171,7 @@ public class ThreadedLevelLightEngine extends LevelLightEngine implements AutoCl
     private final AtomicBoolean scheduled = new AtomicBoolean();
 
     // Paper start - replace light engine impl
-    protected final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine;
+    public final ca.spottedleaf.starlight.common.light.StarLightInterface theLightEngine; // MultiPaper - make public
     public final boolean hasBlockLight;
     public final boolean hasSkyLight;
     // Paper end - replace light engine impl
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index bbd9fdaa4b12543307b144da72b0604eae638cbb..9c88f14a6f17bb054887f236f1b2711202dadfa2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -32,6 +32,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -447,6 +448,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -458,6 +460,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index ab38b0e0394f53979dc3a32270814bf3cb41a330..c53190203f18e9ae40466454e1a3b76e7b8511d3 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -99,6 +99,7 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1056,6 +1057,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else if (this.shouldTickBlocksAt(ChunkPos.asLong(tickingblockentity.getPos()))) {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 5601d0c2fe635a2a4f073c333531e1a8adf1833c..880f19979cd013a14693d5b83c83e75ea5740cbd 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -8,6 +8,7 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
@@ -190,6 +191,7 @@ public abstract class BlockEntity implements io.papermc.paper.util.KeyedObject {
     }
 
     protected static void setChanged(Level world, BlockPos pos, BlockState state) {
+        ((ServerLevel) world).getChunkSource().blockChanged(pos); // MultiPaper
         world.blockEntityChanged(pos);
         if (!state.isAir()) {
             world.updateNeighbourForOutputSignal(pos, state.getBlock());
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
index 9b2c162c362fcf6093a3bf6da715ae8f18176c82..1fca610e6c1b217c381a0befbf71342fa3ed348f 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ComparatorBlockEntity.java
@@ -29,5 +29,6 @@ public class ComparatorBlockEntity extends BlockEntity {
 
     public void setOutputSignal(int outputSignal) {
         this.output = outputSignal;
+        setChanged(); // MultiPaper
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index c9c18cf84e4ee5c253bbc64a4b41e91f9f4c4bc7..86c5af0a3c09b63047efe3f2f8b6df3af37b8815 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -2,9 +2,8 @@ package net.minecraft.world.level.block.piston;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -39,7 +38,6 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 // CraftBukkit start
 import com.google.common.collect.ImmutableList;
-import java.util.AbstractList;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -445,6 +443,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 }
                 // Paper end - fix a variety of piston desync dupes
                 aiblockdata[j++] = iblockdata1;
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition3); // MultiPaper
             }
 
             if (retract) {
@@ -455,6 +454,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 map.remove(blockposition1);
                 world.setBlock(blockposition1, iblockdata1, 68);
                 world.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(blockposition1, iblockdata1, iblockdata3, dir, true, true));
+                ((ServerLevel) world).getChunkSource().blockChanged(blockposition1); // MultiPaper
             }
 
             BlockState iblockdata4 = Blocks.AIR.defaultBlockState();
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
index 613db573cef142e0ab1b24dc994677105a253042..d5af2e2662271c00b94189404a9e000a618ff053 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonMovingBlockEntity.java
@@ -24,6 +24,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaper;
 
 public class PistonMovingBlockEntity extends BlockEntity {
     private static final int TICKS_TO_EXTEND = 2;
@@ -253,7 +254,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
     }
 
     public void finalTick() {
-        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide)) {
+        if (this.level != null && (this.progressO < 1.0F || this.level.isClientSide) && !MultiPaper.isChunkExternal(level.getChunk(getBlockPos()))) { // MultiPaper
             this.progress = 1.0F;
             this.progressO = this.progress;
             this.level.removeBlockEntity(this.worldPosition);
@@ -307,6 +308,7 @@ public class PistonMovingBlockEntity extends BlockEntity {
                 blockEntity.progress = 1.0F;
             }
 
+            blockEntity.setChanged(); // MultiPaper
         }
     }
 
diff --git a/src/main/java/net/minecraft/world/level/border/WorldBorder.java b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
index 3063a45e5d124d4405e940daff24877866165d3f..490e7d65b0c469f5122509cc2f30fc9a5b977ce6 100644
--- a/src/main/java/net/minecraft/world/level/border/WorldBorder.java
+++ b/src/main/java/net/minecraft/world/level/border/WorldBorder.java
@@ -14,6 +14,7 @@ import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
 
 public class WorldBorder {
 
@@ -31,7 +32,7 @@ public class WorldBorder {
     public static final WorldBorder.Settings DEFAULT_SETTINGS = new WorldBorder.Settings(0.0D, 0.0D, 0.2D, 5.0D, 5, 15, 5.9999968E7D, 0L, 0.0D);
     public net.minecraft.server.level.ServerLevel world; // CraftBukkit
 
-    public WorldBorder() {}
+    public WorldBorder() { listeners.add(new MultiPaperWorldBorderHandler()); } // MultiPaper - Add our own world border listener
 
     public boolean isWithinBounds(BlockPos pos) {
         return (double) (pos.getX() + 1) > this.getMinX() && (double) pos.getX() < this.getMaxX() && (double) (pos.getZ() + 1) > this.getMinZ() && (double) pos.getZ() < this.getMaxZ();
@@ -293,6 +294,7 @@ public class WorldBorder {
     }
 
     public void applySettings(WorldBorder.Settings properties) {
+        MultiPaperWorldBorderHandler.updatingWorldBorder = true; // MultiPaper
         this.setCenter(properties.getCenterX(), properties.getCenterZ());
         this.setDamagePerBlock(properties.getDamagePerBlock());
         this.setDamageSafeZone(properties.getSafeZone());
@@ -303,7 +305,7 @@ public class WorldBorder {
         } else {
             this.setSize(properties.getSize());
         }
-
+        MultiPaperWorldBorderHandler.updatingWorldBorder = false; // MultiPaper
     }
 
     private class StaticBorderExtent implements WorldBorder.BorderExtent {
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index 5aeaaae6f15050a2da271fe196d0a234ecafc8a1..e44120e0aaf3513f2b0f72658b8919f88f4f3cec 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -56,7 +56,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
 
     private static final Logger LOGGER = LogManager.getLogger();
     protected final ShortList[] postProcessing;
-    protected volatile boolean unsaved;
+    public volatile boolean unsaved; // MultiPaper - make public
     private volatile boolean isLightCorrect;
     protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
     private long inhabitedTime;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 1a6fa27a966fbc8d7f458a0121c9e2f80c0316fd..a1cb320b82d63c22380b725096078fb104dfebbb 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -7,9 +7,10 @@ import com.google.common.collect.UnmodifiableIterator;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -22,6 +23,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
 import net.minecraft.server.level.ChunkHolder;
@@ -53,6 +55,7 @@ import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk extends ChunkAccess {
 
@@ -80,13 +83,18 @@ public class LevelChunk extends ChunkAccess {
     public boolean loaded;
     private boolean clientLightReady;
     public final ServerLevel level; // CraftBukkit - type
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public Set<ExternalServer> externalSubscribers = ConcurrentHashMap.newKeySet(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
     @Nullable
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
+    @Nullable public ListTag entitiesToLoad; // MultiPaper
+    @Nullable public ListTag blockEntitiesToLoad; // MultiPaper
     private final Int2ObjectMap<GameEventDispatcher> gameEventDispatcherSections;
-    private final LevelChunkTicks<Block> blockTicks;
-    private final LevelChunkTicks<Fluid> fluidTicks;
+    public LevelChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public LevelChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
     // Paper start - track last save time
     public long lastSaveTime;
     public void setLastSaved(long ticks) {
@@ -813,6 +821,7 @@ public class LevelChunk extends ChunkAccess {
         // Paper end - neighbour cache
         org.bukkit.Server server = this.level.getCraftServer();
         this.level.getChunkSource().addLoadedChunk(this); // Paper
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
@@ -874,7 +883,7 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
-        return super.isUnsaved() && !this.mustNotSave;
+        return super.isUnsaved() && !this.mustNotSave && !MultiPaper.isChunkExternal(this); // MultiPaper - only save if no one else owns it
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 9e293afe94e85ecbc2a236b1b34df1a4926b83cb..01cb4af9aee74db890c3a9005743d23376d21a1c 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -45,8 +45,8 @@ public class ProtoChunk extends ChunkAccess {
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
-    private final ProtoChunkTicks<Block> blockTicks;
-    private final ProtoChunkTicks<Fluid> fluidTicks;
+    public ProtoChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
index 8246204ce5d8f825c7796f87006e658d7a019876..9cc574749f1e601a1c9ebee1b49a1a22ac0b15b7 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/ChunkSerializer.java
@@ -277,6 +277,10 @@ public class ChunkSerializer {
             object = new LevelChunk(world.getLevel(), chunkPos, chunkconverter, levelchunkticks, levelchunkticks1, l, achunksection, ChunkSerializer.postLoadChunk(world, nbt), blendingdata);
             ((LevelChunk)object).setBlockNibbles(blockNibbles); // Paper - replace light impl
             ((LevelChunk)object).setSkyNibbles(skyNibbles); // Paper - replace light impl
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            ((LevelChunk)object).entitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "entities");
+            ((LevelChunk)object).blockEntitiesToLoad = ChunkSerializer.getListOfCompoundsOrNull(nbt, "block_entities");
+            // MultiPaper end
         } else {
             ProtoChunkTicks<Block> protochunkticklist = ProtoChunkTicks.load(nbt.getList("block_ticks", 10), (s) -> {
                 return Registry.BLOCK.getOptional(ResourceLocation.tryParse(s));
@@ -521,6 +525,8 @@ public class ChunkSerializer {
         DataResult<Tag> dataresult; // CraftBukkit - decompile error
         Logger logger;
 
+        if (chunk.unsaved) nbttagcompound.putBoolean("shouldSave", true); // MultiPaper
+
         if (blendingdata != null) {
             dataresult = BlendingData.CODEC.encodeStart(NbtOps.INSTANCE, blendingdata);
             logger = ChunkSerializer.LOGGER;
@@ -745,6 +751,10 @@ public class ChunkSerializer {
                 }
             }
 
+            // MultiPaper start - Keep copy of entities and block entities until they're loaded
+            chunk.entitiesToLoad = null;
+            chunk.blockEntitiesToLoad = null;
+            // MultiPaper end
         };
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index acb484e074391d2f1b6b83978ea9483cfb5c214c..c5ae969865a056a456ea4fc91675766de08fec76 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -47,7 +47,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
     public CompletableFuture<ChunkEntities<Entity>> loadEntities(ChunkPos pos) {
         return this.emptyChunks.contains(pos.toLong()) ? CompletableFuture.completedFuture(emptyChunk(pos)) : this.worker.loadAsync(pos).thenApplyAsync((compound) -> {
             if (compound == null) {
-                this.emptyChunks.add(pos.toLong());
+                // this.emptyChunks.add(pos.toLong()); // MultiPaper - don't cache empty chunks
                 return emptyChunk(pos);
             } else {
                 try {
@@ -87,7 +87,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkPos.toLong())) {
                 this.worker.store(chunkPos, (CompoundTag)null);
             }
-
+            this.emptyChunks.remove(chunkPos.toLong()); // MultiPaper - don't cache empty chunks
         } else {
             ListTag listTag = new ListTag();
             final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 950efcc80455f73ec8ca4e991fcf9a5b2b7fa22e..838c003758fb567cf14806279b9b6dc32ba96658 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -894,6 +894,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -903,6 +904,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/ticks/LevelTicks.java b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
index b51a94b3ad50ed5ecec8abb05cb86961c0fb323a..27c6d65d22f2dc08a59cb24a5974c32ea0723ed0 100644
--- a/src/main/java/net/minecraft/world/ticks/LevelTicks.java
+++ b/src/main/java/net/minecraft/world/ticks/LevelTicks.java
@@ -24,9 +24,12 @@ import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.core.Vec3i;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import puregero.multipaper.MultiPaper;
 
 public class LevelTicks<T> implements LevelTickAccess<T> {
     private static final Comparator<LevelChunkTicks<?>> CONTAINER_DRAIN_ORDER = (a, b) -> {
@@ -49,7 +52,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
 
     };
 
-    public LevelTicks(LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) {
+    public ServerLevel level; // MultiPaper - add level
+
+    public LevelTicks(ServerLevel level, LongPredicate tickingFutureReadyPredicate, Supplier<ProfilerFiller> profilerGetter) { // MultiPaper - add level
+        this.level = level; // MultiPaper - add level
         this.tickCheck = tickingFutureReadyPredicate;
         this.profiler = profilerGetter;
     }
@@ -116,6 +122,10 @@ public class LevelTicks<T> implements LevelTickAccess<T> {
                 LevelChunkTicks<T> levelChunkTicks = this.allContainers.get(l);
                 if (levelChunkTicks == null) {
                     objectIterator.remove();
+                // MultiPaper start - Don't tick chunks that aren't owned by us
+                } else if (levelChunkTicks.count() > 0 && !MultiPaper.isChunkLocal(level.getChunkIfLoadedImmediately(ChunkPos.getX(l), ChunkPos.getZ(l)))) {
+                    levelChunkTicks.getAll().forEach(tick -> tick.triggerTick++);
+                // MultiPaper end - Don't tick chunks that aren't owned by us
                 } else {
                     ScheduledTick<T> scheduledTick = levelChunkTicks.peek();
                     if (scheduledTick == null) {
diff --git a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
index f694b0b13ed3ee877d0c8026babdc982a95798c6..f3d2353848d974b47e84109fdce0d5c8dd2fd718 100644
--- a/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
+++ b/src/main/java/net/minecraft/world/ticks/ScheduledTick.java
@@ -5,7 +5,16 @@ import java.util.Comparator;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 
-public record ScheduledTick<T>(T type, BlockPos pos, long triggerTick, TickPriority priority, long subTickOrder) {
+// MultiPaper start - transform ScheduledTick from a record into a class
+public class ScheduledTick<T> {
+
+    public T type; public T type() { return type; }
+    public long triggerTick; public long triggerTick() { return triggerTick; }
+    public BlockPos pos; public BlockPos pos() { return pos; }
+    public TickPriority priority; public TickPriority priority() { return priority; }
+    public long subTickOrder; public long subTickOrder() { return subTickOrder; }
+// MultiPaper end
+
     public static final Comparator<ScheduledTick<?>> DRAIN_ORDER = (first, second) -> {
         int i = Long.compare(first.triggerTick, second.triggerTick);
         if (i != 0) {
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 35ce2069d31413298f842b20f2ba0dc0cf178dd8..e110711f11ae422c956d5317e110f28220a3c0d9 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -9,16 +9,22 @@ import net.minecraft.network.protocol.PacketFlow;
 import net.minecraft.network.protocol.handshake.ClientIntentionPacket;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
 import puregero.multipaper.externalserverprotocol.*;
 
 import java.io.Closeable;
+import java.io.DataInputStream;
 import java.io.IOException;
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends ChannelInitializer<SocketChannel> implements Closeable {
 
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerPacket.class.getSimpleName());
     private Channel channel;
     public long nanoTime = 0;
     public ExternalServer externalServer = null;
@@ -26,6 +32,7 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
     public HashSet<String> subscribedWorlds = new HashSet<>();
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final ConcurrentHashMap<ChunkKey, Consumer<DataInputStream>> chunkCallbacks = new ConcurrentHashMap<>();
 
     public ExternalServerConnection() {
 
@@ -130,4 +137,15 @@ public class ExternalServerConnection extends ChannelInitializer<SocketChannel>
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<DataInputStream> callback) {
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz);
+            }
+        }
+
+        RequestChunkPacket.blocker = externalServer;
+        send(new RequestChunkPacket(world, cx, cz));
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 786d30e54b7a8c189c1739930e477c56ee5e953f..c86ed5061a5810c6b668ac43125d0ae76e9e4263 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -3,26 +3,49 @@ package puregero.multipaper;
 import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
+import puregero.multipaper.externalserverprotocol.*;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
+import java.io.*;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
 
+    public final static ConcurrentHashMap<ChunkKey, ExternalServer> chunkOwnerToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, HashSet<ExternalServer>> chunkSubscribersToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, Runnable> reloadChunks = new ConcurrentHashMap<>();
     private static MultiPaperConnection multiPaperConnection = null;
+    private final static List<ChunkHolder> visibleChunksToCheck = new ArrayList<>();
 
     public static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
@@ -91,6 +114,25 @@ public class MultiPaper {
                 server.getConnection().tick();
             }
         }
+
+        reloadChunks.entrySet().removeIf(entry -> {
+            entry.getValue().run();
+            return true;
+        });
+
+        if (visibleChunksToCheck.isEmpty()) {
+            for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                visibleChunksToCheck.addAll(level.chunkSource.chunkMap.updatingChunks.getVisibleValues());
+            }
+        }
+
+        while (!visibleChunksToCheck.isEmpty()) {
+            ChunkHolder holder = visibleChunksToCheck.remove(visibleChunksToCheck.size() - 1);
+            if (holder.getAvailableChunkNow() != null && holder.getWorld().chunkSource.chunkMap.getVisibleChunkIfPresent(holder.pos.longKey) == holder) {
+                getConnection().syncChunkSubscribers(holder.getWorld().getWorld().getName(), holder.pos.x, holder.pos.z);
+                break;
+            }
+        }
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -178,4 +220,172 @@ public class MultiPaper {
     public static boolean isExternalPlayer(org.bukkit.entity.Entity bukkitEntity) {
         return isExternalPlayer(((CraftEntity) bukkitEntity).getHandle());
     }
+
+    public static boolean isChunkExternal(Chunk chunk) {
+        return chunk != null && isChunkExternal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkExternal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && !((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static boolean isChunkLocal(Chunk chunk) {
+        return chunk != null && isChunkLocal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkLocal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && ((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        try {
+            return getConnection().readChunk(world, path, cx, cz).get(15, TimeUnit.SECONDS);
+        } catch (TimeoutException timeoutException) {
+            LOGGER.warn("Timed out reading " + world + "," + path + "," + cx + "," + cz + ", retrying...");
+            return readRegionFile(world, path, cx, cz);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+ 
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+ 
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(LevelChunk chunk) {
+        try {
+            getConnection().lockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.hasExternalLockRequest = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void unlockChunk(LevelChunk chunk) {
+        try {
+            if (MultiPaper.isChunkLocal(chunk)) {
+                broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendTickListPacket(chunk));
+            }
+            getConnection().unlockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.externalOwner = null;
+            chunk.hasExternalLockRequest = false;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        if (compoundTag == null) {
+            return new byte[0];
+        }
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunkAccess = level.getChunkIfLoaded(cx, cz);
+
+        if (chunkAccess == null) {
+            ChunkHolder holder = getChunkHolder(world, cx, cz);
+            if (holder != null) {
+                chunkAccess = holder.getAvailableChunkNow();
+
+                if (chunkAccess instanceof ImposterProtoChunk) {
+                    chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+                }
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, int x, int z) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = level.chunkSource.chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
+
+        if (holder == null) {
+            holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(x, z));
+        }
+
+        if (holder == null) {
+            holder = level.chunkSource.chunkMap.getUnloadingChunkHolder(x, z);
+        }
+
+        return holder;
+    }
+
+    public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
+        try {
+            getConnection().sendChunkChangedStatus(level.convertable.getLevelId(), pos.x, pos.z, Registry.CHUNK_STATUS.getKey(status).toString());
+        } catch (IOException e) {
+            e.printStackTrace();
+        };
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..52801f3648814566dddb27e4a6984aa4431cb27e
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,248 @@
+package puregero.multipaper;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.piston.PistonMovingBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.DataLayer;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import javax.annotation.Nullable;
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return MultiPaper.isChunkLocal(chunk);
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+        ExternalServer owner = MultiPaper.chunkOwnerToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (owner != null) {
+            chunk.externalOwner = owner;
+        }
+
+        HashSet<ExternalServer> externalSubscribers = MultiPaper.chunkSubscribersToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (externalSubscribers != null) {
+            chunk.externalSubscribers.addAll(externalSubscribers);
+        }
+    }
+
+    public static void onChunkUnload(ServerLevel level, ChunkPos pos, @Nullable ChunkAccess chunk) {
+        if (chunk instanceof LevelChunk levelChunk && levelChunk.hasExternalLockRequest) {
+            MultiPaper.unlockChunk(levelChunk);
+        }
+        try {
+            MultiPaper.getConnection().unsubscribeChunk(level.convertable.getLevelId(), pos.x, pos.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void onChunkUnsubscribed(String world, int cx, int cz) {
+        ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (holder != null && !holder.getWorld().chunkSource.chunkMap.updatingChunks.isQueuedToRemove(holder.getPos().longKey)) {
+            MultiPaper.getConnection().subscribeChunk(world, cx, cz);
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                if (blockEntity != null) {
+                    MultiPaperChunkHandler.onBlockUpdate(MultiPaper.getChunkHolder(blockEntity.getLevel().getWorld().getName(), blockEntity.getBlockPos()), ClientboundBlockEntityDataPacket.create(blockEntity, BlockEntity::saveWithFullMetadata));
+                }
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(ChunkHolder chunkHolder, Packet<?> packet) {
+        if (packet instanceof ClientboundLightUpdatePacket) {
+            // This packet doesn't work, no point in sending it
+            return;
+        }
+
+        if (chunkHolder == null) {
+            // Chunk is still loading
+            return;
+        }
+
+        LevelChunk chunk = chunkHolder.getFullChunk();
+        if (chunk == null) {
+            if (chunkHolder.getAvailableChunkNow() instanceof LevelChunk) {
+                chunk = (LevelChunk) chunkHolder.getAvailableChunkNow();
+            } else {
+                LOGGER.warn("A " + packet.getClass().getSimpleName() + " occurred on an unloaded chunk " + chunkHolder.getAvailableChunkNow());
+                return;
+            }
+        }
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            for (ExternalServer externalServer : chunk.externalSubscribers) {
+                if (!externalServer.isMe()) {
+                    externalServer.getConnection().send(new SendUpdatePacket(chunkHolder.getWorld().convertable.getLevelId(), packet));
+                }
+            }
+        }
+    }
+
+    public static ChunkAccess blockUpdateChunk = null;
+    private static ChunkHolder holder = null;
+    public static void handleBlockUpdate(String world, Packet<?> packet, int depth) {
+        holder = null;
+        blockUpdateChunk = null;
+        ChunkAccess tempChunk = null;
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        if (holder != null) {
+            tempChunk = holder.getAvailableChunkNow();
+
+            if (tempChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                tempChunk = imposterProtoChunk.getWrapped();
+            }
+        }
+
+        if (holder != null && tempChunk instanceof LevelChunk levelChunk) {
+            // Clear pre-existing block changes
+            holder.broadcastChanges(levelChunk);
+        }
+
+        // Set blockUpdateChunk here so that we can broadcast changes beforehand
+        blockUpdateChunk = tempChunk;
+
+        if (holder != null && level.getChunkIfLoaded(holder.pos.x, holder.pos.z) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                setBlock(((LevelChunk) blockUpdateChunk), update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    setBlock(((LevelChunk) blockUpdateChunk), pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity existingBlockEntity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (existingBlockEntity != null && existingBlockEntity.getMinecraftKey().toString().equals(update.getTag().getString("id"))) {
+                    existingBlockEntity.load(update.getTag());
+                    if (!(existingBlockEntity instanceof PistonMovingBlockEntity)) {
+                        holder.blockChanged(update.getPos());
+                    }
+                } else if (!blockUpdateChunk.getBlockState(update.getPos()).hasBlockEntity() && depth < 1) {
+                    MCUtil.scheduleTask(1, () -> handleBlockUpdate(world, packet, depth + 1));
+                } else {
+                    blockUpdateChunk.removeBlockEntity(update.getPos());
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                    blockUpdateChunk.getBlockEntity(update.getPos());
+                    if (!(existingBlockEntity instanceof PistonMovingBlockEntity)) {
+                        holder.blockChanged(update.getPos());
+                    }
+                }
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                blockUpdateChunk.setBlockState(update.getPos(), update.getBlockState(), false);
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    blockUpdateChunk.setBlockState(pos, state, false);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity entity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (entity != null) {
+                    entity.load(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                // TODO: Doesn't work
+                handleLightUpdatePacket(level, blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk levelChunk) {
+            // Send block changes
+            holder.broadcastChanges(levelChunk);
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    private static void setBlock(LevelChunk chunk, BlockPos pos, BlockState blockState) {
+        BlockState oldState = chunk.setBlockState(pos, blockState, false, false);
+        holder.blockChanged(pos);
+
+        if (oldState != null && blockState != oldState && (blockState.getLightBlock(chunk, pos) != oldState.getLightBlock(chunk, pos) || blockState.getLightEmission() != oldState.getLightEmission() || blockState.useShapeForLightOcclusion() || oldState.useShapeForLightOcclusion())) {
+            chunk.level.getProfiler().push("queueCheckLightExternalUpdate");
+            chunk.level.getChunkSource().getLightEngine().checkBlock(pos);
+            chunk.level.getProfiler().pop();
+        }
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ServerLevel level, ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = level.getChunkSource().getLightEngine();
+        BitSet bitset = packet.getLightData().getSkyYMask();
+        BitSet bitset1 = packet.getLightData().getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getLightData().getSkyUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator, packet.getLightData().getTrustEdges());
+        BitSet bitset2 = packet.getLightData().getBlockYMask();
+        BitSet bitset3 = packet.getLightData().getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getLightData().getBlockUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1, packet.getLightData().getTrustEdges());
+    }
+
+    // From the client
+    private static void readSectionList(int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1, boolean trustEdges) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                levelLightEngine.queueSectionData(lightLayer, SectionPos.of(i, l, j), flag ? new DataLayer((byte[])iterator1.next().clone()) : new DataLayer(), trustEdges);
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 59546ec0eccd0bcd852dd030ebc20b0637176dde..7b6649d8a71df5cd806ab8b915e67948bd0f9054 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -5,18 +5,31 @@ import io.netty.channel.ChannelOption;
 import io.netty.channel.epoll.Epoll;
 import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.network.ServerConnectionListener;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.RequestChunkPacket;
+import puregero.multipaper.externalserverprotocol.SendTickListPacket;
 
 import javax.annotation.Nullable;
 import java.io.*;
 import java.net.Socket;
 import java.net.SocketException;
+import java.util.HashSet;
 import java.util.Map;
+import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaperConnection extends Thread {
 
@@ -90,6 +103,17 @@ public class MultiPaperConnection extends Thread {
                     }
                 }
 
+                if (MinecraftServer.getServer() != null) {
+                    for (ServerLevel level : MinecraftServer.getServer().getAllLevels()) {
+                        level.chunkSource.chunkMap.updatingChunks.getVisibleValuesCopy().forEach(chunkHolder -> {
+                            subscribeChunk(level.convertable.getLevelId(), chunkHolder.pos.x, chunkHolder.pos.z);
+                        });
+                        level.chunkSource.chunkMap.updatingChunks.getUpdatingValuesCopy().forEach(chunkHolder -> {
+                            subscribeChunk(level.convertable.getLevelId(), chunkHolder.pos.x, chunkHolder.pos.z);
+                        });
+                    }
+                }
+
                 DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
                 while (!socket.isClosed()) {
                     int id = in.readInt();
@@ -134,6 +158,109 @@ public class MultiPaperConnection extends Thread {
         secret = in.readUTF();
     }
 
+    public void chunkOwner(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String owner = in.readUTF();
+        ExternalServer server = owner.isEmpty() ? null : getOrCreateServer(owner);
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk levelChunk) {
+                if (levelChunk.externalOwner != null && levelChunk.externalOwner.isMe() && server != null && !server.isMe()) {
+                    server.getConnection().send(new SendTickListPacket(levelChunk));
+                }
+                if (server != null && server.isMe()) {
+                    // Wait a bit for extra data to arrive before ticking the chunk
+                    levelChunk.externalOwner = null;
+                    MultiPaper.runSync(() -> levelChunk.externalOwner = server);
+                } else if (server != null) {
+                    levelChunk.externalOwner = server;
+                    levelChunk.blockTicks.removeIf(tick -> true);
+                    levelChunk.fluidTicks.removeIf(tick -> true);
+                } else {
+                    levelChunk.externalOwner = null;
+                }
+            }
+            if (server != null && chunk.getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
+            }
+        }
+
+    }
+
+    public void chunkSubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        MultiPaper.runSync(() -> {
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalSubscribers.add(server);
+            } else {
+                MultiPaper.chunkSubscribersToSet.computeIfAbsent(new ChunkKey(world, cx, cz), key -> new HashSet<>()).add(server);
+            }
+        });
+    }
+
+    public void chunkUnsubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        MultiPaper.runSync(() -> {
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalSubscribers.remove(server);
+            }
+
+            HashSet<ExternalServer> subscribers = MultiPaper.chunkSubscribersToSet.get(new ChunkKey(world, cx, cz));
+            if (subscribers != null) {
+                subscribers.remove(server);
+            }
+        });
+    }
+
+    public void chunkSubscribeSync(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String owner = in.readUTF();
+        ExternalServer ownerServer = owner.isEmpty() ? null : getOrCreateServer(owner);
+        int length = in.readInt();
+        HashSet<ExternalServer> servers = new HashSet<>();
+        for (int i = 0; i < length; i++) {
+            servers.add(getOrCreateServer(in.readUTF()));
+        }
+
+        MultiPaper.runSync(() -> {
+            ChunkKey key = new ChunkKey(world, cx, cz);
+
+            MultiPaper.chunkSubscribersToSet.remove(key);
+
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.externalOwner = ownerServer;
+                levelChunk.externalSubscribers.clear();
+                levelChunk.externalSubscribers.addAll(servers);
+            } else {
+                MultiPaper.chunkSubscribersToSet.put(key, servers);
+
+                if (ownerServer == null) {
+                    MultiPaper.chunkOwnerToSet.remove(key);
+                } else {
+                    MultiPaper.chunkOwnerToSet.put(key, ownerServer);
+                }
+            }
+        });
+    }
+
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
         String address = in.readUTF();
         int port = in.readInt();
@@ -163,6 +290,24 @@ public class MultiPaperConnection extends Thread {
         });
     }
 
+    public void chunkChangedStatus(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String statusString = in.readUTF();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+        ChunkStatus status = Registry.CHUNK_STATUS.get(new ResourceLocation(statusString));
+
+        if (!server.isMe()) {
+            ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+            if (holder == null) {
+                LOGGER.warn("Received a chunk change status notification for an unloaded chunk " + world + ";" + cx + ";" + cz + " from " + server.getName());
+            } else if (holder.getAvailableChunkNow() != null && !holder.getAvailableChunkNow().getStatus().isOrAfter(status)) {
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
+            }
+        }
+    }
+
     public void writeTickTime(long time, double tps) throws IOException {
         DataOutputSender out = new DataOutputSender(this);
         out.writeUTF("writeTickTime");
@@ -178,4 +323,169 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(port);
         out.send(null);
     }
+
+    public CompletableFuture<Integer> getEntityCounterStartValue() throws IOException {
+        CompletableFuture<Integer> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("getEntityCounterStartValue");
+        out.send(in -> {
+            try {
+                future.complete(in.readInt());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("forceReadChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                if (!owner.isEmpty() && path.equals("region")) {
+                    ExternalServer server = serversMap.get(owner);
+                    server.getConnection().requestChunk(world, cx, cz, inputStream -> {
+                        RequestChunkPacket.blocker = null;
+                        future.complete(inputStream);
+                    });
+                } else {
+                    future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unlockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unlockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void subscribeChunk(String world, int cx, int cz) {
+        try {
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("subscribeChunk");
+            out.writeUTF(world);
+            out.writeInt(cx);
+            out.writeInt(cz);
+            out.send(null);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void unsubscribeChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unsubscribeChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(in -> {
+            try {
+                String world2 = in.readUTF();
+                int cx2 = in.readInt();
+                int cz2 = in.readInt();
+
+                MultiPaper.runSync(() -> MultiPaperChunkHandler.onChunkUnsubscribed(world2, cx2, cz2));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+    }
+
+    public void syncChunkSubscribers(String world, int cx, int cz) {
+        try {
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("syncChunkSubscribers");
+            out.writeUTF(world);
+            out.writeInt(cx);
+            out.writeInt(cz);
+            out.send(null);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void sendChunkChangedStatus(String world, int cx, int cz, String resource) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkChangedStatus");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeUTF(resource);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d3df885830b956992a70ba3b8ea5bc4440f0e12
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperWorldBorderHandler.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.border.BorderChangeListener;
+import net.minecraft.world.level.border.WorldBorder;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+public class MultiPaperWorldBorderHandler implements BorderChangeListener {
+
+    public static boolean updatingWorldBorder = false;
+
+    @Override
+    public void onBorderSizeSet(@NotNull WorldBorder border, double size) {
+        onWorldBorderChange(new ClientboundSetBorderSizePacket(border), border.world);
+    }
+
+    @Override
+    public void onBorderSizeLerping(@NotNull WorldBorder border, double fromSize, double toSize, long time) {
+        onWorldBorderChange(new ClientboundSetBorderLerpSizePacket(border), border.world);
+    }
+
+    @Override
+    public void onBorderCenterSet(@NotNull WorldBorder border, double centerX, double centerZ) {
+        onWorldBorderChange(new ClientboundSetBorderCenterPacket(border), border.world);
+    }
+
+    @Override
+    public void onBorderSetWarningTime(@NotNull WorldBorder border, int warningTime) {
+        onWorldBorderChange(new ClientboundSetBorderWarningDelayPacket(border), border.world);
+    }
+
+    @Override
+    public void onBorderSetWarningBlocks(@NotNull WorldBorder border, int warningBlockDistance) {
+        onWorldBorderChange(new ClientboundSetBorderWarningDistancePacket(border), border.world);
+    }
+
+    @Override
+    public void onBorderSetDamagePerBlock(@NotNull WorldBorder border, double damagePerBlock) {}
+
+    @Override
+    public void onBorderSetDamageSafeZOne(@NotNull WorldBorder border, double safeZoneRadius) {}
+
+    private void onWorldBorderChange(Packet<?> packet, ServerLevel level) {
+        if (!updatingWorldBorder) {
+            MultiPaper.broadcastPacketToExternalServers(level.getWorld().getName(), new SendUpdatePacket(level.getWorld().getName(), packet));
+
+            // Save the level.dat
+            level.saveIncrementally(true);
+        }
+    }
+
+    public static void handle(String world, Packet<?> packet) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+
+        updatingWorldBorder = true;
+
+        if (packet instanceof ClientboundSetBorderSizePacket setBorderSizePacket) {
+            level.getWorldBorder().setSize(setBorderSizePacket.getSize());
+        } else if (packet instanceof ClientboundSetBorderLerpSizePacket setBorderLerpSizePacket) {
+            level.getWorldBorder().lerpSizeBetween(setBorderLerpSizePacket.getOldSize(), setBorderLerpSizePacket.getNewSize(), setBorderLerpSizePacket.getLerpTime());
+        } else if (packet instanceof ClientboundSetBorderCenterPacket setBorderCenterPacket) {
+            level.getWorldBorder().setCenter(setBorderCenterPacket.getNewCenterX(), setBorderCenterPacket.getNewCenterZ());
+        } else if (packet instanceof ClientboundSetBorderWarningDelayPacket setBorderWarningDelayPacket) {
+            level.getWorldBorder().setWarningTime(setBorderWarningDelayPacket.getWarningDelay());
+        } else if (packet instanceof ClientboundSetBorderWarningDistancePacket setBorderWarningDistancePacket) {
+            level.getWorldBorder().setWarningBlocks(setBorderWarningDistancePacket.getWarningBlocks());
+        }
+
+        updatingWorldBorder = false;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index fe04e97a2bdbb479ff738a4b068e8cb23b07f44b..cb9d9d817e52d9aa63a78d45e1611d09704a3eaa 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -19,6 +19,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerRespawnPacket.class, PlayerRespawnPacket::new);
         addPacket(PlayerChangeDimensionPacket.class, PlayerChangeDimensionPacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b823c3021e94d6fc974c2bf1247f4f6bc9bac4f7
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,128 @@
+package puregero.multipaper.externalserverprotocol;
+
+import com.mojang.datafixers.util.Either;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ThreadedLevelLightEngine;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+    public static ExternalServer blocker = null;
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+
+        if (holder == null) {
+            LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we aren't trying to load it.");
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return;
+        }
+
+        CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = holder.getLastAvailableChunkFuture();
+
+        if (blocker == connection.externalServer) {
+            ChunkAccess access = holder.getAvailableChunkNow();
+            if (access != null) {
+                future = CompletableFuture.completedFuture(Either.left(holder.getAvailableChunkNow()));
+            } else {
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+        }
+
+        future.thenAccept(either -> {
+            if (either.left().isEmpty()) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+                return;
+            }
+
+            CompletableFuture<Void> lightFuture = ((ThreadedLevelLightEngine) level.getLightEngine()).theLightEngine.getChunkFuture(holder.getPos());
+
+            if (!lightFuture.isDone()) {
+                LOGGER.info("Waiting for lighting of chunk {},{},{} before sending it to {}", world, cx, cz, connection.externalServer.getName());
+                lightFuture.thenRunAsync(() -> handle(connection));
+                return;
+            }
+
+            ChunkAccess chunk = either.left().get();
+
+            try {
+                CompoundTag tag = ChunkSerializer.write(level, chunk);
+
+                if (chunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                    chunk = imposterProtoChunk.getWrapped();
+                }
+
+                if (chunk instanceof LevelChunk levelChunk) {
+                    if (levelChunk.entitiesToLoad != null) {
+                        tag.put("entities", levelChunk.entitiesToLoad);
+                    }
+                    if (levelChunk.blockEntitiesToLoad != null) {
+                        tag.put("block_entities", levelChunk.blockEntitiesToLoad);
+                    }
+                }
+
+                connection.send(new SendChunkPacket(world, cx, cz, tag));
+            } catch (ConcurrentModificationException e) {
+                LOGGER.warn("Got ConcurrentModificationException while sending chunk, sending it in main thread instead");
+                MultiPaper.runSync(() -> handle(connection));
+            }
+        })
+        // Timeout instantly if this server is blocking our chunk loading, as this is probably also blocking their chunk loading
+        .orTimeout(15, TimeUnit.SECONDS).exceptionally(throwable -> {
+            if (throwable instanceof TimeoutException) {
+                LOGGER.warn("Timed out while sending chunk " + world + "," + cx + "," + cz);
+            } else {
+                LOGGER.warn("Error while sending chunk " + world + "," + cx + "," + cz, throwable);
+            }
+
+            connection.send(new SendChunkPacket(world, cx, cz, null));
+            return null;
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b89fd7927c3547ef26988467606cc44733723ac9
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,103 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        cx = in.readInt();
+        cz = in.readInt();
+        data = in.readByteArray();
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeByteArray(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<DataInputStream> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.getConnection().forceReadChunk(world, "region", cx, cz).thenAccept(data2 -> callback.accept(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2)))));
+                } else {
+                    callback.accept(new DataInputStream(new ByteArrayInputStream(data)));
+                }
+            } else {
+                if (data.length == 0) {
+                    return;
+                }
+
+                CompoundTag tag = MultiPaper.nbtFromBytes(data);
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+                if (holder == null) {
+                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but no chunk is loaded here");
+                } else if (holder.getAvailableChunkNow() instanceof LevelChunk) {
+//                    LOGGER.warn("Received chunk data " + world + "," + cx + "," + cz + " but it is a level chunk (" + holder.getChunkHolderStatus() + ")");
+                } else {
+                    ChunkSerializer.InProgressChunkHolder newChunk = ChunkSerializer.loadChunk(level, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
+                    MultiPaper.runSync(() -> newChunk.tasks.forEach(Runnable::run));
+
+                    if (newChunk.protoChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+                        holder.replaceProtoChunk(imposterProtoChunk);
+                    } else {
+                        holder.replaceProtoChunk(newChunk.protoChunk);
+                    }
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..95a3823f5d13c29628adfc73a185d43cac573e15
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,89 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        tag = new CompoundTag();
+        tag.put("block_ticks", chunk.blockTicks.save(chunk.level.getLevelData().getGameTime(), (block) -> Registry.BLOCK.getKey(block).toString()));
+        tag.put("fluid_ticks", chunk.fluidTicks.save(chunk.level.getLevelData().getGameTime(), (fluidtype) -> Registry.FLUID.getKey(fluidtype).toString()));
+    }
+
+    public SendTickListPacket(FriendlyByteBuf in) {
+        this.world = in.readUtf();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        byte[] data = in.readByteArray();
+        try {
+            tag = MultiPaper.nbtFromBytes(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        try {
+            byte[] data = MultiPaper.nbtToBytes(tag);
+
+            out.writeByteArray(data);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk instanceof LevelChunk levelChunk) {
+                levelChunk.unregisterTickContainerFromLevel(level);
+                levelChunk.blockTicks = LevelChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.fluidTicks = LevelChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                levelChunk.unpackTicks(level.getLevelData().getGameTime());
+                if (levelChunk.loaded) levelChunk.registerTickContainerInLevel(level);
+            } else if (chunk instanceof ProtoChunk protoChunk) {
+                protoChunk.blockTicks = ProtoChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+                protoChunk.fluidTicks = ProtoChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            } else {
+                LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..7cda216bdf980eb65a002b7e1f593afda11d067a
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,62 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.*;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperWorldBorderHandler;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final String world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(String world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+
+        byte[] bytes = in.readByteArray();
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        out.writeByteArray(buf.array());
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet, 0));
+        } else if (packet instanceof ClientboundSetBorderSizePacket || packet instanceof ClientboundSetBorderLerpSizePacket || packet instanceof ClientboundSetBorderCenterPacket || packet instanceof ClientboundSetBorderWarningDelayPacket || packet instanceof ClientboundSetBorderWarningDistancePacket) {
+            MultiPaper.runSync(() -> MultiPaperWorldBorderHandler.handle(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
