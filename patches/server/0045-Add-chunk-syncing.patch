From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 6a30338648214c98b05feb5a628dbdc6b2683ff9..be8ef2bd8c1d92fd1e97c2ebf6d308b94b2ea8fb 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -390,7 +390,7 @@ public class PaperConfig {
         maxBookTotalSizeMultiplier = getDouble("settings.book-size.total-multiplier", maxBookTotalSizeMultiplier);
     }
 
-    public static boolean useOptimizedTickList = true;
+    public static boolean useOptimizedTickList = false; // MultiPaper - disable
     private static void useOptimizedTickList() {
         if (config.contains("settings.use-optimized-ticklist")) { // don't add default, hopefully temporary config
             useOptimizedTickList = config.getBoolean("settings.use-optimized-ticklist");
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 3603f1ac72635143ef927e6da90e9fcbd09e124c..7cca3f3baeb0c1fc1beb428b1ebfd2ae99a7e2e7 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -17,6 +17,7 @@ import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
@@ -42,6 +43,8 @@ import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet; // Paper
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ChunkHolder {
 
@@ -491,11 +494,19 @@ public class ChunkHolder {
             if (packetplayouttileentitydata != null) {
                 this.broadcast(packetplayouttileentitydata, false);
             }
+
+            MultiPaperChunkHandler.onBlockUpdate(this, new ClientboundBlockEntityDataPacket(pos, 0, tileentity.save(new CompoundTag()))); // MultiPaper - sync the full block with external servers
         }
 
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(this, packet);
+        }
+        // MultiPaper end
+
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
@@ -809,6 +820,7 @@ public class ChunkHolder {
                 either.ifLeft(chunk -> {
                     ChunkHolder.this.isEntityTickingReady = true;
                     // Paper start - entity ticking chunk set
+                    if (!chunk.hasExternalLockRequest) MultiPaper.lockChunk(chunk); // MultiPaper
                     ChunkHolder.this.chunkMap.level.getChunkSource().entityTickingChunks.add(chunk);
                     // Paper end - entity ticking chunk set
                 });
@@ -823,6 +835,7 @@ public class ChunkHolder {
             // Paper start - entity ticking chunk set
             LevelChunk chunkIfCached = this.getFullChunkUnchecked();
             if (chunkIfCached != null) {
+                if (chunkIfCached.hasExternalLockRequest) MultiPaper.unlockChunk(chunkIfCached); // MultiPaper
                 this.chunkMap.level.getChunkSource().entityTickingChunks.remove(chunkIfCached);
             }
             // Paper end - entity ticking chunk set
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index a9f247ba1d889dffdbac51fa70cc887f4987e717..da7c090e55023129049c235a46d874ad08fb74ab 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -104,6 +104,7 @@ import org.apache.logging.log4j.Logger;
 
 import org.bukkit.entity.Player; // CraftBukkit
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -1688,6 +1689,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, level); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1699,6 +1701,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, level, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1742,6 +1750,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 35f27e9a7c82eaec5b4a1a71696dac8485b2cd6d..5c4c8839f3603282d39238e9ef245044486574cc 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -45,6 +45,8 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
     public static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(); // Paper
@@ -1039,6 +1041,8 @@ public class ServerChunkCache extends ChunkSource {
                     // Paper end
                     ChunkPos chunkcoordintpair = chunk.getPos();
 
+                    if (chunk.externalOwner == null || !chunk.externalOwner.isMe()) continue; // MultiPaper - Don't tick this chunk if we don't own it
+
                     if ((true || this.level.isPositionEntityTicking(chunkcoordintpair)) && !this.chunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, false)) { // Paper - optimise isOutsideOfRange // Paper - we only iterate entity ticking chunks
                         chunk.setInhabitedTime(chunk.getInhabitedTime() + j);
                         if (flag1 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunk.getPos()) && !this.chunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, true)) { // Spigot // Paper - optimise isOutsideOfRange
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1ae7a10df7460f223413c38ac6bd85dba15fb347..f8e29035de239718cec7640c8df03639c31457dc 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -162,6 +162,7 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -1068,6 +1069,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickLiquid(TickNextTickData<Fluid> tick) {
+        if (!MultiPaperChunkHandler.shouldTick(this, tick.pos)) return; // MultiPaper - should tick
+
         FluidState fluid = this.getFluidState(tick.pos);
 
         if (fluid.getType() == tick.getType()) {
@@ -1077,6 +1080,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickBlock(TickNextTickData<Block> tick) {
+        if (!MultiPaperChunkHandler.shouldTick(this, tick.pos)) return; // MultiPaper - should tick
+
         BlockState iblockdata = this.getBlockState(tick.pos);
 
         if (iblockdata.is((Block) tick.getType())) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 2b79ace854461b216dc4970d1cc4a3953a51dd50..a61f2acf874c033cde1a5285818aa0ccb4f636a7 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -31,6 +31,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -311,6 +312,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -322,6 +324,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 24d772c18d5a448154909e4a51964ba29485a5c2..f1982e4d37130db67fa767a8051cb8feae08771f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -98,6 +98,7 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1074,6 +1075,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/ServerTickList.java b/src/main/java/net/minecraft/world/level/ServerTickList.java
index 0f61dd3a3115f68ccd2c7cb4c9309f5ace96a406..5ab89a28cb9eb437a3841dfe782e4c5156f77e61 100644
--- a/src/main/java/net/minecraft/world/level/ServerTickList.java
+++ b/src/main/java/net/minecraft/world/level/ServerTickList.java
@@ -9,6 +9,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.ConcurrentSkipListSet;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
@@ -31,7 +32,7 @@ public class ServerTickList<T> implements TickList<T> {
     protected final Predicate<T> ignore;
     private final Function<T, ResourceLocation> toId;
     private final Set<TickNextTickData<T>> tickNextTickSet = Sets.newHashSet();
-    private final Set<TickNextTickData<T>> tickNextTickList = Sets.newTreeSet(TickNextTickData.createTimeComparator());
+    private final Set<TickNextTickData<T>> tickNextTickList = new ConcurrentSkipListSet<>(TickNextTickData.createTimeComparator()); // MultiPaper - Make thread safe
     private final ServerLevel level;
     private final Queue<TickNextTickData<T>> currentlyTicking = Queues.newArrayDeque();
     private final List<TickNextTickData<T>> alreadyTicked = Lists.newArrayList();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 9b4a464fe820effa906af486cf71a74e283ccd4e..8c9fdefee45b9039728373e7d0ce7f5d8ba4bb78 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -21,6 +21,7 @@ import org.bukkit.inventory.InventoryHolder;
 import org.spigotmc.CustomTimingsHandler; // Spigot
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public abstract class BlockEntity implements net.minecraft.server.KeyedObject { // Paper
 
@@ -147,6 +148,7 @@ public abstract class BlockEntity implements net.minecraft.server.KeyedObject {
     public void setChanged() {
         if (this.level != null) {
             if (IGNORE_TILE_UPDATES) return; // Paper
+            MultiPaperChunkHandler.broadcastBlockEntityChange(this);
             BlockEntity.setChanged(this.level, this.worldPosition, this.blockState);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index db7904b1bb402a36684b97c443336630762aeaf9..17e7b39e8b187efb623a236ca766b398d82b3317 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -13,13 +13,9 @@ import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
@@ -69,6 +65,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk implements ChunkAccess {
 
@@ -105,9 +102,12 @@ public class LevelChunk implements ChunkAccess {
     public final Map<BlockPos, BlockEntity> blockEntities;
     private final Map<StructureFeature<?>, StructureStart<?>> structureStarts;
     private final Map<StructureFeature<?>, LongSet> structuresRefences;
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public HashSet<ExternalServer> externalSubscribers = new HashSet<>(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
     private final ShortList[] postProcessing;
-    private TickList<Block> blockTicks;
-    private TickList<Fluid> liquidTicks;
+    public TickList<Block> blockTicks; // MultiPaper - make public
+    public TickList<Fluid> liquidTicks; // MultiPaper - make public
     // Paper start - track last save time
     public long lastSaveTime;
     @Override
@@ -978,6 +978,7 @@ public class LevelChunk implements ChunkAccess {
         // Paper end - neighbour cache
         org.bukkit.Server server = this.level.getCraftServer();
         this.level.getChunkSource().addLoadedChunk(this); // Paper
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         ((ServerLevel)this.level).getChunkSource().chunkMap.playerChunkManager.onChunkLoad(this.chunkPos.x, this.chunkPos.z); // Paper - rewrite player chunk management
         if (server != null) {
             /*
@@ -1021,6 +1022,7 @@ public class LevelChunk implements ChunkAccess {
         // note: saving can be prevented, but not forced if no saving is actually required
         this.mustNotSave = !unloadEvent.isSaveChunk();
         this.level.getChunkSource().removeLoadedChunk(this); // Paper
+        MultiPaperChunkHandler.onChunkUnload(this); // MultiPaper
         // Paper start - neighbour cache
         int chunkX = this.chunkPos.x;
         int chunkZ = this.chunkPos.z;
@@ -1162,7 +1164,7 @@ public class LevelChunk implements ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
-        return this.unsaved && !this.mustNotSave; // CraftBukkit
+        return this.unsaved && !this.mustNotSave && (externalOwner == null || externalOwner.isMe()); // CraftBukkit // MultiPaper - only save if no one else owns it
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index e1b32b644bc976ff66258ed706f4d1e8de99420d..6933c39425143ba853214888c6ca25fe983f548f 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -59,8 +59,8 @@ public class ProtoChunk implements ChunkAccess {
     private final Map<StructureFeature<?>, StructureStart<?>> structureStarts = Maps.newHashMap();
     private final Map<StructureFeature<?>, LongSet> structuresRefences = Maps.newHashMap();
     private final UpgradeData upgradeData;
-    private final ProtoTickList<Block> blockTicks;
-    private final ProtoTickList<Fluid> liquidTicks;
+    public ProtoTickList<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoTickList<Fluid> liquidTicks; // MultiPaper - make public and non-final
     private final LevelHeightAccessor levelHeightAccessor;
     private long inhabitedTime;
     private final Map<GenerationStep.Carving, BitSet> carvingMasks = new Object2ObjectArrayMap<>();
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 1c77959518039e4b4fb2ffa8b93f5f69e8587ade..c206fd51978a16a1e405db8203953273880c4ce7 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -103,7 +103,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkcoordintpair.toLong())) {
                 this.worker.store(chunkcoordintpair, (CompoundTag) null);
             }
-
+            this.emptyChunks.remove(chunkcoordintpair.toLong()); // MultiPaper - don't cache empty chunks when they're not loaded
         } else {
             ListTag nbttaglist = new ListTag();
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index d1a4f9979f209a1afb2bf4bfa3d70c66338ae27d..8d398064f9d94f18b79697264ad5c1250819b4aa 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -897,6 +897,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -906,6 +907,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index e360ff62d3be252d6b9746b00dbdb4a2aae95405..602bb0a8f22d23b1d44eb59656d290798a2708e1 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -37,6 +37,12 @@ public class RegionFileStorage implements AutoCloseable {
         this.folder = directory;
         this.sync = dsync;
     }
+    
+    // MultiPaper start
+    public File getFolder() {
+        return folder;
+    }
+    // MultiPaper end
 
     // Paper start
     public static ChunkPos getRegionFileCoordinates(File file) {
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index 411b1cfdb0de16c8c183860833ebdd0772b92f7d..af98a71ae3d3e6b40852ced13a30b7136accf0cb 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -70,7 +70,7 @@ public class ExternalPlayer extends ServerPlayer {
 
         @Override
         public void send(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
-            LOGGER.info("Forwarding packet " + packet);
+//            LOGGER.info("Forwarding packet " + packet);
             externalServerConnection.sendPacket(ExternalPlayer.this, packet);
         }
     }
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 5384c15cb77ef984a6596c16f8b7f94c06dbb7ab..d45e1060ea382730cac6458b065d944285ce5826 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -3,22 +3,25 @@ package puregero.multipaper;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacketSerializer;
-import puregero.multipaper.externalserverprotocol.HelloPacket;
-import puregero.multipaper.externalserverprotocol.SendPacketPacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.*;
 
 import java.io.*;
 import java.net.Socket;
 import java.util.*;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends Thread implements Closeable {
 
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerPacket.class.getSimpleName());
+
     private Socket socket;
     public ExternalServer externalServer = null;
 
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final HashMap<ChunkKey, Consumer<byte[]>> chunkCallbacks = new HashMap<>();
 
     public ExternalServerConnection(Socket socket) {
         this.socket = socket;
@@ -104,4 +107,14 @@ public class ExternalServerConnection extends Thread implements Closeable {
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<byte[]> callback) {
+        send(new RequestChunkPacket(world, cx, cz));
+
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz);
+            }
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index 38be2afcc04916ab199930a931a8753de426a40c..c951a45154a4886432709a9abbfa7f09eeea9794 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,38 +1,47 @@
 package puregero.multipaper;
 
+import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
 import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
-import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.PlayerMovePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.*;
 
-import java.io.File;
-import java.io.IOException;
+import java.io.*;
 import java.nio.file.Files;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.UUID;
 import java.util.function.Supplier;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
     // You'll want to increase this if you have more than 250 servers
     // The bits in this value should be all 1s to optimize hashmaps and the like
     // Eg 255 is 0b11111111
     private static final int ENTITY_COUNTER_INCREMENT = 255;
-
+    public final static ConcurrentHashMap<ChunkKey, ExternalServer> chunkOwnerToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, HashSet<ExternalServer>> chunkSubscribersToSet = new ConcurrentHashMap<>();
     private static MultiPaperConnection multiPaperConnection = null;
     private static ExternalServerSocket externalServerSocket = null;
-
     public static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
             multiPaperConnection = new MultiPaperConnection();
         }
-
         return multiPaperConnection;
     }
-
     private static String bungeeCordName = null;
     public static String getBungeeCordName() {
         if (bungeeCordName == null) {
@@ -65,7 +74,6 @@ public class MultiPaper {
                 }
             }
         }
-
         for (ExternalServer server : getConnection().getServersMap().values()) {
             if (server.getConnection() != null) {
                 // This tick function must be run after the vanilla tick
@@ -73,17 +81,14 @@ public class MultiPaper {
             }
         }
     }
-
     public static void sendTickTime(long time) {
         try {
             getConnection().writeTickTime(time);
-
             tick();
         } catch (IOException e) {
             e.printStackTrace();
         }
     }
-
     public static void onStart() {
         try {
             externalServerSocket = new ExternalServerSocket();
@@ -92,11 +97,9 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
-
     public static void onPlayerJoin(ServerPlayer player) {
         broadcastPacketToExternalServers(new PlayerCreatePacket(player));
     }
-
     public static void onPlayerDisconnect(ServerPlayer player) {
         if (!(player instanceof ExternalPlayer)) {
             broadcastPacketToExternalServers(new PlayerRemovePacket(player));
@@ -129,7 +132,6 @@ public class MultiPaper {
             throw new RuntimeException(e);
         }
     }
-
     public static int getEntityCounterIncrement() {
         return ENTITY_COUNTER_INCREMENT;
     }
@@ -142,4 +144,133 @@ public class MultiPaper {
         }
         return null;
     }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        return getConnection().readChunk(world, path, cx, cz).join();
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+ 
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+ 
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(LevelChunk chunk) {
+        try {
+            getConnection().lockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.hasExternalLockRequest = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void unlockChunk(LevelChunk chunk) {
+        try {
+            broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendTickListPacket(chunk));
+            getConnection().unlockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.externalOwner = null;
+            chunk.hasExternalLockRequest = false;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        if (compoundTag == null) {
+            return new byte[0];
+        }
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, (DataOutput) new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, (DataOutput) new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunkAccess = level.getChunkIfLoaded(cx, cz);
+
+        if (chunkAccess == null) {
+            ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(cx, cz));
+            chunkAccess = holder.getAvailableChunkNow();
+
+            if (chunkAccess instanceof ImposterProtoChunk) {
+                chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, int x, int z) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = level.chunkSource.chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
+
+        if (holder == null) {
+            holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(x, z));
+        }
+
+        return holder;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..10842ae0c1330d17db15ebb292c93e5eefbc04af
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,184 @@
+package puregero.multipaper;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.DataLayer;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return chunk == null || (chunk.externalOwner != null && chunk.externalOwner.isMe());
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+        chunk.externalOwner = MultiPaper.chunkOwnerToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        HashSet<ExternalServer> externalSubscribers = MultiPaper.chunkSubscribersToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (externalSubscribers != null) {
+            chunk.externalSubscribers = externalSubscribers;
+        }
+    }
+
+    public static void onChunkUnload(LevelChunk chunk) {
+        if (chunk.hasExternalLockRequest) {
+            MultiPaper.unlockChunk(chunk);
+        }
+        try {
+            MultiPaper.getConnection().unsubscribeChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                MultiPaperChunkHandler.onBlockUpdate(blockEntity.getLevel().getChunkIfLoaded(blockEntity.getBlockPos()).playerChunk, new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), 0, blockEntity.save(new CompoundTag())));
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(ChunkHolder chunkHolder, Packet<?> packet) {
+        LevelChunk chunk = chunkHolder.getFullChunk();
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            for (ExternalServer externalServer : chunk.externalSubscribers) {
+                if (!externalServer.isMe()) {
+                    externalServer.getConnection().send(new SendUpdatePacket(chunkHolder.getWorld().convertable.getLevelId(), packet));
+                }
+            }
+        }
+    }
+
+    private static ChunkAccess blockUpdateChunk = null;
+    private static ChunkHolder holder = null;
+    public static void handleBlockUpdate(String world, Packet<?> packet) {
+        holder = null;
+        blockUpdateChunk = null;
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        ChunkAccess chunk = holder.getAvailableChunkNow();
+        if (holder != null && chunk instanceof LevelChunk) {
+            // Clear pre-existing block changes
+            holder.broadcastChanges((LevelChunk) chunk);
+        }
+
+        blockUpdateChunk = chunk;
+
+        boolean unsaved = false;
+        if (blockUpdateChunk != null) {
+            unsaved = blockUpdateChunk.isUnsaved();
+        }
+
+        if (level.getChunkIfLoaded(holder.pos.x, holder.pos.z) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                level.setBlockAndUpdate(update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    level.setBlockAndUpdate(pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                blockUpdateChunk.removeBlockEntity(update.getPos());
+                blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                level.setBlockEntity(blockUpdateChunk.getBlockEntity(update.getPos()));
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                blockUpdateChunk.setBlockState(update.getPos(), update.getBlockState(), false);
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    blockUpdateChunk.setBlockState(pos, state, false);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity entity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (entity != null) {
+                    entity.load(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                // TODO: Doesn't work
+                handleLightUpdatePacket(blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk) {
+            // Send block changes
+            holder.broadcastChanges((LevelChunk) blockUpdateChunk);
+        }
+
+        if (blockUpdateChunk != null) {
+            // Don't save changes that another server has made
+            blockUpdateChunk.setUnsaved(unsaved);
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = chunk.getLevel().getChunkSource().getLightEngine();
+        BitSet bitset = packet.getSkyYMask();
+        BitSet bitset1 = packet.getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getSkyUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator, packet.getTrustEdges());
+        BitSet bitset2 = packet.getBlockYMask();
+        BitSet bitset3 = packet.getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getBlockUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1, packet.getTrustEdges());
+    }
+
+    // From the client
+    private static void readSectionList(int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1, boolean trustEdges) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                levelLightEngine.queueSectionData(lightLayer, SectionPos.of(i, l, j), flag ? new DataLayer((byte[])iterator1.next().clone()) : new DataLayer(), trustEdges);
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 3d19e69add10e8a6a8305d9b651f30cbf4034c12..46b9eafb44f1855e8830ddcd7b0aa7c01ca40522 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,17 +1,25 @@
 package puregero.multipaper;
 
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
 
 import javax.annotation.Nullable;
 import java.io.*;
 import java.net.Socket;
 import java.net.SocketException;
 import java.nio.file.Files;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaperConnection extends Thread {
 
@@ -128,6 +136,61 @@ public class MultiPaperConnection extends Thread {
         server.setLastAlive(System.currentTimeMillis());
     }
 
+    public void chunkOwner(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk) {
+                ((LevelChunk) chunk).externalOwner = server;
+            }
+            if (chunk.getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+//                server.getConnection().requestChunk(world, cx, cz, null);
+                if (Bukkit.getWorld(world).unloadChunk(cx, cz, false)) {
+                    LOGGER.info("Unloaded chunk " + world + "," + cx + "," + cz + " as someone has a full copy");
+                } else {
+                    LOGGER.warn("Failed to unload chunk " + world + "," + cx + "," + cz + " due to someone having a full copy");
+                }
+            }
+        }
+    }
+
+    public void chunkSubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+
+        LevelChunk chunk = ((CraftWorld) Bukkit.getWorld(world)).getHandle().getChunkIfLoaded(cx, cz);
+        if (chunk == null) {
+            MultiPaper.chunkSubscribersToSet.computeIfAbsent(new ChunkKey(world, cx, cz), key -> new HashSet<>()).add(server);
+        } else {
+            chunk.externalSubscribers.add(server);
+        }
+    }
+
+    public void chunkUnsubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+
+        LevelChunk chunk = ((CraftWorld) Bukkit.getWorld(world)).getHandle().getChunkIfLoaded(cx, cz);
+        if (chunk == null) {
+            HashSet<ExternalServer> subscribers = MultiPaper.chunkSubscribersToSet.get(new ChunkKey(world, cx, cz));
+            if (subscribers != null) {
+                subscribers.remove(server);
+            }
+        } else {
+            chunk.externalSubscribers.remove(server);
+        }
+    }
+
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
         String address = in.readUTF();
         int port = in.readInt();
@@ -171,4 +234,106 @@ public class MultiPaperConnection extends Thread {
 
         return future;
     }
+
+    public CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("forceReadChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                if (!owner.isEmpty() && path.equals("region")) {
+                    ExternalServer server = serversMap.get(owner);
+                    server.getConnection().requestChunk(world, cx, cz, data2 -> {
+                        future.complete(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2))));
+                    });
+                } else {
+                    future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unlockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unlockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unsubscribeChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unsubscribeChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 998b0df31e09092b199f7b7637bd64dda213b773..92721ba1ae32a1477d7cbb7a1d55b9cd7303c011 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -16,6 +16,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerRemovePacket.class, PlayerRemovePacket::new);
         addPacket(PlayerMovePacket.class, PlayerMovePacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, IOExceptionFunction<DataInputStream, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe6b403fec4fbdc5458afef3bcaabe8b0caf8aab
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,76 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        sendChunkLater(connection, world, cx, cz, 0);
+    }
+
+    private void sendChunkLater(ExternalServerConnection connection, String world, int cx, int cz, int depth) {
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk == null) {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(cx, cz));
+            if (holder != null) {
+                if (depth == 20) {
+                    LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we timed out waiting for it to load.");
+                    connection.send(new SendChunkPacket(world, cx, cz, null));
+                    return;
+                }
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    sendChunkLater(connection, world, cx, cz, depth + 1);
+                }, 1, "ExternalServerConnection-sendChunkLater");
+            } else {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+            }
+        } else {
+            CompoundTag tag = ChunkSerializer.write((ServerLevel) chunk.getLevel(), chunk);
+            connection.send(new SendChunkPacket(world, cx, cz, tag));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2f33ad7ea22a414861082cf2496d65979ea9c76
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,96 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtCompressToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+        int byteLength = in.readInt();
+        data = new byte[byteLength];
+        in.readFully(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<byte[]> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.getConnection().forceReadChunk(world, "region", cx, cz).thenAccept(callback);
+                } else {
+                    callback.accept(data);
+                }
+            } else {
+                CompoundTag tag = NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                LevelChunk chunk = level.getChunkIfLoaded(cx, cz);
+                if (chunk != null) {
+                    ChunkSerializer.InProgressChunkHolder holder = ChunkSerializer.loadChunk(level, null, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
+                    LevelChunk newChunk = ((ImposterProtoChunk) holder.protoChunk).getWrapped();
+                    newChunk.externalOwner = chunk.externalOwner;
+                    newChunk.externalSubscribers = chunk.externalSubscribers;
+                    newChunk.playerChunk = chunk.playerChunk;
+                    MultiPaper.runSync(newChunk::loadCallback);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc30660aecb693b3780a43074629bee680d5ee04
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,87 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkTickList;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.level.chunk.ProtoTickList;
+import net.minecraft.world.level.material.Fluid;
+import net.minecraft.world.level.material.Fluids;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        ChunkTickList<Block> blockTicks = new ChunkTickList<>(Registry.BLOCK::getKey, chunk.level.getBlockTicks().fetchTicksInChunk(chunk.getPos(), false, false), chunk.level.getGameTime());
+        ChunkTickList<Fluid> liquidTicks = new ChunkTickList<>(Registry.FLUID::getKey, chunk.level.getLiquidTicks().fetchTicksInChunk(chunk.getPos(), false, false), chunk.level.getGameTime());
+
+        tag = new CompoundTag();
+        tag.put("TileTicks", blockTicks.save());
+        tag.put("LiquidTicks", liquidTicks.save());
+    }
+
+    public SendTickListPacket(DataInputStream in) throws IOException {
+        this.world = in.readUTF();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        int byteLength = in.readInt();
+        byte[] data = new byte[byteLength];
+        in.readFully(data);
+        tag = MultiPaper.nbtDecompressFromBytes(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        byte[] data = MultiPaper.nbtCompressToBytes(tag);
+
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk levelChunk) {
+            levelChunk.packTicks(level);
+            levelChunk.blockTicks = ChunkTickList.create(tag.getList("TileTicks", Tag.TAG_COMPOUND), Registry.BLOCK::getKey, Registry.BLOCK::get);
+            levelChunk.liquidTicks = ChunkTickList.create(tag.getList("LiquidTicks", Tag.TAG_COMPOUND), Registry.FLUID::getKey, Registry.FLUID::get);
+            levelChunk.unpackTicks();
+        } else if (chunk instanceof ProtoChunk protoChunk) {
+            protoChunk.blockTicks = new ProtoTickList<>(block -> block == null || block.defaultBlockState().isAir(), chunk.getPos(), tag.getList("TileTicks", Tag.TAG_COMPOUND), level);
+            protoChunk.liquidTicks = new ProtoTickList<>(fluidtype -> fluidtype == null || fluidtype == Fluids.EMPTY, chunk.getPos(), tag.getList("LiquidTicks", Tag.TAG_COMPOUND), level);
+        } else {
+            LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2bcaa3fbb1f9640faf3d7c61ba1a7087d46db12
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,70 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final String world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(String world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
