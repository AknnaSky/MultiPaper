From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Tue, 16 Nov 2021 19:23:16 +1000
Subject: [PATCH] Add chunk syncing


diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 873a9767687ee78a852e2392d12bafa25e4ddca3..60f61aadd23dd65149495db83cd224c23f94ce1e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -15,6 +15,7 @@ import javax.annotation.Nullable;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
@@ -38,6 +39,9 @@ import net.minecraft.world.level.lighting.LevelLightEngine;
 import net.minecraft.server.MinecraftServer;
 // CraftBukkit end
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
 public class ChunkHolder {
 
     public static final Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> UNLOADED_CHUNK = Either.right(ChunkHolder.ChunkLoadingFailure.UNLOADED);
@@ -337,11 +341,19 @@ public class ChunkHolder {
             if (packet != null) {
                 this.broadcast(packet, false);
             }
+
+            MultiPaperChunkHandler.onBlockUpdate(this, new ClientboundBlockEntityDataPacket(pos, 0, tileentity.save(new CompoundTag()))); // MultiPaper - sync the full block with external servers
         }
 
     }
 
     public void broadcast(Packet<?> packet, boolean onlyOnWatchDistanceEdge) {
+        // MultiPaper start - Sync blocks with external servers
+        if (!(packet instanceof ClientboundBlockEntityDataPacket)) { // We handle block entities separately
+            MultiPaperChunkHandler.onBlockUpdate(this, packet);
+        }
+        // MultiPaper end
+        
         this.playerProvider.getPlayers(this.pos, onlyOnWatchDistanceEdge).forEach((entityplayer) -> {
             entityplayer.connection.send(packet);
         });
@@ -615,6 +627,7 @@ public class ChunkHolder {
                 either.ifLeft(chunk -> {
                     ChunkHolder.this.isEntityTickingReady = true;
                     // Paper start - entity ticking chunk set
+                    if (!chunk.hasExternalLockRequest) MultiPaper.lockChunk(chunk); // MultiPaper
                     ChunkHolder.this.chunkMap.level.getChunkSource().entityTickingChunks.add(chunk);
                     // Paper end - entity ticking chunk set
                 });
@@ -629,6 +642,7 @@ public class ChunkHolder {
             // Paper start - entity ticking chunk set
             LevelChunk chunkIfCached = this.getFullChunkUnchecked();
             if (chunkIfCached != null) {
+                if (chunkIfCached.hasExternalLockRequest) MultiPaper.unlockChunk(chunkIfCached); // MultiPaper
                 this.chunkMap.level.getChunkSource().entityTickingChunks.remove(chunkIfCached);
             }
             // Paper end - entity ticking chunk set
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index d6b92e9618133ebd43424685d12b6904ddab862a..75152d30010cc8d4fcf00d332d724b3f9725f0f9 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -109,6 +109,8 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.entity.Player;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -1048,6 +1050,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         ((LevelChunk) ichunkaccess).setLoaded(false);
                     }
 
+                    MultiPaperChunkHandler.onChunkUnload(ichunkaccess); // MultiPaper
+
                     // Paper start - async chunk saving
                     try {
                         this.asyncSave(ichunkaccess);
@@ -1685,6 +1689,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, level); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1696,6 +1701,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, level, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1739,6 +1750,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 1dd03324b44a5339fc2568bc067cebd01dd4fd83..be288a861bee04d35ee0bbf076d2c588cf52ab1f 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -50,6 +50,8 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
 import java.util.function.Function; // Paper
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -1027,6 +1029,8 @@ public class ServerChunkCache extends ChunkSource {
                 LevelChunk chunk1 = chunkproviderserver_a.chunk;
                 ChunkPos chunkcoordintpair = chunk1.getPos();
 
+                if (!MultiPaper.isChunkLocal(chunk)) continue; // MultiPaper - Don't tick this chunk if we don't own it
+
                 if (this.level.isPositionEntityTicking(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkproviderserver_a.holder, chunkcoordintpair, false)) { // Paper - optimise anyPlayerCloseEnoughForSpawning
                     chunk1.incrementInhabitedTime(j);
                     if (flag2 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkproviderserver_a.holder, chunkcoordintpair, true)) { // Spigot // Paper - optimise anyPlayerCloseEnoughForSpawning
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index fb9665356dd4e1fc01ecc30cf9c2b459711c745f..4445e0f91293c28767986626e01bd38d217d1dc1 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -159,6 +159,7 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -1073,6 +1074,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickFluid(BlockPos pos, Fluid fluid) {
+        if (!MultiPaperChunkHandler.shouldTick(this, pos)) return; // MultiPaper - should tick
+
         FluidState fluid1 = this.getFluidState(pos);
 
         if (fluid1.is(fluid)) {
@@ -1082,6 +1085,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
     }
 
     private void tickBlock(BlockPos pos, Block block) {
+        if (!MultiPaperChunkHandler.shouldTick(this, pos)) return; // MultiPaper - should tick
+
         BlockState iblockdata = this.getBlockState(pos);
 
         if (iblockdata.is(block)) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 8a569e3300543cb171c3befae59969628adc424c..6a98602041e599af47717701841aebe4f3586584 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -31,6 +31,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.chunk.storage.SectionStorage;
+import puregero.multipaper.MultiPaper;
 
 public class PoiManager extends SectionStorage<PoiSection> {
     public static final int MAX_VILLAGE_DISTANCE = 6;
@@ -312,6 +313,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
+        if (true) return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -323,6 +325,7 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        if (true) MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound); // MultiPaper
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 4db17badb6f957f758fa4731c9bbeab02b9761fb..b7aadbfd03305d7b2de2e3bb571142e39694db4f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -99,6 +99,7 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import puregero.multipaper.MultiPaperChunkHandler;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -1056,6 +1057,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else if (this.shouldTickBlocksAt(ChunkPos.asLong(tickingblockentity.getPos()))) {
+                if (!MultiPaperChunkHandler.shouldTick(this, tickingblockentity.getPos())) continue; // MultiPaper - should tick
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
index 5601d0c2fe635a2a4f073c333531e1a8adf1833c..b72f2e73ee6e75be619afabefd544331a8d00194 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -24,6 +24,7 @@ import org.bukkit.inventory.InventoryHolder;
 import org.spigotmc.CustomTimingsHandler; // Spigot
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import puregero.multipaper.MultiPaperChunkHandler;
 
 public abstract class BlockEntity implements io.papermc.paper.util.KeyedObject { // Paper
 
@@ -184,6 +185,7 @@ public abstract class BlockEntity implements io.papermc.paper.util.KeyedObject {
     public void setChanged() {
         if (this.level != null) {
             if (IGNORE_TILE_UPDATES) return; // Paper
+            MultiPaperChunkHandler.broadcastBlockEntityChange(this);
             BlockEntity.setChanged(this.level, this.worldPosition, this.blockState);
         }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 87048256635692a20a728978a4ea667a14583e47..9ad9937a795a27842e8bc17b3d124d1a0c970db1 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -7,8 +7,8 @@ import com.google.common.collect.UnmodifiableIterator;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Iterator;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
@@ -53,6 +53,7 @@ import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.*;
 
 public class LevelChunk extends ChunkAccess {
 
@@ -80,13 +81,16 @@ public class LevelChunk extends ChunkAccess {
     public boolean loaded;
     private boolean clientLightReady;
     public final ServerLevel level; // CraftBukkit - type
+    @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
+    public HashSet<ExternalServer> externalSubscribers = new HashSet<>(); // MultiPaper - Chunk subscribers
+    public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
     @Nullable
     private Supplier<ChunkHolder.FullChunkStatus> fullStatus;
     @Nullable
     private LevelChunk.PostLoadProcessor postLoad;
     private final Int2ObjectMap<GameEventDispatcher> gameEventDispatcherSections;
-    private final LevelChunkTicks<Block> blockTicks;
-    private final LevelChunkTicks<Fluid> fluidTicks;
+    public LevelChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public LevelChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
     // Paper start - track last save time
     public long lastSaveTime;
     public void setLastSaved(long ticks) {
@@ -813,6 +817,7 @@ public class LevelChunk extends ChunkAccess {
         // Paper end - neighbour cache
         org.bukkit.Server server = this.level.getCraftServer();
         this.level.getChunkSource().addLoadedChunk(this); // Paper
+        MultiPaperChunkHandler.onChunkLoad(this); // MultiPaper
         if (server != null) {
             /*
              * If it's a new world, the first few chunks are generated inside
@@ -874,7 +879,7 @@ public class LevelChunk extends ChunkAccess {
 
     @Override
     public boolean isUnsaved() {
-        return super.isUnsaved() && !this.mustNotSave;
+        return super.isUnsaved() && !this.mustNotSave && !MultiPaper.isChunkExternal(this); // MultiPaper - only save if no one else owns it
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index e7676e86c08affa8e730c13f11d4b269ca896ee8..f81dd8241ab5dc69e3fe05034b315e6094551f99 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -45,8 +45,8 @@ public class ProtoChunk extends ChunkAccess {
     private final Map<GenerationStep.Carving, CarvingMask> carvingMasks = new Object2ObjectArrayMap<>();
     @Nullable
     private BelowZeroRetrogen belowZeroRetrogen;
-    private final ProtoChunkTicks<Block> blockTicks;
-    private final ProtoChunkTicks<Fluid> fluidTicks;
+    public ProtoChunkTicks<Block> blockTicks; // MultiPaper - make public and non-final
+    public ProtoChunkTicks<Fluid> fluidTicks; // MultiPaper - make public and non-final
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
index fec7d5c6a7b7a20ac9aecec1d3187f5c61fc430c..ecb62a4dbdeb7cf74deff697e25919c2bea9f23e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -87,7 +87,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
             if (this.emptyChunks.add(chunkPos.toLong())) {
                 this.worker.store(chunkPos, (CompoundTag)null);
             }
-
+            this.emptyChunks.remove(chunkcoordintpair.toLong()); // MultiPaper - don't cache empty chunks when they're not loaded
         } else {
             ListTag listTag = new ListTag();
             final java.util.Map<net.minecraft.world.entity.EntityType<?>, Integer> savedEntityCounts = new java.util.HashMap<>(); // Paper
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 834fa7048e3affb4fcc734d56526b9fba5fa69ca..70a68b0a8bacbc1a527b72f6fba4403f4fbfda1e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -894,6 +894,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean hasChunk(ChunkPos pos) {
+        if (true) return true; // MultiPaper - always return true
         return this.getOffset(pos) != 0;
     }
 
@@ -903,6 +904,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.file == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d139536be7ab15293b798af115e71a8dbe4a2f3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,34 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+
+        return super.equals(other);
+    }
+
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+
+        return name.hashCode() ^ i ^ j;
+    }
+}
+
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 17621d5fd36f0b17ab2c4d1736583d9eb9c79153..9b0e84b22db7beb26455be117e28a848b0b41df3 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -3,22 +3,25 @@ package puregero.multipaper;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacketSerializer;
-import puregero.multipaper.externalserverprotocol.HelloPacket;
-import puregero.multipaper.externalserverprotocol.SendPacketPacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.*;
 
 import java.io.*;
 import java.net.Socket;
 import java.util.*;
+import java.util.function.Consumer;
 
 public class ExternalServerConnection extends Thread implements Closeable {
 
+    private static final Logger LOGGER = LogManager.getLogger(ExternalServerPacket.class.getSimpleName());
+
     private Socket socket;
     public ExternalServer externalServer = null;
 
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
+    public final HashMap<ChunkKey, Consumer<byte[]>> chunkCallbacks = new HashMap<>();
 
     public ExternalServerConnection(Socket socket) {
         this.socket = socket;
@@ -108,4 +111,14 @@ public class ExternalServerConnection extends Thread implements Closeable {
             players.add(player);
         }
     }
+
+    public void requestChunk(String world, int cx, int cz, Consumer<byte[]> callback) {
+        send(new RequestChunkPacket(world, cx, cz));
+
+        if (callback != null) {
+            if (chunkCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("A chunk callback already existed for " + world + ", " + cx + ", " + cz);
+            }
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index dfbb4c47f0308e8395057014ca14dec0152eec07..e31b3dabb0d8efaa0b1c94232f3e3a33a94a2ecb 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,32 +1,45 @@
 package puregero.multipaper;
 
+import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftEntity;
-import puregero.multipaper.externalserverprotocol.ExternalServerPacket;
-import puregero.multipaper.externalserverprotocol.PlayerCreatePacket;
-import puregero.multipaper.externalserverprotocol.PlayerRemovePacket;
+import puregero.multipaper.externalserverprotocol.*;
 
-import java.io.File;
-import java.io.IOException;
+import java.io.*;
 import java.nio.file.Files;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.function.Supplier;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaper {
 
+    public final static ConcurrentHashMap<ChunkKey, ExternalServer> chunkOwnerToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, HashSet<ExternalServer>> chunkSubscribersToSet = new ConcurrentHashMap<>();
     private static MultiPaperConnection multiPaperConnection = null;
     private static ExternalServerSocket externalServerSocket = null;
-
     public static MultiPaperConnection getConnection() {
         if (multiPaperConnection == null) {
             multiPaperConnection = new MultiPaperConnection();
         }
-
         return multiPaperConnection;
     }
-
     private static String bungeeCordName = null;
     public static String getBungeeCordName() {
         if (bungeeCordName == null) {
@@ -65,7 +78,6 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
-
     public static void onStart() {
         try {
             externalServerSocket = new ExternalServerSocket();
@@ -74,11 +86,9 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
-
     public static void onPlayerJoin(ServerPlayer player) {
         broadcastPacketToExternalServers(new PlayerCreatePacket(player));
     }
-
     public static void onPlayerDisconnect(ServerPlayer player) {
         if (!(player instanceof ExternalPlayer)) {
             broadcastPacketToExternalServers(new PlayerRemovePacket(player));
@@ -119,4 +129,153 @@ public class MultiPaper {
     public static boolean isExternalPlayer(org.bukkit.entity.Entity bukkitEntity) {
         return isExternalPlayer(((CraftEntity) bukkitEntity).getHandle());
     }
+
+    public static boolean isChunkExternal(Chunk chunk) {
+        return chunk != null && isChunkExternal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkExternal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && !((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static boolean isChunkLocal(Chunk chunk) {
+        return chunk != null && isChunkLocal(((CraftChunk) chunk).getHandle());
+    }
+
+    public static boolean isChunkLocal(ChunkAccess chunk) {
+        return chunk instanceof LevelChunk && ((LevelChunk) chunk).externalOwner != null && ((LevelChunk) chunk).externalOwner.isMe();
+    }
+
+    public static CompoundTag readChunk(ChunkPos chunkPos, ServerLevel serverLevel) throws IOException {
+        return readRegionFileNBT(serverLevel, "region", chunkPos);
+    }
+
+    public static void writeChunk(ChunkPos chunkPos, ServerLevel serverLevel, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel, "region", chunkPos, compoundTag);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        return getConnection().readChunk(world, path, cx, cz).join();
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+ 
+    public static CompoundTag readRegionFileNBT(File path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos) throws IOException {
+        return readRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z);
+    }
+
+    public static CompoundTag readRegionFileNBT(String world, String path, int cx, int cz) throws IOException {
+        DataInput in = readRegionFile(world, path, cx, cz);
+
+        return in == null ? null : NbtIo.read(in);
+    }
+ 
+    public static void writeRegionFileNBT(File path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(getWorld(path), path.getName(), chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(ServerLevel serverLevel, String path, ChunkPos chunkPos, CompoundTag compoundTag) throws IOException {
+        writeRegionFileNBT(serverLevel.convertable.getLevelId(), path, chunkPos.x, chunkPos.z, compoundTag);
+    }
+
+    public static void writeRegionFileNBT(String world, String path, int cx, int cz, CompoundTag compoundTag) throws IOException {
+        writeRegionFile(world, path, cx, cz, nbtToBytes(compoundTag));
+    }
+
+    private static String getWorld(File path) {
+        do {
+            path = path.getParentFile();
+        } while (path.getName().startsWith("DIM"));
+        return path.getName();
+    }
+
+    public static void lockChunk(LevelChunk chunk) {
+        try {
+            getConnection().lockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.hasExternalLockRequest = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void unlockChunk(LevelChunk chunk) {
+        try {
+            if (MultiPaper.isChunkLocal(chunk)) {
+                broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendTickListPacket(chunk));
+            }
+            getConnection().unlockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
+            chunk.externalOwner = null;
+            chunk.hasExternalLockRequest = false;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static byte[] nbtToBytes(CompoundTag compoundTag) throws IOException {
+        if (compoundTag == null) {
+            return new byte[0];
+        }
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NbtIo.write(compoundTag, new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new ByteArrayInputStream(data)));
+    }
+
+    public static byte[] nbtCompressToBytes(CompoundTag compoundTag) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(buffer);
+        NbtIo.write(compoundTag, new DataOutputStream(deflaterOutputStream));
+        deflaterOutputStream.close();
+        return buffer.toByteArray();
+    }
+
+    public static CompoundTag nbtDecompressFromBytes(byte[] data) throws IOException {
+        return NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+    }
+
+    public static ChunkAccess getChunkAccess(String world, int cx, int cz) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunkAccess = level.getChunkIfLoaded(cx, cz);
+
+        if (chunkAccess == null) {
+            ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(cx, cz));
+            if (holder != null) {
+                chunkAccess = holder.getAvailableChunkNow();
+
+                if (chunkAccess instanceof ImposterProtoChunk) {
+                    chunkAccess = ((ImposterProtoChunk) chunkAccess).getWrapped();
+                }
+            }
+        }
+
+        return chunkAccess;
+    }
+
+    public static ChunkAccess getChunkAccess(String world, BlockPos pos) {
+        return getChunkAccess(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, BlockPos pos) {
+        return getChunkHolder(world, pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    public static ChunkHolder getChunkHolder(String world, int x, int z) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkHolder holder = level.chunkSource.chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
+
+        if (holder == null) {
+            holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(x, z));
+        }
+
+        return holder;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..0dafe71aa247f4fe4c344ad361e83f7774c4848e
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperChunkHandler.java
@@ -0,0 +1,185 @@
+package puregero.multipaper;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LightLayer;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.DataLayer;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.SendUpdatePacket;
+
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class MultiPaperChunkHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperChunkHandler.class.getSimpleName());
+
+    public static boolean shouldTick(Level level, BlockPos pos) {
+        LevelChunk chunk = level.getChunkIfLoaded(pos);
+        return !MultiPaper.isChunkExternal(chunk);
+    }
+
+    public static void onChunkLoad(LevelChunk chunk) {
+        chunk.externalOwner = MultiPaper.chunkOwnerToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        HashSet<ExternalServer> externalSubscribers = MultiPaper.chunkSubscribersToSet.remove(new ChunkKey(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ));
+        if (externalSubscribers != null) {
+            chunk.externalSubscribers = externalSubscribers;
+        }
+    }
+
+    public static void onChunkUnload(ChunkAccess chunk) {
+        if (chunk instanceof LevelChunk && ((LevelChunk) chunk).hasExternalLockRequest) {
+            MultiPaper.unlockChunk((LevelChunk) chunk);
+        }
+        try {
+            MultiPaper.getConnection().unsubscribeChunk(((ServerLevel) chunk.getLevel()).convertable.getLevelId(), chunk.getPos().x, chunk.getPos().z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static final HashSet<BlockEntity> blockEntitiesToBroadcast = new HashSet<>();
+    public static void broadcastBlockEntityChange(BlockEntity entity) {
+        if (blockUpdateChunk != null) return; // Don't broadcast the update to other servers if we're handling an update
+        blockEntitiesToBroadcast.add(entity);
+        // Wait a bit as the block entity may get changed multiple times in 1 tick
+        MultiPaper.runSync(() -> {
+            for (BlockEntity blockEntity : blockEntitiesToBroadcast) {
+                MultiPaperChunkHandler.onBlockUpdate(blockEntity.getLevel().getChunkIfLoaded(blockEntity.getBlockPos()).playerChunk, new ClientboundBlockEntityDataPacket(blockEntity.getBlockPos(), 0, blockEntity.save(new CompoundTag())));
+            }
+            blockEntitiesToBroadcast.clear();
+        });
+    }
+
+    public static void onBlockUpdate(ChunkHolder chunkHolder, Packet<?> packet) {
+        LevelChunk chunk = chunkHolder.getFullChunk();
+        if (blockUpdateChunk == null) { // Don't broadcast the update to other servers if we're handling an update
+            for (ExternalServer externalServer : chunk.externalSubscribers) {
+                if (!externalServer.isMe()) {
+                    externalServer.getConnection().send(new SendUpdatePacket(chunkHolder.getWorld().convertable.getLevelId(), packet));
+                }
+            }
+        }
+    }
+
+    private static ChunkAccess blockUpdateChunk = null;
+    private static ChunkHolder holder = null;
+    public static void handleBlockUpdate(String world, Packet<?> packet) {
+        holder = null;
+        blockUpdateChunk = null;
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        if (packet instanceof ClientboundBlockUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+            update.runUpdates((pos, state) -> {
+                if (holder == null) holder = MultiPaper.getChunkHolder(world, pos);
+            });
+        } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getPos());
+        } else if (packet instanceof ClientboundLightUpdatePacket update) {
+            holder = MultiPaper.getChunkHolder(world, update.getX(), update.getZ());
+        }
+
+        if (holder != null) {
+            blockUpdateChunk = holder.getAvailableChunkNow();
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk) {
+            // Clear pre-existing block changes
+            holder.broadcastChanges((LevelChunk) blockUpdateChunk);
+        }
+
+        boolean unsaved = false;
+        if (blockUpdateChunk != null) {
+            unsaved = blockUpdateChunk.isUnsaved();
+        }
+
+        if (holder != null && level.getChunkIfLoaded(holder.pos.x, holder.pos.z) != null) {
+            // Chunk is loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                level.setBlockAndUpdate(update.getPos(), update.getBlockState());
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    level.setBlockAndUpdate(pos, state);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                blockUpdateChunk.removeBlockEntity(update.getPos());
+                blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                level.setBlockEntity(blockUpdateChunk.getBlockEntity(update.getPos()));
+            }
+        } else if (blockUpdateChunk != null) {
+            // Chunk is not loaded
+            if (packet instanceof ClientboundBlockUpdatePacket update) {
+                blockUpdateChunk.setBlockState(update.getPos(), update.getBlockState(), false);
+            } else if (packet instanceof ClientboundSectionBlocksUpdatePacket update) {
+                update.runUpdates((pos, state) -> {
+                    blockUpdateChunk.setBlockState(pos, state, false);
+                });
+            } else if (packet instanceof ClientboundBlockEntityDataPacket update) {
+                BlockEntity entity = blockUpdateChunk.getBlockEntity(update.getPos());
+                if (entity != null) {
+                    entity.load(update.getTag());
+                } else {
+                    blockUpdateChunk.setBlockEntityNbt(update.getTag());
+                }
+            } else if (packet instanceof ClientboundLightUpdatePacket update) {
+                // TODO: Doesn't work
+                handleLightUpdatePacket(blockUpdateChunk, update);
+            }
+        }
+
+        if (holder != null && blockUpdateChunk instanceof LevelChunk) {
+            // Send block changes
+            holder.broadcastChanges((LevelChunk) blockUpdateChunk);
+        }
+
+        if (blockUpdateChunk != null) {
+            // Don't save changes that another server has made
+            blockUpdateChunk.setUnsaved(unsaved);
+        }
+
+        blockUpdateChunk = null;
+    }
+
+    // From the client
+    private static void handleLightUpdatePacket(ChunkAccess chunk, ClientboundLightUpdatePacket packet) {
+        int i = packet.getX();
+        int j = packet.getZ();
+        LevelLightEngine levellightengine = chunk.getLevel().getChunkSource().getLightEngine();
+        BitSet bitset = packet.getSkyYMask();
+        BitSet bitset1 = packet.getEmptySkyYMask();
+        Iterator<byte[]> iterator = packet.getSkyUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.SKY, bitset, bitset1, iterator, packet.getTrustEdges());
+        BitSet bitset2 = packet.getBlockYMask();
+        BitSet bitset3 = packet.getEmptyBlockYMask();
+        Iterator<byte[]> iterator1 = packet.getBlockUpdates().iterator();
+        readSectionList(i, j, levellightengine, LightLayer.BLOCK, bitset2, bitset3, iterator1, packet.getTrustEdges());
+    }
+
+    // From the client
+    private static void readSectionList(int i, int j, LevelLightEngine levelLightEngine, LightLayer lightLayer, BitSet bitset2, BitSet bitset3, Iterator<byte[]> iterator1, boolean trustEdges) {
+        for(int k = 0; k < levelLightEngine.getLightSectionCount(); ++k) {
+            int l = levelLightEngine.getMinLightSection() + k;
+            boolean flag = bitset2.get(k);
+            boolean flag1 = bitset3.get(k);
+            if (flag || flag1) {
+                levelLightEngine.queueSectionData(lightLayer, SectionPos.of(i, l, j), flag ? new DataLayer((byte[])iterator1.next().clone()) : new DataLayer(), trustEdges);
+            }
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index f6f7d74d354373fc21dd988757792ab575e3ad64..db203c8423b2cc33b6bdab0d123cdbc7085d0e39 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,17 +1,25 @@
 package puregero.multipaper;
 
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
 
 import javax.annotation.Nullable;
 import java.io.*;
 import java.net.Socket;
 import java.net.SocketException;
 import java.nio.file.Files;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
 
 public class MultiPaperConnection extends Thread {
 
@@ -133,6 +141,64 @@ public class MultiPaperConnection extends Thread {
         server.setLastAlive(System.currentTimeMillis());
     }
 
+    public void chunkOwner(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String owner = in.readUTF();
+        ExternalServer server = owner.isEmpty() ? null : getOrCreateServer(owner);
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk != null) {
+            if (chunk instanceof LevelChunk) {
+                ((LevelChunk) chunk).externalOwner = server;
+            }
+            if (server != null && chunk.getStatus() != ChunkStatus.FULL) {
+                // A server has locked the chunk, which means their chunk must be full.
+                // Let's redownload their full copy
+//                server.getConnection().requestChunk(world, cx, cz, null);
+                MultiPaper.runSync(() -> {
+                    if (Bukkit.getWorld(world).unloadChunk(cx, cz, false)) {
+                        LOGGER.info("Unloaded chunk " + world + "," + cx + "," + cz + " as someone has a full copy");
+                    } else {
+                        LOGGER.warn("Failed to unload chunk " + world + "," + cx + "," + cz + " due to someone having a full copy");
+                    }
+                });
+            }
+        }
+    }
+
+    public void chunkSubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk) {
+            ((LevelChunk) chunk).externalSubscribers.add(server);
+        } else {
+            MultiPaper.chunkSubscribersToSet.computeIfAbsent(new ChunkKey(world, cx, cz), key -> new HashSet<>()).add(server);
+        }
+    }
+
+    public void chunkUnsubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk) {
+            ((LevelChunk) chunk).externalSubscribers.remove(server);
+        } else {
+            HashSet<ExternalServer> subscribers = MultiPaper.chunkSubscribersToSet.get(new ChunkKey(world, cx, cz));
+            if (subscribers != null) {
+                subscribers.remove(server);
+            }
+        }
+    }
+
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
         String address = in.readUTF();
         int port = in.readInt();
@@ -161,4 +227,122 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(port);
         out.send(null);
     }
+
+    public CompletableFuture<Integer> getEntityCounterStartValue() throws IOException {
+        CompletableFuture<Integer> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("getEntityCounterStartValue");
+        out.send(in -> {
+            try {
+                future.complete(in.readInt());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public CompletableFuture<byte[]> forceReadChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("forceReadChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                String owner = in.readUTF();
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                if (!owner.isEmpty() && path.equals("region")) {
+                    ExternalServer server = serversMap.get(owner);
+                    server.getConnection().requestChunk(world, cx, cz, data2 -> {
+                        future.complete(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2))));
+                    });
+                } else {
+                    future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unlockChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unlockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void unsubscribeChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unsubscribeChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 269fa39d6d5f16efeda1867e47d2a14bfa94770c..ba9525c0ed1d0bb65a408980a9e6905a5b2a591e 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -18,6 +18,10 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerChangeGamemodePacket.class, PlayerChangeGamemodePacket::new);
         addPacket(PlayerChangeDimensionPacket.class, PlayerChangeDimensionPacket::new);
         addPacket(SendPacketPacket.class, SendPacketPacket::new);
+        addPacket(SendUpdatePacket.class, SendUpdatePacket::new);
+        addPacket(RequestChunkPacket.class, RequestChunkPacket::new);
+        addPacket(SendChunkPacket.class, SendChunkPacket::new);
+        addPacket(SendTickListPacket.class, SendTickListPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, IOExceptionFunction<DataInputStream, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe6b403fec4fbdc5458afef3bcaabe8b0caf8aab
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestChunkPacket.java
@@ -0,0 +1,76 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class RequestChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestChunkPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        sendChunkLater(connection, world, cx, cz, 0);
+    }
+
+    private void sendChunkLater(ExternalServerConnection connection, String world, int cx, int cz, int depth) {
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk == null) {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            ChunkHolder holder = level.chunkSource.chunkMap.getUpdatingChunkIfPresent(ChunkPos.asLong(cx, cz));
+            if (holder != null) {
+                if (depth == 20) {
+                    LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we timed out waiting for it to load.");
+                    connection.send(new SendChunkPacket(world, cx, cz, null));
+                    return;
+                }
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    sendChunkLater(connection, world, cx, cz, depth + 1);
+                }, 1, "ExternalServerConnection-sendChunkLater");
+            } else {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting chunk " + world + "," + cx + "," + cz + " but we don't have it loaded.");
+                connection.send(new SendChunkPacket(world, cx, cz, null));
+            }
+        } else {
+            CompoundTag tag = ChunkSerializer.write((ServerLevel) chunk.getLevel(), chunk);
+            connection.send(new SendChunkPacket(world, cx, cz, tag));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2f33ad7ea22a414861082cf2496d65979ea9c76
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -0,0 +1,96 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ImposterProtoChunk;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.storage.ChunkSerializer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.function.Consumer;
+import java.util.zip.InflaterInputStream;
+
+public class SendChunkPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendChunkPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendChunkPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtCompressToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendChunkPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+        int byteLength = in.readInt();
+        data = new byte[byteLength];
+        in.readFully(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<byte[]> callback = connection.chunkCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty chunk for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.getConnection().forceReadChunk(world, "region", cx, cz).thenAccept(callback);
+                } else {
+                    callback.accept(data);
+                }
+            } else {
+                CompoundTag tag = NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                LevelChunk chunk = level.getChunkIfLoaded(cx, cz);
+                if (chunk != null) {
+                    ChunkSerializer.InProgressChunkHolder holder = ChunkSerializer.loadChunk(level, null, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
+                    LevelChunk newChunk = ((ImposterProtoChunk) holder.protoChunk).getWrapped();
+                    newChunk.externalOwner = chunk.externalOwner;
+                    newChunk.externalSubscribers = chunk.externalSubscribers;
+                    newChunk.playerChunk = chunk.playerChunk;
+                    MultiPaper.runSync(newChunk::loadCallback);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a968e8b7fd194afcf568f5e620fbcfe27aabe90
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendTickListPacket.java
@@ -0,0 +1,81 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.ProtoChunk;
+import net.minecraft.world.ticks.LevelChunkTicks;
+import net.minecraft.world.ticks.ProtoChunkTicks;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendTickListPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendTickListPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final CompoundTag tag;
+
+    public SendTickListPacket(LevelChunk chunk) {
+        this.world = chunk.level.convertable.getLevelId();
+        this.cx = chunk.locX;
+        this.cz = chunk.locZ;
+
+        tag = new CompoundTag();
+        tag.put("block_ticks", chunk.blockTicks.save(chunk.level.getLevelData().getGameTime(), (block) -> Registry.BLOCK.getKey(block).toString()));
+        tag.put("fluid_ticks", chunk.fluidTicks.save(chunk.level.getLevelData().getGameTime(), (fluidtype) -> Registry.FLUID.getKey(fluidtype).toString()));
+    }
+
+    public SendTickListPacket(DataInputStream in) throws IOException {
+        this.world = in.readUTF();
+        this.cx = in.readInt();
+        this.cz = in.readInt();
+
+        int byteLength = in.readInt();
+        byte[] data = new byte[byteLength];
+        in.readFully(data);
+        tag = MultiPaper.nbtDecompressFromBytes(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+
+        byte[] data = MultiPaper.nbtCompressToBytes(tag);
+
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk levelChunk) {
+            levelChunk.blockTicks = LevelChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            levelChunk.fluidTicks = LevelChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            levelChunk.unpackTicks(level.getLevelData().getGameTime());
+        } else if (chunk instanceof ProtoChunk protoChunk) {
+            protoChunk.blockTicks = ProtoChunkTicks.load(tag.getList("block_ticks", Tag.TAG_COMPOUND), s -> Registry.BLOCK.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+            protoChunk.fluidTicks = ProtoChunkTicks.load(tag.getList("fluid_ticks", Tag.TAG_COMPOUND), s -> Registry.FLUID.getOptional(ResourceLocation.tryParse(s)), chunk.getPos());
+        } else {
+            LOGGER.warn("Received tick lists for an unloaded chunk " + world + "," + cx + "," + cz);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2bcaa3fbb1f9640faf3d7c61ba1a7087d46db12
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -0,0 +1,70 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperChunkHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class SendUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendUpdatePacket.class.getSimpleName());
+
+    private final String world;
+    private final Packet<?> packet;
+
+    public SendUpdatePacket(String world, Packet<?> packet) {
+        this.world = world;
+        this.packet = packet;
+    }
+
+    public SendUpdatePacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        if (packet instanceof ClientboundBlockUpdatePacket || packet instanceof ClientboundSectionBlocksUpdatePacket || packet instanceof ClientboundLightUpdatePacket || packet instanceof ClientboundBlockEntityDataPacket) {
+            MultiPaper.runSync(() -> MultiPaperChunkHandler.handleBlockUpdate(world, packet));
+        } else {
+            LOGGER.warn("Unhandled update packet of type " + packet.getClass().getSimpleName());
+        }
+    }
+}
