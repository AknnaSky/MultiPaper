From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 21 Nov 2021 22:41:15 +1000
Subject: [PATCH] Sync entities


diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 76ddd2fd9aae82a75f6b2ca27aca43a45e017ab2..144d3eca8bb57de646cac1414ed9529f39b61176 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -56,12 +56,7 @@ import net.minecraft.Util;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkPacket;
-import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
-import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.server.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.progress.ChunkProgressListener;
@@ -106,6 +101,7 @@ import org.bukkit.entity.Player; // CraftBukkit
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -2356,10 +2352,23 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         public void broadcast(Packet<?> packet) {
             Iterator iterator = this.seenBy.iterator();
 
+            // MultiPaper start - Are we ticking this entity?
+            LevelChunk chunk = level.getChunkIfLoaded(entity.blockPosition());
+            boolean isMovePacket = packet instanceof ClientboundMoveEntityPacket || packet instanceof ClientboundTeleportEntityPacket;
+            if (!(MultiPaper.isExternalPlayer(entity.getControllingPassenger()) && isMovePacket) &&
+                    (MultiPaper.isRealPlayer(entity) ||
+                    (MultiPaper.isRealPlayer(entity.getControllingPassenger()) && isMovePacket) ||
+                    (!MultiPaper.isExternalPlayer(entity) && MultiPaper.isChunkLocal(chunk)))) {
+                MultiPaperEntitiesHandler.onEntityUpdate(entity, packet); // MultiPaper
+            }
+            // MultiPaper end
+
             while (iterator.hasNext()) {
                 ServerPlayerConnection serverplayerconnection = (ServerPlayerConnection) iterator.next();
 
-                serverplayerconnection.send(packet);
+                if (!MultiPaper.isExternalPlayer(serverplayerconnection.getPlayer())) {
+                    serverplayerconnection.send(packet);
+                }
             }
 
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index a453aac607f9b38f0bf90038ff2d8071687c4bae..214a8e2921547f3cbe8a1321530cdd207003fb91 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -34,6 +34,7 @@ import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
 import net.minecraft.world.phys.Vec3;
 import org.apache.logging.log4j.LogManager;
@@ -44,6 +45,7 @@ import net.minecraft.server.network.ServerPlayerConnection;
 import net.minecraft.util.Mth;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class ServerEntity {
@@ -95,6 +97,16 @@ public class ServerEntity {
             this.broadcastAndSend(new ClientboundSetPassengersPacket(this.entity)); // CraftBukkit
         }
 
+        // MultiPaper start - Entities in vehicles glitch out when crossing borders, this forces them to sync
+        if (!list.isEmpty()) {
+            for (Entity passenger : list) {
+                if (passenger.position().distanceToSqr(this.entity.position()) > 16) {
+                    passenger.setPosRaw(this.entity.getX(), this.entity.getY(), this.entity.getZ());
+                }
+            }
+        }
+        // MultiPaper end
+
         if (this.entity instanceof ItemFrame /*&& this.tickCounter % 10 == 0*/) { // CraftBukkit - Moved below, should always enter this block
             ItemFrame entityitemframe = (ItemFrame) this.entity;
             ItemStack itemstack = entityitemframe.getItem();
@@ -126,7 +138,7 @@ public class ServerEntity {
             int i;
             int j;
 
-            if (this.entity.isPassenger()) {
+            if (!(this.entity instanceof ServerPlayer) && this.entity.isPassenger()) { // MultiPaper - Force full position update for players
                 i = Mth.floor(this.entity.getYRot() * 256.0F / 360.0F);
                 j = Mth.floor(this.entity.getXRot() * 256.0F / 360.0F);
                 boolean flag = Math.abs(i - this.yRotp) >= 1 || Math.abs(j - this.xRotp) >= 1;
@@ -260,6 +272,7 @@ public class ServerEntity {
 
     public void removePairing(ServerPlayer player) {
         this.entity.stopSeenByPlayer(player);
+        if (MultiPaper.isRealPlayer(player)) // MultiPaper - Don't send to external players
         player.connection.send(new ClientboundRemoveEntitiesPacket(new int[]{this.entity.getId()}));
     }
 
@@ -267,6 +280,7 @@ public class ServerEntity {
         ServerGamePacketListenerImpl playerconnection = player.connection;
 
         Objects.requireNonNull(player.connection);
+        if (MultiPaper.isRealPlayer(player)) // MultiPaper - Don't send to external players
         this.sendPairingData(playerconnection::send, player); // CraftBukkit - add player
         this.entity.startSeenByPlayer(player);
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 04098de654aa0e72b35ae18e2a041ea661cc0be2..7c794ed51310c1a2bd84446c69574c6722bdb1a7 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -164,6 +164,7 @@ import org.bukkit.event.world.TimeSkipEvent;
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperChunkHandler;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 import puregero.multipaper.externalserverprotocol.TimeUpdatePacket;
 
 public class ServerLevel extends Level implements WorldGenLevel {
@@ -758,6 +759,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
             this.entityTickList.forEach((entity) -> {
+                // MultiPaper start - Are we ticking this entity?
+                LevelChunk chunk = getChunkIfLoaded(entity.blockPosition());
+                if (!MultiPaper.isRealPlayer(entity) && !MultiPaper.isChunkLocal(chunk)) {
+                    return;
+                }
+                // MultiPaper end
+
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
@@ -1424,6 +1432,8 @@ public class ServerLevel extends Level implements WorldGenLevel {
             }
             // CraftBukkit end
 
+            MultiPaperEntitiesHandler.onEntitySpawn(entity); // MultiPaper
+
             return this.entityManager.addNewEntity(entity); // CraftBukkit - decompile error
         }
     }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index dd2ee961cc35d3e95fcbedb3f20ec0506827e655..2c1b7f47704287306f8ade13c2106df2e7c7834e 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -168,6 +168,7 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import puregero.multipaper.ExternalPlayer;
 import puregero.multipaper.ExternalServer;
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.externalserverprotocol.PlayerChangeDimensionPacket;
@@ -1392,7 +1393,7 @@ public class ServerPlayer extends Player {
         } else {
             Entity entity2 = this.getVehicle();
 
-            if (entity2 != entity1 && this.connection != null) {
+            if (entity2 != entity1 && this.connection != null && MultiPaper.isChunkLocal(level.getChunkIfLoaded(entity.blockPosition()))) { // MultiPaper
                 this.connection.teleport(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
             }
 
@@ -1409,7 +1410,7 @@ public class ServerPlayer extends Player {
         super.stopRiding(suppressCancellation); // Paper
         Entity entity1 = this.getVehicle();
 
-        if (entity1 != entity && this.connection != null) {
+        if (entity1 != entity && this.connection != null && MultiPaper.isChunkLocal(level.getChunkIfLoaded(entity.blockPosition()))) { // MultiPaper
             this.connection.dismount(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
         }
 
@@ -1890,7 +1891,9 @@ public class ServerPlayer extends Player {
         this.locale = packet.language;
         // Paper start
         this.adventure$locale = net.kyori.adventure.translation.Translator.parseLocale(this.locale);
+        if (!(this instanceof ExternalPlayer)) { // MultiPaper
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
+        } // MultiPaper
         // Paper end
         this.clientViewDistance = packet.viewDistance;
         // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 88ac989502f69de1ec15099eefe45a6d54966add..191285ec9cbe442e61a4057138a2844d68ff3ace 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -149,7 +149,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.JigsawBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.StructureBlockEntity;
-import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
@@ -177,7 +176,6 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.craftbukkit.util.LazyPlayerSet;
 import org.bukkit.craftbukkit.util.Waitable;
@@ -194,7 +192,6 @@ import org.bukkit.event.inventory.InventoryCreativeEvent;
 import org.bukkit.event.inventory.InventoryType.SlotType;
 import org.bukkit.event.inventory.SmithItemEvent;
 import org.bukkit.event.player.AsyncPlayerChatEvent;
-import org.bukkit.event.player.PlayerAnimationEvent;
 import org.bukkit.event.player.PlayerChatEvent;
 import org.bukkit.event.player.PlayerCommandPreprocessEvent;
 import org.bukkit.event.player.PlayerInteractAtEntityEvent;
@@ -216,6 +213,7 @@ import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
 import puregero.multipaper.MultiPaper;
 import puregero.multipaper.MultiPaperInventoryHandler;
+import puregero.multipaper.MultiPaperPlayerHandler;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
@@ -3103,6 +3101,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        MultiPaperPlayerHandler.handlePlayerAbilities(this.player, packet); // MultiPaper
         // CraftBukkit start
         if (this.player.getAbilities().mayfly && this.player.getAbilities().flying != packet.isFlying()) {
             PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.player.getBukkitEntity(), packet.isFlying());
@@ -3119,6 +3118,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
     @Override
     public void handleClientInformation(ServerboundClientInformationPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
+        MultiPaperPlayerHandler.handleClientInformation(this.player, packet);
         this.player.updateOptions(packet);
     }
 
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index da83f0d2c8d093302a2d8cc397451703462bde61..6d0094959e484221b4642d1be4c916a7ab059206 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -320,7 +320,6 @@ public abstract class PlayerList {
         if (!networkmanager.isConnected()) {
             return;
         }
-        MultiPaper.onPlayerJoin(player); // MultiPaper
         player.didPlayerJoinEvent = true;
         // Paper end
         TranslatableComponent chatmessage;
@@ -369,6 +368,8 @@ public abstract class PlayerList {
         }
         // CraftBukkit end
 
+        MultiPaper.onPlayerJoin(player); // MultiPaper
+
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoPacket packet = new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, player);
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index aac9dd19237d0708990960d03328e7530cd7bc8e..34113186a8c08699db7c8758a1703f25eab48b2c 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -147,6 +147,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaperEntitiesHandler;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, net.minecraft.server.KeyedObject { // Paper
@@ -626,6 +627,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
     }
 
     public void remove(Entity.RemovalReason reason) {
+        MultiPaperEntitiesHandler.onEntityRemove(this); // MultiPaper
         this.setRemoved(reason);
         if (reason == Entity.RemovalReason.KILLED) {
             this.gameEvent(GameEvent.ENTITY_KILLED);
@@ -4124,6 +4126,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
             int j = Mth.floor(y);
             int k = Mth.floor(z);
 
+            if ((i >> 4) != (this.blockPosition.getX() >> 4) || (k >> 4) != (this.blockPosition.getZ() >> 4)) {
+                MultiPaperEntitiesHandler.onChunkMove(this, new BlockPos(i, j, k), this.blockPosition);
+            }
+
             if (i != this.blockPosition.getX() || j != this.blockPosition.getY() || k != this.blockPosition.getZ()) {
                 this.blockPosition = new BlockPos(i, j, k);
             }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index df12ba04df24e1c70c43e00283ea2a78ae2ca422..c33ce00ed8dc4251fbe035abeae9137004bf716a 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -140,6 +140,7 @@ import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.EntityResurrectEvent;
 import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 
@@ -2568,6 +2569,7 @@ public abstract class LivingEntity extends Entity {
             vec3d = new Vec3(this.getX(), d0, this.getZ());
         }
 
+        if (MultiPaper.isChunkLocal(level.getChunkIfLoaded(vehicle.blockPosition()))) // MultiPaper
         this.dismountTo(vec3d.x, vec3d.y, vec3d.z);
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 94e76e295dbd0f3bac4b30a3e7338cd56a971207..de3932d9f84ffb30ab8eaacbf37d67ffbd2026d5 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -145,7 +145,7 @@ public abstract class Player extends LivingEntity {
     private static final EntityDataAccessor<Float> DATA_PLAYER_ABSORPTION_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.FLOAT);
     private static final EntityDataAccessor<Integer> DATA_SCORE_ID = SynchedEntityData.defineId(Player.class, EntityDataSerializers.INT);
     public static final EntityDataAccessor<Byte> DATA_PLAYER_MODE_CUSTOMISATION = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
-    protected static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE);
+    public static final EntityDataAccessor<Byte> DATA_PLAYER_MAIN_HAND = SynchedEntityData.defineId(Player.class, EntityDataSerializers.BYTE); // MultiPaper - make public
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_LEFT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     protected static final EntityDataAccessor<CompoundTag> DATA_SHOULDER_RIGHT = SynchedEntityData.defineId(Player.class, EntityDataSerializers.COMPOUND_TAG);
     private long timeEntitySatOnShoulder;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 18ed7fd0173b010ed6fd5a2dc9c4ddcccbf192e4..ec416cad04b929a2f1be99a23cfae8f6bf8d784e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -105,6 +105,7 @@ public class LevelChunk implements ChunkAccess {
     @Nullable public ExternalServer externalOwner; // MultiPaper - Chunk owner
     public HashSet<ExternalServer> externalSubscribers = new HashSet<>(); // MultiPaper - Chunk subscribers
     public boolean hasExternalLockRequest = false; // MultiPaper - Have we sent a request to lock this chunk?
+    public HashSet<ExternalServer> externalEntitiesSubscribers = new HashSet<>(); // MultiPaper - Entities subscribers
     private final ShortList[] postProcessing;
     public TickList<Block> blockTicks; // MultiPaper - make public
     public TickList<Fluid> liquidTicks; // MultiPaper - make public
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
index 2340feb8483c2478a22b78e735bcbd6759f1b011..21023743292cd1f9d6eafdee23cbf28339cc4455 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/IOWorker.java
@@ -21,6 +21,7 @@ import net.minecraft.util.thread.StrictQueue;
 import net.minecraft.world.level.ChunkPos;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class IOWorker implements AutoCloseable {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -66,7 +67,7 @@ public class IOWorker implements AutoCloseable {
                 return Either.left(pendingStore.data);
             } else {
                 try {
-                    CompoundTag compoundTag = this.storage.read(pos);
+                    CompoundTag compoundTag = MultiPaper.readRegionFileNBT(storage.getFolder(), pos); // this.storage.read(pos); // MultiPaper
                     return Either.left(compoundTag);
                 } catch (Exception var4) {
                     LOGGER.warn("Failed to read chunk {}", pos, var4);
@@ -129,7 +130,7 @@ public class IOWorker implements AutoCloseable {
 
     private void runStore(ChunkPos pos, IOWorker.PendingStore result) {
         try {
-            this.storage.write(pos, result.data);
+            MultiPaper.writeRegionFileNBT(storage.getFolder(), pos, result.data); // this.storage.write(pos, result.data); // MultiPaper
             result.result.complete((Void)null);
         } catch (Exception var4) {
             LOGGER.error("Failed to store chunk {}", pos, var4);
diff --git a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
index 5a72ce41cc57578498c4a072a1eb04ac28958afe..90e6376b162e0532aef547da9d89828ca400fa88 100644
--- a/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
+++ b/src/main/java/net/minecraft/world/level/entity/PersistentEntitySectionManager.java
@@ -25,15 +25,21 @@ import java.util.stream.Stream;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
 import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.util.CsvOutput;
 import net.minecraft.util.VisibleForDebug;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.chunk.LevelChunk;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import net.minecraft.world.level.ChunkPos;
 // CraftBukkit start
 import net.minecraft.world.level.chunk.storage.EntityStorage;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
+import puregero.multipaper.ExternalServer;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+import puregero.multipaper.externalserverprotocol.EntityUpdateNBTPacket;
 // CraftBukkit end
 
 public class PersistentEntitySectionManager<T extends EntityAccess> implements AutoCloseable {
@@ -46,9 +52,9 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
     final EntitySectionStorage<T> sectionStorage;
     private final LevelEntityGetter<T> entityGetter;
     private final Long2ObjectMap<Visibility> chunkVisibility = new Long2ObjectOpenHashMap();
-    private final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap();
+    public final Long2ObjectMap<PersistentEntitySectionManager.ChunkLoadStatus> chunkLoadStatuses = new Long2ObjectOpenHashMap(); // MultiPaper - make public
     private final LongSet chunksToUnload = new LongOpenHashSet();
-    private final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue();
+    public final Queue<ChunkEntities<T>> loadingInbox = Queues.newConcurrentLinkedQueue(); // MultiPaper - make public
     public final io.papermc.paper.world.EntitySliceManager entitySliceManager; // Paper
 
     public PersistentEntitySectionManager(Class<T> entityClass, LevelCallback<T> handler, EntityPersistentStorage<T> dataAccess, io.papermc.paper.world.EntitySliceManager entitySliceManager) { // Paper
@@ -347,6 +353,14 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
 
     private boolean processChunkUnload(long chunkPos) {
         org.spigotmc.AsyncCatcher.catchOp("Entity chunk unload process"); // Paper
+        MultiPaperEntitiesHandler.onEntitiesUnload(entitySliceManager.world, new ChunkPos(chunkPos));
+        // MultiPaper start
+        for (Entity entity : getEntities(new ChunkPos(chunkPos))) {
+            if (MultiPaper.isExternalPlayer(entity) && entity.getVehicle() != null) {
+                entity.stopRiding();
+            }
+        }
+        // MultiPaper end
         boolean flag = this.storeChunkSections(chunkPos, (entityaccess) -> {
             entityaccess.getPassengersAndSelf().forEach(this::unloadEntity);
         }, true); // CraftBukkit - add boolean for event call
@@ -375,6 +389,9 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
         ChunkEntities<T> chunkentities; // CraftBukkit - decompile error
 
         while ((chunkentities = (ChunkEntities) this.loadingInbox.poll()) != null) {
+            // Multipaper start - Sometimes chunks already have entities loaded? Send these to subscribed chunks
+            List<Entity> existingEntities = getEntities(chunkentities.getPos()).stream().filter(entity -> !(entity instanceof ServerPlayer)).toList();
+            // MultiPaper end
             chunkentities.getEntities().forEach((entityaccess) -> {
                 this.addEntity(entityaccess, true);
             });
@@ -389,6 +406,16 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
                 level.onChunkSetTicking(chunkentities.getPos().x, chunkentities.getPos().z);
             }
             // Paper end
+            // Multipaper start - Sometimes chunks already have entities loaded? Send these to subscribed chunks
+            LevelChunk chunk = level.getChunkIfLoaded(chunkentities.getPos().x, chunkentities.getPos().z);
+            if (!existingEntities.isEmpty()) {
+                LOGGER.info("There were already " + existingEntities.size() + " entities in " + level.convertable.getLevelId() + "," + chunkentities.getPos().x + "," + chunkentities.getPos().z);
+                LOGGER.info("Sending these entities to: " + chunk.externalEntitiesSubscribers.stream().map(ExternalServer::getName).toList());
+                for (Entity existingEntity : existingEntities) {
+                    MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(existingEntity));
+                }
+            }
+            // MultiPaper end
         }
 
     }
@@ -513,7 +540,7 @@ public class PersistentEntitySectionManager<T extends EntityAccess> implements A
         return i + "," + this.visibleEntityStorage.count() + "," + this.sectionStorage.count() + "," + this.chunkLoadStatuses.size() + "," + this.chunkVisibility.size() + "," + this.loadingInbox.size() + "," + this.chunksToUnload.size();
     }
 
-    private static enum ChunkLoadStatus {
+    public static enum ChunkLoadStatus { // MultiPaper - make public
 
         FRESH, PENDING, LOADED;
 
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index ef4675269b04bf95f2670b728f20c45d063aa00b..5ef897fcda9919ca5f73be1156d67411ab2de63b 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -6,6 +6,7 @@ import io.netty.util.concurrent.GenericFutureListener;
 import net.minecraft.network.Connection;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
@@ -36,6 +37,17 @@ public class ExternalPlayer extends ServerPlayer {
         this.valid = true;
         connection = new ServerGamePacketListenerImpl(getServer(), new ExternalPlayerConnection(PacketFlow.CLIENTBOUND), this);
         setPos(x, y, z);
+
+        for (int i = 0; i < getServer().getPlayerList().players.size(); ++i) {
+            ServerPlayer entityplayer1 = getServer().getPlayerList().players.get(i);
+
+            if (!entityplayer1.getBukkitEntity().canSee(getBukkitEntity())) {
+                continue;
+            }
+
+            entityplayer1.connection.send(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, new ServerPlayer[] { this }));
+        }
+
         getServer().getPlayerList().addPlayer(this);
         ((ServerLevel) level).addNewPlayer(this);
         containerMenu.transferTo(containerMenu, getBukkitEntity());
@@ -64,9 +76,4 @@ public class ExternalPlayer extends ServerPlayer {
             externalServerConnection.sendPacket(ExternalPlayer.this, packet);
         }
     }
-
-    @Override
-    public boolean broadcastToPlayer(ServerPlayer spectator) {
-        return false;
-    }
 }
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index d45e1060ea382730cac6458b065d944285ce5826..f0784dbe7255a47c39f84e725bf3f8bcef72b37b 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -1,8 +1,11 @@
 package puregero.multipaper;
 
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.HumanoidArm;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.externalserverprotocol.*;
@@ -22,6 +25,7 @@ public class ExternalServerConnection extends Thread implements Closeable {
     private static final Queue<List<ExternalPlayer>> externalPlayerListPool = new LinkedList<>();
     private final HashMap<Packet<?>, List<ExternalPlayer>> packetsToSend = new LinkedHashMap<>();
     public final HashMap<ChunkKey, Consumer<byte[]>> chunkCallbacks = new HashMap<>();
+    public final HashMap<ChunkKey, Consumer<byte[]>> entitiesCallbacks = new HashMap<>();
 
     public ExternalServerConnection(Socket socket) {
         this.socket = socket;
@@ -42,6 +46,25 @@ public class ExternalServerConnection extends Thread implements Closeable {
         try {
             send(new HelloPacket(MultiPaper.getBungeeCordName()));
 
+            while (MinecraftServer.getServer() == null || MinecraftServer.getServer().getPlayerList() == null || MinecraftServer.getServer().getPlayerList().players == null) {
+                Thread.sleep(100); // Wait for server to initialise
+            }
+
+            for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+                if (MultiPaper.isRealPlayer(player)) {
+                    send(new PlayerCreatePacket(player));
+                    send(new PlayerActionPacket(player, new ServerboundClientInformationPacket(
+                            player.locale,
+                            player.clientViewDistance,
+                            player.getChatVisibility(),
+                            player.canChatInColor(),
+                            player.getEntityData().get(ServerPlayer.DATA_PLAYER_MODE_CUSTOMISATION),
+                            player.getEntityData().get(ServerPlayer.DATA_PLAYER_MAIN_HAND) == 0 ? HumanoidArm.LEFT : HumanoidArm.RIGHT,
+                            player.isTextFilteringEnabled()
+                    )));
+                }
+            }
+
             DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
             while (!socket.isClosed()) {
                 ExternalServerPacket packet = ExternalServerPacketSerializer.deserialize(in);
@@ -117,4 +140,14 @@ public class ExternalServerConnection extends Thread implements Closeable {
             }
         }
     }
+
+    public void requestEntities(String world, int cx, int cz, Consumer<byte[]> callback) {
+        send(new RequestEntitiesPacket(world, cx, cz));
+
+        if (callback != null) {
+            if (entitiesCallbacks.put(new ChunkKey(world, cx, cz), callback) != null) {
+                LOGGER.warn("An entities callback already existed for " + world + ", " + cx + ", " + cz);
+            }
+        }
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index e69f5750bd4003cf08ea6de73e54fae6d7a639ac..cdeef29cd561b6962baa1156c8a7b426bd66ce14 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,14 +1,17 @@
 package puregero.multipaper;
 
 import net.minecraft.core.BlockPos;
-import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
+import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
+import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.HumanoidArm;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
@@ -29,8 +32,8 @@ import java.io.*;
 import java.nio.file.Files;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.function.Supplier;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Supplier;
 import java.util.zip.DeflaterOutputStream;
 import java.util.zip.InflaterInputStream;
 
@@ -107,6 +110,12 @@ public class MultiPaper {
                 broadcastPacketToExternalServers(new TimeUpdatePacket(level));
             }
         }
+
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            if (player instanceof ExternalPlayer) {
+                player.detectEquipmentUpdates();
+            }
+        }
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -126,8 +135,29 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
+
     public static void onPlayerJoin(ServerPlayer player) {
         broadcastPacketToExternalServers(new PlayerCreatePacket(player));
+
+        if (player.clientViewDistance != null) {
+            broadcastPacketToExternalServers(new PlayerActionPacket(player, new ServerboundClientInformationPacket(
+                    player.locale,
+                    player.clientViewDistance,
+                    player.getChatVisibility(),
+                    player.canChatInColor(),
+                    player.getEntityData().get(ServerPlayer.DATA_PLAYER_MODE_CUSTOMISATION),
+                    player.getEntityData().get(ServerPlayer.DATA_PLAYER_MAIN_HAND) == 0 ? HumanoidArm.LEFT : HumanoidArm.RIGHT,
+                    player.isTextFilteringEnabled()
+            )));
+        }
+
+        if (player.getVehicle() != null) {
+            LevelChunk levelChunk = player.getVehicle().level.getChunkAt(player.getVehicle().blockPosition());
+            if (levelChunk != null) {
+                MultiPaper.broadcastPacketToExternalServers(levelChunk.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(player.getVehicle()));
+                MultiPaper.broadcastPacketToExternalServers(levelChunk.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(player.getVehicle(), player.getVehicle().getPassengers(), new ClientboundSetPassengersPacket(player.getVehicle())));
+            }
+        }
     }
     public static void onPlayerDisconnect(ServerPlayer player) {
         if (!(player instanceof ExternalPlayer)) {
@@ -321,6 +351,7 @@ public class MultiPaper {
     public static void unlockChunk(LevelChunk chunk) {
         try {
             if (MultiPaper.isChunkLocal(chunk)) {
+                broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendEntitiesPacket(chunk));
                 broadcastPacketToExternalServers(chunk.externalSubscribers, () -> new SendTickListPacket(chunk));
             }
             getConnection().unlockChunk(chunk.level.convertable.getLevelId(), chunk.locX, chunk.locZ);
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 19f7084c61dff18f83c16fbf52a3707ac0d27a80..89b51127fbc849fafa14c02d2192c7a9ad2d5632 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,6 +1,9 @@
 package puregero.multipaper;
 
+import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.LevelChunk;
@@ -9,6 +12,8 @@ import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.externalserverprotocol.EntityUpdateNBTPacket;
+import puregero.multipaper.externalserverprotocol.EntityUpdateWithDependenciesPacket;
 
 import javax.annotation.Nullable;
 import java.io.*;
@@ -253,6 +258,41 @@ public class MultiPaperConnection extends Thread {
         }
     }
 
+    public void entitiesSubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk) {
+            ((LevelChunk) chunk).externalEntitiesSubscribers.add(server);
+
+            for (Entity entity : ((LevelChunk) chunk).level.entityManager.getEntities(chunk.getPos())) {
+                if (MultiPaper.isRealPlayer(entity) && entity.getVehicle() != null) {
+                    server.getConnection().send(new EntityUpdateNBTPacket(entity.getVehicle()));
+                    server.getConnection().send(new EntityUpdateWithDependenciesPacket(entity.getVehicle(), entity.getVehicle().getPassengers(), new ClientboundSetPassengersPacket(entity.getVehicle())));
+                }
+            }
+        } else {
+            LOGGER.warn("Received an entities subscribe notification for an unloaded chunk " + world + ";" + cx + ";" + cz);
+        }
+    }
+
+    public void entitiesUnsubscribe(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+
+        ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+        if (chunk instanceof LevelChunk) {
+            ((LevelChunk) chunk).externalEntitiesSubscribers.remove(server);
+        } else {
+            LOGGER.warn("Received an entities unsubscribe notification for an unloaded chunk " + world + ";" + cx + ";" + cz);
+        }
+    }
+
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
         String address = in.readUTF();
         int port = in.readInt();
@@ -337,6 +377,11 @@ public class MultiPaperConnection extends Thread {
                     server.getConnection().requestChunk(world, cx, cz, data2 -> {
                         future.complete(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2))));
                     });
+                } else if (!owner.isEmpty() && path.equals("entities")) {
+                    ExternalServer server = serversMap.get(owner);
+                    server.getConnection().requestEntities(world, cx, cz, data2 -> {
+                        future.complete(data2.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data2))));
+                    });
                 } else {
                     future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
                 }
@@ -357,10 +402,13 @@ public class MultiPaperConnection extends Thread {
     }
 
     public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
-        deflateOut.write(data);
-        deflateOut.close();
+        if (data.length != 0) {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+            deflateOut.write(data);
+            deflateOut.close();
+            data = baos.toByteArray();
+        }
 
         DataOutputSender out = new DataOutputSender(this);
         out.writeUTF("writeChunk");
@@ -368,8 +416,8 @@ public class MultiPaperConnection extends Thread {
         out.writeUTF(path);
         out.writeInt(cx);
         out.writeInt(cz);
-        out.writeInt(baos.size());
-        out.write(baos.toByteArray());
+        out.writeInt(data.length);
+        out.write(data);
         out.send(in -> { /* Do nothing */ });
     }
     
@@ -605,4 +653,13 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(cz);
         out.send(null);
     }
+
+    public void unsubscribeEntities(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("unsubscribeEntities");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java b/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfab56b23024d97f4f09d169d102b6a7ca487584
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperEntitiesHandler.java
@@ -0,0 +1,243 @@
+package puregero.multipaper;
+
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.*;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ChunkMap;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.AttributeInstance;
+import net.minecraft.world.entity.ai.attributes.AttributeModifier;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang.ArrayUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import puregero.multipaper.externalserverprotocol.*;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class MultiPaperEntitiesHandler {
+
+    private static final Logger LOGGER = LogManager.getLogger(MultiPaperEntitiesHandler.class.getSimpleName());
+
+    public static void onEntitiesUnload(ServerLevel level, ChunkPos pos) {
+        try {
+            MultiPaper.getConnection().unsubscribeEntities(level.convertable.getLevelId(), pos.x, pos.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void onChunkMove(Entity entity, BlockPos to, BlockPos from) {
+        if (from.equals(BlockPos.ZERO)) return; // They just spawned
+        if (!entity.shouldBeSaved() && !(entity.isVehicle() && entity.hasExactlyOnePlayerPassenger())) return; // Entity shouldn't be synced (eg players)
+
+        LevelChunk chunkFrom = entity.level.getChunkIfLoaded(from);
+        LevelChunk chunkTo = entity.level.getChunkIfLoaded(to);
+
+        if (chunkFrom == null || chunkTo == null) {
+            LOGGER.warn("Entity moving chunk from " + chunkFrom + " (" + from + ") to " + chunkTo + " (" + to + ")");
+            return;
+        }
+
+//        if (MultiPaper.isChunkLocal(chunkTo)) {
+//            // Entities get glitched out with vehicles when entering our area, this fixes it
+//            if (entity.isVehicle()) {
+//                for (Entity passenger : entity.getPassengers()) {
+//                    if (!(passenger instanceof ServerPlayer)) {
+//                        passenger.levelCallback.onMove();
+//                    }
+//                }
+//            }
+//        }
+
+        if (MultiPaper.isChunkLocal(chunkFrom)) {
+            if (!MultiPaper.isChunkLocal(chunkTo)) {
+                // Leaving our jurisdiction, do a full entity update to ensure the new external server has all the required info
+                MultiPaper.runSync(() -> MultiPaper.broadcastPacketToExternalServers(chunkTo.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(entity)));
+            }
+            for (ExternalServer fromServer : chunkFrom.externalEntitiesSubscribers) {
+                if (fromServer.getConnection() != null && !chunkTo.externalEntitiesSubscribers.contains(fromServer)) {
+                    // Entity is leaving another server's area, make sure they know this
+                    fromServer.getConnection().send(new EntityUpdatePacket(entity, new ClientboundTeleportEntityPacket(entity)));
+                }
+            }
+            for (ExternalServer toServer : chunkTo.externalEntitiesSubscribers) {
+                if (toServer.getConnection() != null && !chunkFrom.externalEntitiesSubscribers.contains(toServer)) {
+                    // Entity is entering another server's area, send them the full entity
+                    MultiPaper.broadcastPacketToExternalServers(chunkTo.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(entity));
+                    if (entity.isVehicle() && entity.hasExactlyOnePlayerPassenger()) {
+                        MultiPaper.broadcastPacketToExternalServers(chunkTo.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entity.getPassengers(), new ClientboundSetPassengersPacket(entity)));
+                    }
+                }
+            }
+        }
+    }
+
+    private static void setRemovedRecursive(Entity entity) {
+        for (Entity passenger : entity.getPassengers()) {
+            if (!(passenger instanceof ServerPlayer)) {
+                setRemovedRecursive(passenger);
+            }
+        }
+        entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+    }
+
+    public static void handleEntityUpdate(Entity entity, Packet<?> packet) {
+        if (packet instanceof ClientboundMoveEntityPacket moveEntityPacket) {
+            Vec3 vector = moveEntityPacket.updateEntityPosition(entity.position());
+            if (!(entity instanceof ServerPlayer) && !((ServerLevel) entity.level).entityManager.areEntitiesLoaded(new ChunkPos(new BlockPos(vector)).longKey)) {
+                setRemovedRecursive(entity);
+                return;
+            }
+            if (moveEntityPacket.hasRotation()) {
+                entity.moveTo(vector.x, vector.y, vector.z, moveEntityPacket.getyRot() * 360f / 256, moveEntityPacket.getxRot() * 360f / 256);
+            } else {
+                // Include y-rot and x-rot, as without it, it teleports players
+                entity.moveTo(vector.x, vector.y, vector.z, entity.getYRot(), entity.getXRot());
+            }
+        } else if (packet instanceof ClientboundTeleportEntityPacket teleportEntityPacket) {
+            if (!(entity instanceof ServerPlayer) &&!((ServerLevel) entity.level).entityManager.areEntitiesLoaded(new ChunkPos(new BlockPos(teleportEntityPacket.getX(), teleportEntityPacket.getY(), teleportEntityPacket.getZ())).longKey)) {
+                setRemovedRecursive(entity);
+                return;
+            }
+            entity.moveTo(teleportEntityPacket.getX(), teleportEntityPacket.getY(), teleportEntityPacket.getZ(), teleportEntityPacket.getyRot() * 360f / 256, teleportEntityPacket.getxRot() * 360f / 256);
+        } else if (packet instanceof ClientboundSetEntityMotionPacket setEntityMotionPacket) {
+            entity.setDeltaMovement(setEntityMotionPacket.getXa() / 8000.0D, setEntityMotionPacket.getYa() / 8000.0D, setEntityMotionPacket.getZa() / 8000.0D);
+        } else if (packet instanceof ClientboundRotateHeadPacket rotateHeadPacket) {
+            entity.setYHeadRot(rotateHeadPacket.getYHeadRot() * 360f / 256);
+        } else if (packet instanceof ClientboundSetEntityDataPacket setEntityDataPacket) {
+            if (setEntityDataPacket.getUnpackedData() != null) {
+                for (SynchedEntityData.DataItem item : setEntityDataPacket.getUnpackedData()) {
+                    entity.getEntityData().set(item.getAccessor(), item.getValue());
+                }
+            } else {
+                LOGGER.warn("ClientboundSetEntityDataPacket.getUnpackedData() was null");
+            }
+        } else if (packet instanceof ClientboundUpdateAttributesPacket updateAttributesPacket) {
+            for (ClientboundUpdateAttributesPacket.AttributeSnapshot snapshot : updateAttributesPacket.getValues()) {
+                AttributeInstance instance = ((LivingEntity) entity).getAttribute(snapshot.getAttribute());
+                instance.setBaseValue(snapshot.getBase());
+                instance.removeModifiers();
+                for (AttributeModifier modifier : snapshot.getModifiers()) {
+                    instance.addPermanentModifier(modifier);
+                }
+            }
+        } else if (packet instanceof ClientboundAnimatePacket animatePacket) {
+            ChunkMap.TrackedEntity trackedEntity = ((ServerLevel) entity.level).chunkSource.chunkMap.entityMap.get(entity.getId());
+            if (trackedEntity != null) {
+                trackedEntity.broadcast(new ClientboundAnimatePacket(entity, animatePacket.getAction()));
+            } else {
+                LOGGER.warn(entity + " has no TrackedEntity!");
+            }
+        } else if (packet instanceof ClientboundEntityEventPacket entityEventPacket) {
+            ChunkMap.TrackedEntity trackedEntity = ((ServerLevel) entity.level).chunkSource.chunkMap.entityMap.get(entity.getId());
+            if (trackedEntity != null) {
+                trackedEntity.broadcast(new ClientboundEntityEventPacket(entity, entityEventPacket.getEventId()));
+            } else {
+                LOGGER.warn(entity + " has no TrackedEntity!");
+            }
+        } else if (packet instanceof ClientboundSetEquipmentPacket setEquipmentPacket) {
+            for (Pair<EquipmentSlot, ItemStack> pair : setEquipmentPacket.getSlots()) {
+                entity.setItemSlot(pair.getFirst(), pair.getSecond());
+            }
+        } else {
+            LOGGER.warn("Unhandled packet " + packet);
+        }
+    }
+
+    public static void handleEntityWithDependenicesUpdate(Entity entity, Entity[] entities, Packet<?> packet) {
+        if (packet instanceof ClientboundSetPassengersPacket setPassengersPacket) {
+            for (Entity riding : entity.getPassengers()) {
+                if (!ArrayUtils.contains(entities, riding)) {
+                    riding.stopRiding();
+                }
+            }
+            for (Entity passenger : entities) {
+                if (!entity.getPassengers().contains(passenger)) {
+                    passenger.startRiding(entity, true);
+                }
+            }
+        } else if (packet instanceof ClientboundSetEntityLinkPacket setEntityLinkPacket) {
+            if (entities.length == 0) {
+                ((Mob) entity).setLeashedTo(null, true);
+            } else {
+                ((Mob) entity).setLeashedTo(entities[0], true);
+            }
+        } else if (packet instanceof ClientboundTakeItemEntityPacket takeItemEntityPacket) {
+            ((LivingEntity) entities[0]).take(entity, takeItemEntityPacket.getAmount());
+        } else {
+            LOGGER.warn("Unhandled dependencies packet " + packet);
+        }
+    }
+
+    public static void onEntitySpawn(Entity entity) {
+        if (!entity.shouldBeSaved()) return;
+
+        MultiPaper.runSync(() -> { // Run this after the entity has finished spawning
+            LevelChunk chunk = entity.level.getChunkIfLoaded(entity.blockPosition());
+            if (chunk != null) {
+                MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdateNBTPacket(entity));
+            } else {
+                LOGGER.warn(entity + " spawned in an unloaded chunk");
+            }
+        });
+    }
+
+    public static void onEntityRemove(Entity entity) {
+        if (!entity.shouldBeSaved()) return;
+
+        LevelChunk chunk = entity.level.getChunkIfLoaded(entity.blockPosition());
+        if (chunk != null) {
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityRemovePacket(entity));
+        } else {
+            LOGGER.warn(entity + " removed in an unloaded chunk");
+        }
+    }
+
+    public static void onEntityUpdate(Entity entity, Packet<?> packet) {
+        if ((packet instanceof ClientboundMoveEntityPacket || packet instanceof ClientboundTeleportEntityPacket)
+                && MultiPaper.isRealPlayer(entity)) {
+            MultiPaper.broadcastPacketToExternalServers(new EntityUpdatePacket(entity, packet));
+            return;
+        }
+
+        LevelChunk chunk = entity.level.getChunkIfLoaded(entity.blockPosition());
+
+        if (packet instanceof ClientboundSetPassengersPacket setPassengersPacket) {
+            List<Entity> entities = new ArrayList<>();
+            for (int id : setPassengersPacket.getPassengers()) {
+                entities.add(entity.level.getEntity(id));
+            }
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        } else if (packet instanceof ClientboundSetEntityLinkPacket setEntityLinkPacket) {
+            List<Entity> entities = new ArrayList<>();
+            entities.add(entity.level.getEntity(setEntityLinkPacket.getDestId()));
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        } else if (packet instanceof ClientboundTakeItemEntityPacket takeItemEntityPacket) {
+            List<Entity> entities = new ArrayList<>();
+            entities.add(entity.level.getEntity(takeItemEntityPacket.getPlayerId()));
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdateWithDependenciesPacket(entity, entities, packet));
+            return;
+        }
+
+        if (chunk != null) {
+            MultiPaper.broadcastPacketToExternalServers(chunk.externalEntitiesSubscribers, () -> new EntityUpdatePacket(entity, packet));
+        } else {
+            LOGGER.warn("onEntityUpdate was called for an unloaded chunk " + entity);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java b/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..a69c0ab8a07a32020946489acf97b9bd1e22778d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperPlayerHandler.java
@@ -0,0 +1,21 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
+import net.minecraft.network.protocol.game.ServerboundPlayerAbilitiesPacket;
+import net.minecraft.network.protocol.game.ServerboundSetCarriedItemPacket;
+import net.minecraft.server.level.ServerPlayer;
+import puregero.multipaper.externalserverprotocol.PlayerActionPacket;
+
+public class MultiPaperPlayerHandler {
+    public static void handlePlayerAbilities(ServerPlayer player, ServerboundPlayerAbilitiesPacket packet) {
+        if (MultiPaper.isRealPlayer(player)) {
+            MultiPaper.broadcastPacketToExternalServers(new PlayerActionPacket(player, packet));
+        }
+    }
+
+    public static void handleClientInformation(ServerPlayer player, ServerboundClientInformationPacket packet) {
+        if (MultiPaper.isRealPlayer(player)) {
+            MultiPaper.broadcastPacketToExternalServers(new PlayerActionPacket(player, packet));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b9fd457b215c608edc5a68ef0369f7eb614629b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityRemovePacket.java
@@ -0,0 +1,54 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.UUID;
+
+public class EntityRemovePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityRemovePacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+
+    public EntityRemovePacket(Entity entity) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+    }
+
+    public EntityRemovePacket(DataInputStream in) throws IOException {
+        this.world = in.readUTF();
+        this.uuid = readUUID(in);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        writeUUID(out, uuid);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            Entity entity = level.getEntity(uuid);
+            if (entity != null) {
+                entity.setRemoved(Entity.RemovalReason.DISCARDED);
+            } else {
+                LOGGER.warn("Tried to remove a non-existent entity with uuid " + uuid);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..b2d78f522b4fbb43a5cc568c3b4d582d87fa9090
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateNBTPacket.java
@@ -0,0 +1,83 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.UUID;
+
+public class EntityUpdateNBTPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdateNBTPacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final byte[] data;
+
+    public EntityUpdateNBTPacket(Entity entity) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+
+        CompoundTag tag = new CompoundTag();
+        entity.save(tag);
+
+        try {
+            this.data = MultiPaper.nbtCompressToBytes(tag);
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public EntityUpdateNBTPacket(DataInputStream in) throws IOException {
+        this.world = in.readUTF();
+        this.uuid = readUUID(in);
+        int byteLength = in.readInt();
+        this.data = new byte[byteLength];
+        in.readFully(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        writeUUID(out, uuid);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            try {
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                Entity entity = level.getEntity(uuid);
+                CompoundTag tag = MultiPaper.nbtDecompressFromBytes(data);
+                if (entity == null) {
+                     EntityType.loadEntityRecursive(tag, level, entity2 -> {
+                        if (level.entityManager.isPending(entity2.chunkPosition().longKey) || level.entityManager.areEntitiesLoaded(entity2.chunkPosition().longKey)) {
+                            level.entityManager.addNewEntity(entity2);
+                            return entity2;
+                        } else {
+                            LOGGER.warn("Tried to create an entity from nbt, but the entities for that chunk aren't loaded: " + entity2);
+                            return null;
+                        }
+                    });
+                } else {
+                    entity.load(tag);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..35985e8d9703380c362d31e6593e281fdba6991c
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdatePacket.java
@@ -0,0 +1,81 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.UUID;
+
+public class EntityUpdatePacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdatePacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final Packet<?> packet;
+
+    public EntityUpdatePacket(Entity entity, Packet<?> packet) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+        this.packet = packet;
+    }
+
+    public EntityUpdatePacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        uuid = readUUID(in);
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        writeUUID(out, uuid);
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            Entity entity = level.getEntity(uuid);
+
+            if (entity == null) {
+                LOGGER.warn("Could not find entity " + uuid + " for " + packet.getClass().getSimpleName());
+                return;
+            }
+
+            MultiPaperEntitiesHandler.handleEntityUpdate(entity, packet);
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..2587a9bc72dafab4480e8db612518c0685d3e381
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/EntityUpdateWithDependenciesPacket.java
@@ -0,0 +1,107 @@
+package puregero.multipaper.externalserverprotocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntitiesHandler;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Objects;
+import java.util.UUID;
+
+public class EntityUpdateWithDependenciesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(EntityUpdateWithDependenciesPacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final UUID[] uuids;
+    private final Packet<?> packet;
+
+    public EntityUpdateWithDependenciesPacket(Entity entity, Collection<Entity> dependents, Packet<?> packet) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+        this.uuids = dependents.stream().filter(Objects::nonNull).map(Entity::getUUID).toArray(UUID[]::new);
+        this.packet = packet;
+    }
+
+    public EntityUpdateWithDependenciesPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        uuid = readUUID(in);
+
+        uuids = new UUID[in.read()];
+
+        for (int i = 0; i < uuids.length; i++) {
+            uuids[i] = readUUID(in);
+        }
+
+        int length = in.readInt();
+        byte[] bytes = new byte[length];
+        in.readFully(bytes);
+        ByteBuf buf = Unpooled.wrappedBuffer(bytes);
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        int packetId = friendlyByteBuf.readVarInt();
+        packet = ConnectionProtocol.PLAY.createPacket(PacketFlow.CLIENTBOUND, packetId, friendlyByteBuf);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        writeUUID(out, uuid);
+
+        out.write(uuids.length);
+        for (UUID uuid : uuids) {
+            writeUUID(out, uuid);
+        }
+
+        ConnectionProtocol protocol = ConnectionProtocol.getProtocolForPacket(packet);
+        Integer id = protocol.getPacketId(PacketFlow.CLIENTBOUND, packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(buf);
+        friendlyByteBuf.writeVarInt(id);
+        packet.write(friendlyByteBuf);
+        byte[] bytes = buf.array();
+        out.writeInt(bytes.length);
+        out.write(bytes);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+            Entity entity = level.getEntity(uuid);
+
+            if (entity == null) {
+                LOGGER.warn("Could not find entity " + uuid + " for " + packet.getClass().getSimpleName());
+                return;
+            }
+
+            Entity[] entities = new Entity[uuids.length];
+
+            for (int i = 0; i < uuids.length; i++) {
+                entities[i] = level.getEntity(uuids[i]);
+
+                if (entities[i] == null) {
+                    LOGGER.warn("Could not find dependent entity " + uuids[i] + " for " + packet.getClass().getSimpleName());
+                    return;
+                }
+            }
+
+            MultiPaperEntitiesHandler.handleEntityWithDependenicesUpdate(entity, entities, packet);
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index 526d780f0309b0b081761cf143c5fd547e6eea57..a3313c5edf5e8a4a78accd830eede0e39d4f4e84 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -25,6 +25,12 @@ public class ExternalServerPacketSerializer {
         addPacket(PlayerActionPacket.class, PlayerActionPacket::new);
         addPacket(PlayerInventoryUpdatePacket.class, PlayerInventoryUpdatePacket::new);
         addPacket(TimeUpdatePacket.class, TimeUpdatePacket::new);
+        addPacket(RequestEntitiesPacket.class, RequestEntitiesPacket::new);
+        addPacket(SendEntitiesPacket.class, SendEntitiesPacket::new);
+        addPacket(EntityUpdateNBTPacket.class, EntityUpdateNBTPacket::new);
+        addPacket(EntityUpdatePacket.class, EntityUpdatePacket::new);
+        addPacket(EntityUpdateWithDependenciesPacket.class, EntityUpdateWithDependenciesPacket::new);
+        addPacket(EntityRemovePacket.class, EntityRemovePacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, IOExceptionFunction<DataInputStream, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
index b242b1f00b4f4380db4d2c3d5a9c7ec66f478fcd..38d4b1f8ad24cd3003ddc891afb7c0c9bcce83ff 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/PlayerActionPacket.java
@@ -60,13 +60,15 @@ public class PlayerActionPacket extends ExternalServerPacket {
 
     @Override
     public void handle(ExternalServerConnection connection) {
-        ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
+        MultiPaper.runSync(() -> {
+            ServerPlayer player = MinecraftServer.getServer().getPlayerList().getPlayer(uuid);
 
-        if (player == null) {
-            LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
-            return;
-        }
+            if (player == null) {
+                LOGGER.warn("Tried to run an action on a non-existent player with uuid " + uuid);
+                return;
+            }
 
-        player.server.execute(() -> action.handle(player.connection));
+            action.handle(player.connection);
+        });
     }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..8482ed16ef089d1b2b882672ee4d82da973ec718
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/RequestEntitiesPacket.java
@@ -0,0 +1,63 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.ChunkPos;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import puregero.multipaper.ExternalServerConnection;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+public class RequestEntitiesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(RequestEntitiesPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+
+    public RequestEntitiesPacket(String world, int cx, int cz) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+    }
+
+    public RequestEntitiesPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        sendChunkLater(connection, world, cx, cz, 0);
+    }
+
+    private void sendChunkLater(ExternalServerConnection connection, String world, int cx, int cz, int depth) {
+        ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+        if (!level.entityManager.areEntitiesLoaded(ChunkPos.asLong(cx, cz))) {
+            if (depth == 20) {
+                LOGGER.warn(connection.externalServer.getName() + " is requesting entities " + world + "," + cx + "," + cz + " but we timed out waiting for them to load.");
+                connection.send(new SendEntitiesPacket(world, cx, cz, null));
+                return;
+            }
+            ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                sendChunkLater(connection, world, cx, cz, depth + 1);
+            }, 1, "ExternalServerConnection-sendEntitiesLater");
+        } else {
+            connection.send(new SendEntitiesPacket(level, new ChunkPos(cx, cz)));
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..6215a9b547e36ea51fd1f42c066d8b09c28d63ae
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendEntitiesPacket.java
@@ -0,0 +1,139 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.*;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.entity.ChunkEntities;
+import net.minecraft.world.level.entity.EntityInLevelCallback;
+import net.minecraft.world.level.entity.PersistentEntitySectionManager;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftWorld;
+import puregero.multipaper.ChunkKey;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.zip.InflaterInputStream;
+
+public class SendEntitiesPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(SendEntitiesPacket.class.getSimpleName());
+
+    private final String world;
+    private final int cx;
+    private final int cz;
+    private final byte[] data;
+
+    public SendEntitiesPacket(LevelChunk chunk) {
+        this(chunk.level, chunk.getPos());
+    }
+
+    public SendEntitiesPacket(ServerLevel level, ChunkPos pos) {
+        this(level.convertable.getLevelId(), pos.x, pos.z, getEntites(level, pos));
+    }
+
+    private static CompoundTag getEntites(ServerLevel level, ChunkPos pos) {
+        if (!level.entityManager.areEntitiesLoaded(pos.longKey)) throw new IllegalStateException("Entities are not loaded in " + level.convertable.getLevelId() + pos);
+        CompoundTag entitiesRoot = new CompoundTag();
+        ListTag entities = new ListTag();
+        for (Entity entity : level.entityManager.getEntities(pos)) {
+            if (entity.shouldBeSaved()) {
+                CompoundTag tag = new CompoundTag();
+                entity.save(tag);
+                entities.add(tag);
+            }
+        }
+        entitiesRoot.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
+        entitiesRoot.put("Entities", entities);
+        entitiesRoot.put("Position", new IntArrayTag(new int[]{pos.x, pos.z}));
+        return entitiesRoot;
+    }
+
+    public SendEntitiesPacket(String world, int cx, int cz, CompoundTag tag) {
+        this.world = world;
+        this.cx = cx;
+        this.cz = cz;
+
+        try {
+            if (tag == null) {
+                data = new byte[0];
+            } else {
+                data = MultiPaper.nbtCompressToBytes(tag);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public SendEntitiesPacket(DataInputStream in) throws IOException {
+        world = in.readUTF();
+        cx = in.readInt();
+        cz = in.readInt();
+
+        int byteLength = in.readInt();
+        data = new byte[byteLength];
+        in.readFully(data);
+    }
+
+    @Override
+    public void write(DataOutputStream out) throws IOException {
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(data.length);
+        out.write(data);
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        try {
+            Consumer<byte[]> callback = connection.entitiesCallbacks.remove(new ChunkKey(world, cx, cz));
+            if (callback != null) {
+                if (data.length == 0) {
+                    LOGGER.warn(connection.externalServer.getName() + " sent us an empty entities for " + world + "," + cx + "," + cz + ", force loading it from disk");
+                    MultiPaper.getConnection().forceReadChunk(world, "entities", cx, cz).thenAccept(callback);
+                } else {
+                    callback.accept(data);
+                }
+            } else {
+                // Replace the existing entities with these new entities
+                ChunkPos pos = new ChunkPos(cx, cz);
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                // Check that we have these entities loaded in the first place
+                if (level.entityManager.chunkLoadStatuses.containsKey(pos.longKey)) {
+                    CompoundTag tag = data.length == 0 ? null : NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+                    ListTag entities = tag == null ? new ListTag() : tag.getList("Entities", Tag.TAG_COMPOUND);
+                    MultiPaper.runSync(() -> {
+                        // Remove existing entities in this chunk
+                        for (Entity entity : level.entityManager.getEntities(new ChunkPos(cx, cz))) {
+                            if (entity.shouldBeSaved()) {
+                                entity.setRemoved(Entity.RemovalReason.UNLOADED_TO_CHUNK);
+                                entity.setLevelCallback(EntityInLevelCallback.NULL);
+                            }
+                        }
+                        // Add our entities to be loaded
+                        List<Entity> list = EntityType.loadEntitiesRecursive(entities, level).collect(Collectors.toList());
+                        level.entityManager.chunkLoadStatuses.put(pos.longKey, PersistentEntitySectionManager.ChunkLoadStatus.PENDING);
+                        level.entityManager.loadingInbox.add(new ChunkEntities<>(pos, list));
+                    });
+                } else {
+                    LOGGER.warn("Unsolicited entities for " + world + "," + cx + "," + cz);
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
index b2bcaa3fbb1f9640faf3d7c61ba1a7087d46db12..389878c9f2a66e336b983f7b760a9584ae76f5f9 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendUpdatePacket.java
@@ -10,6 +10,7 @@ import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
+import net.minecraft.server.level.ServerLevel;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import puregero.multipaper.ExternalServerConnection;
@@ -27,6 +28,11 @@ public class SendUpdatePacket extends ExternalServerPacket {
     private final String world;
     private final Packet<?> packet;
 
+    public SendUpdatePacket(ServerLevel level, Packet<?> packet) {
+        this.world = level.convertable.getLevelId();
+        this.packet = packet;
+    }
+
     public SendUpdatePacket(String world, Packet<?> packet) {
         this.world = world;
         this.packet = packet;
