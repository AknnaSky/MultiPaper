From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Thu, 21 Jan 2021 16:57:51 +1000
Subject: [PATCH] Ensure players get moved to their new server


diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 37b3cb2fa82dbb65188c866e5c1ae19c9ac7c1ea..a9d648030177d39f232d8785b61c0aafcb6a2f9a 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -34,34 +34,20 @@ public class MultiPaperConnection extends Thread {
     private HashMap<Integer, Request> callbacks = new HashMap<>();
     private HashMap<String, ExternalServer> serversMap = new HashMap<>();
     private String myName = null;
+    private WriterWorkerThread writer = new WriterWorkerThread(() -> socket);
     public HashMap<UUID, Location> playerLocations = new HashMap<>();
 
     public MultiPaperConnection() {
+        super("MultiPaperConnection Thread");
         start();
     }
 
-    public void send(byte[] bytes, int id, @Nullable Consumer<DataInputStream> callback) throws IOException {
-        while (true) {
-            try {
-                synchronized (socket) {
-                    if (callback != null) {
-                        callbacks.put(id, new Request(bytes, callback));
-                    }
-                    socket.getOutputStream().write(bytes);
-                    return;
-                }
-            } catch (Exception e) {
-                if (socket != null) {
-                    e.printStackTrace();
-                }
-            }
-
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException e) {
-                throw new IOException(e);
-            }
+    public void send(byte[] bytes, int id, @Nullable Consumer<DataInputStream> callback) {
+        Request request = new Request(bytes, callback);
+        if (callback != null) {
+            callbacks.put(id, request);
         }
+        writer.write(request);
     }
 
     public DataOutputSender buffer(int id) throws IOException {
@@ -88,16 +74,18 @@ public class MultiPaperConnection extends Thread {
             LOGGER.info("Connecting to " + server + "...");
             String[] serverParts = server.split(":");
             try (Socket socket = new Socket(serverParts[0], Integer.parseInt(serverParts[1]))) {
+                DataOutputStream out = new DataOutputStream(socket.getOutputStream());
+                out.writeUTF(myName = MultiPaper.getBungeeCordName());
+                
                 this.socket = socket;
                 LOGGER.info("Connected to " + server);
 
                 synchronized (socket) {
-                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());
-                    out.writeUTF(myName = MultiPaper.getBungeeCordName());
-
                     // Resend requests on this new socket
                     for (Request request : callbacks.values()) {
-                        socket.getOutputStream().write(request.getData());
+                        if (request.setLastSocket(socket)) {
+                            socket.getOutputStream().write(request.getData());
+                        }
                     }
                 }
 
@@ -340,7 +328,7 @@ public class MultiPaperConnection extends Thread {
     }
 
     public void start(DataInputStream in, DataOutputSender out) throws IOException {
-        if (DedicatedServer.getServer() != null) {
+        if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
             MultiPaper.broadcastPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, DedicatedServer.getServer().getPlayerList().players.toArray(new EntityPlayer[0])));
         }
     }
diff --git a/src/main/java/puregero/multipaper/Request.java b/src/main/java/puregero/multipaper/Request.java
index 19b017cb8118b72d06c7016605cf17bb9dcad131..47f33a3aee0b5332bd4a3819d2fbe5ed23a07109 100644
--- a/src/main/java/puregero/multipaper/Request.java
+++ b/src/main/java/puregero/multipaper/Request.java
@@ -1,9 +1,11 @@
 package puregero.multipaper;
 
 import java.io.DataInputStream;
+import java.net.Socket;
 import java.util.function.Consumer;
 
 public class Request {
+    private Socket lastSocket;
     private final byte[] data;
     private final Consumer<DataInputStream> callback;
     private final long time = System.currentTimeMillis();
@@ -24,4 +26,17 @@ public class Request {
     public long getTime() {
         return time;
     }
+
+    /**
+     * @return True if the socket is not the same as the last socket, false
+     * otherwise
+     */
+    public synchronized boolean setLastSocket(Socket socket) {
+        if (socket == lastSocket) {
+            return false;
+        }
+        
+        lastSocket = socket;
+        return true;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/WriterWorkerThread.java b/src/main/java/puregero/multipaper/WriterWorkerThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7c3cc5e40db63359e4da69a647b8c1ed427b4b0
--- /dev/null
+++ b/src/main/java/puregero/multipaper/WriterWorkerThread.java
@@ -0,0 +1,75 @@
+package puregero.multipaper;
+
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.LinkedList;
+import java.util.Queue;
+import java.util.function.Supplier;
+
+public class WriterWorkerThread extends Thread {
+
+    private static final int MAX_QUEUE_SIZE = 16;
+    
+    private final Supplier<Socket> socketSupplier;
+    private final Queue<Request> queue = new LinkedList<>();
+
+    public WriterWorkerThread(Supplier<Socket> socketSupplier) {
+        super("WriterWorkerThread");
+        this.socketSupplier = socketSupplier;
+        start();
+    }
+    
+    public void write(Request request) {
+        while (true) {
+            synchronized (queue) {
+                // MultiPaperConnection gets priority in the queue, it mustn't block otherwise the connection can stall
+                if (queue.size() < MAX_QUEUE_SIZE || Thread.currentThread() instanceof MultiPaperConnection) {
+                    queue.add(request);
+                    queue.notify();
+                    return;
+                }
+            }
+
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+    
+    public void run() {
+        Request toWrite;
+        
+        while (true) {
+            synchronized (queue) {
+                while (queue.isEmpty()) {
+                    try {
+                        queue.wait();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                        return;
+                    }
+                }
+
+                toWrite = queue.poll();
+            }
+
+            try {
+                Socket socket = socketSupplier.get();
+
+                if (toWrite.setLastSocket(socket)) {
+                    synchronized (socket) {
+                        socket.getOutputStream().write(toWrite.getData());
+                    }
+                }
+            } catch (NullPointerException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    
+}
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
index ab8cf248ff8496e37f11ba49481e41118c2bf381..959699e2aa6747c87b70c56974bc2ca58fc1e5a8 100644
--- a/src/main/java/puregero/multipaper/Zone.java
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -89,6 +89,9 @@ public class Zone {
         for (Player player : toSend) {
             ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
             BungeeCord.connectPlayer(player, server);
+            
+            // Check back in 15 seconds to see if they've moved servers yet
+            ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> ensureMovedServer(player), 15 * 20, "Ensure player moved servers");
         }
 
         ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> zone.chunks.forEach(Chunk::unload), 0, "Unload Chunks");
@@ -96,7 +99,30 @@ public class Zone {
         return toSend;
     }
 
-    public static void checkIfShouldMerge(Chunk chunk) {
+    /** 
+     * Ensure a player has been moved to another server. If they haven't, put
+     * them back on this server and check if they still need to be moved.
+     */
+    private static void ensureMovedServer(Player player) {
+        // Remove the player from beingSentToAnotherServer will put them back on the server
+        if (player.isOnline() && beingSentToAnotherServer.remove(player)) {
+            zonesToUnload.remove(player);
+            
+            LOGGER.info(player.getName() + " failed to move servers, checking if they still need to");
+            
+            // If the chunk isn't loaded, paper'll load it and do these checks later
+            if (player.getLocation().isChunkLoaded()) {
+                CraftChunk chunk = (CraftChunk) player.getChunk();
+                
+                // Check if the chunk should merge, and if it shouldn't, try to lock the chunk
+                if (!checkIfShouldMerge(chunk)) {
+                    MultiPaper.lockChunk(chunk.getHandle().getPos(), chunk.getCraftWorld().getHandle());
+                }
+            }
+        }
+    }
+
+    public static boolean checkIfShouldMerge(Chunk chunk) {
         ExternalServer serverTo = MultiPaper.getMe();
 
         // Find server with lowest average tick time
@@ -109,19 +135,19 @@ public class Zone {
 
         if (serverTo.isMe()) {
             // Can't merge with yourself
-            return;
+            return false;
         }
 
         Zone zone = new Zone(chunk, SHOULD_MERGE_CHUNK_LIMIT);
 
         if (zone.chunks.size() >= SHOULD_MERGE_CHUNK_LIMIT) {
             // Too many chunks loaded, probably not worth merging
-            return;
+            return false;
         }
 
         if (zone.players.isEmpty()) {
             // No one to merge
-            return;
+            return false;
         }
 
         HashSet<Player> nearbyPlayers = new HashSet<>();
@@ -137,10 +163,12 @@ public class Zone {
             // There are nearby players on this server, this will probably mean
             // that if we merge with another server, we might end up merging
             // back very soon
-            return;
+            return false;
         }
 
         Zone.doMerge(chunk, zone, serverTo.getName());
+        
+        return true;
     }
 
     public static void onPlayerDisconnect(Player player) {
