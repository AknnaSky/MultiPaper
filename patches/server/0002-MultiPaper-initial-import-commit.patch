From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 17 Jan 2021 15:56:33 +1000
Subject: [PATCH] MultiPaper initial import commit


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 921253a06daa414aed7dc6824effc65db09ea7a5..2d5b2743ab621e19ec67874abbbaec5846f61b37 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -670,7 +670,7 @@ public class PaperWorldConfig {
 
     public long delayChunkUnloadsBy;
     private void delayChunkUnloadsBy() {
-        delayChunkUnloadsBy = PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s"));
+        delayChunkUnloadsBy = 0; // PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s")); // MultiPaper disable delay
         if (delayChunkUnloadsBy > 0) {
             log("Delaying chunk unloads by " + delayChunkUnloadsBy + " seconds");
             delayChunkUnloadsBy *= 20;
diff --git a/src/main/java/net/minecraft/advancements/CriterionProgress.java b/src/main/java/net/minecraft/advancements/CriterionProgress.java
index cc2d025c899039854fbc500709ec4008c985cd38..642e1d92fc02fe15fe84b1d126028cb46568da3f 100644
--- a/src/main/java/net/minecraft/advancements/CriterionProgress.java
+++ b/src/main/java/net/minecraft/advancements/CriterionProgress.java
@@ -45,7 +45,11 @@ public class CriterionProgress {
     }
 
     public JsonElement e() {
-        return (JsonElement) (this.b != null ? new JsonPrimitive(CriterionProgress.a.format(this.b)) : JsonNull.INSTANCE);
+        try {
+            return (JsonElement) (this.b != null ? new JsonPrimitive(CriterionProgress.a.format(this.b)) : JsonNull.INSTANCE);
+        } catch (Exception e) {
+            return JsonNull.INSTANCE;
+        }
     }
 
     public static CriterionProgress b(PacketDataSerializer packetdataserializer) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSpectate.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSpectate.java
index c2a94249292df63f8b1c2ca3afe302fcc35ff831..4e76f8b93424883de1ccc94814f381d1a6063af8 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSpectate.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayInSpectate.java
@@ -36,4 +36,10 @@ public class PacketPlayInSpectate implements Packet<PacketListenerPlayIn> {
     public Entity a(WorldServer worldserver) {
         return worldserver.getEntity(this.a);
     }
+    
+    // MultiPaper start - Expose uuid
+    public UUID getUUID() {
+        return a;
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerInfo.java b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerInfo.java
index 2758cf87fe5cb89c101f2495783c72a2fe4ad632..053ecfdd16b1bcf1423ea7735b4fe3255c05b05c 100644
--- a/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerInfo.java
+++ b/src/main/java/net/minecraft/network/protocol/game/PacketPlayOutPlayerInfo.java
@@ -46,6 +46,26 @@ public class PacketPlayOutPlayerInfo implements Packet<PacketListenerPlayOut> {
 
     }
 
+    // MultiPaper start
+    public PacketPlayOutPlayerInfo(Iterable<PlayerInfoData> iterable) {
+        this.a = EnumPlayerInfoAction.ADD_PLAYER;
+
+        Iterator<PlayerInfoData> iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            this.b.add(iterator.next());
+        }
+    }
+
+   public PacketPlayOutPlayerInfo.EnumPlayerInfoAction getAction() {
+        return a;
+    }
+
+    public List<PacketPlayOutPlayerInfo.PlayerInfoData> getPlayerInfoDatas() {
+        return b;
+    }
+    // MultiPaper end
+
     @Override
     public void a(PacketDataSerializer packetdataserializer) throws IOException {
         this.a = (PacketPlayOutPlayerInfo.EnumPlayerInfoAction) packetdataserializer.a(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.class);
@@ -174,10 +194,12 @@ public class PacketPlayOutPlayerInfo implements Packet<PacketListenerPlayOut> {
 
     public class PlayerInfoData {
 
-        private final int b;
-        private final EnumGamemode c;
-        private final GameProfile d;
-        private final IChatBaseComponent e;
+        // MultiPaper start - make not final and public
+        public int b;
+        public EnumGamemode c;
+        public GameProfile d;
+        public IChatBaseComponent e;
+        // MultiPaper end
 
         public PlayerInfoData(GameProfile gameprofile, int i, EnumGamemode enumgamemode, @Nullable IChatBaseComponent ichatbasecomponent) {
             this.d = gameprofile;
diff --git a/src/main/java/net/minecraft/server/AdvancementDataPlayer.java b/src/main/java/net/minecraft/server/AdvancementDataPlayer.java
index 7a8a1960882e291c46301d07da3e1c5415516893..ad189289ad6b179731ee73242234a88ee819da3c 100644
--- a/src/main/java/net/minecraft/server/AdvancementDataPlayer.java
+++ b/src/main/java/net/minecraft/server/AdvancementDataPlayer.java
@@ -51,6 +51,7 @@ import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.GameRules;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class AdvancementDataPlayer {
 
@@ -158,9 +159,15 @@ public class AdvancementDataPlayer {
     }
 
     private void d(AdvancementDataWorld advancementdataworld) {
-        if (this.f.isFile()) {
+        String json = null;
+        try {
+            json = MultiPaper.readAdvancements(player.getUniqueIDString());
+        } catch (IOException e1) {
+            e1.printStackTrace();
+        }
+        if ((json != null && !json.isEmpty()) || this.f.isFile()) {
             try {
-                JsonReader jsonreader = new JsonReader(new StringReader(Files.toString(this.f, StandardCharsets.UTF_8)));
+                JsonReader jsonreader = new JsonReader(new StringReader(json));
                 Throwable throwable = null;
 
                 try {
@@ -248,6 +255,12 @@ public class AdvancementDataPlayer {
         jsonelement.getAsJsonObject().addProperty("DataVersion", SharedConstants.getGameVersion().getWorldVersion());
 
         try {
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeAdvancements(player.getUniqueIDString(), AdvancementDataPlayer.b.toJson(jsonelement));
+                return;
+            }
+            // MultiPaper end
             FileOutputStream fileoutputstream = new FileOutputStream(this.f);
             Throwable throwable = null;
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c372e6897c73fad6f9c478cec9f58303fb0cce17..3a6068b7dc2ddc3b6635a33a09226be38a752d97 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -182,6 +182,8 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.ShutdownHandler;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
 
@@ -882,6 +884,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         // CraftBukkit end
         MinecraftServer.LOGGER.info("Stopping server");
         MinecraftTimings.stopServer(); // Paper
+        ShutdownHandler.onStop(); // MultiPaper
         // CraftBukkit start
         if (this.server != null) {
             this.server.disablePlugins();
@@ -1400,6 +1403,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         tickTimes60s.add(this.ticks, l);
         // Paper end
 
+        MultiPaper.sendTickTime(i1 - i); // MultiPaper
         this.circularTimer.a(i1 - i);
         this.methodProfiler.exit();
         org.spigotmc.WatchdogThread.tick(); // Spigot
diff --git a/src/main/java/net/minecraft/server/commands/CommandReload.java b/src/main/java/net/minecraft/server/commands/CommandReload.java
index 2c66816f7930e90559feaf4c5b0790d3358882b7..01ff3713aff19b231b616376fb41c011b74eefdf 100644
--- a/src/main/java/net/minecraft/server/commands/CommandReload.java
+++ b/src/main/java/net/minecraft/server/commands/CommandReload.java
@@ -12,14 +12,13 @@ import net.minecraft.server.packs.repository.ResourcePackRepository;
 import net.minecraft.world.level.storage.SaveData;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
 
 public class CommandReload {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
     public static void a(Collection<String> collection, CommandListenerWrapper commandlistenerwrapper) {
-        commandlistenerwrapper.getServer().reloadServerResources(collection, ServerResourcesReloadedEvent.Cause.COMMAND).exceptionally((throwable) -> { // Paper
+        commandlistenerwrapper.getServer().a(collection).exceptionally((throwable) -> {
             CommandReload.LOGGER.warn("Failed to execute reload", throwable);
             commandlistenerwrapper.sendFailureMessage(new ChatMessage("commands.reload.failure"));
             return null;
@@ -49,7 +48,7 @@ public class CommandReload {
         SaveData savedata = minecraftserver.getSaveData();
         Collection<String> collection = resourcepackrepository.d();
         Collection<String> collection1 = a(resourcepackrepository, savedata, collection);
-        minecraftserver.reloadServerResources(collection1, ServerResourcesReloadedEvent.Cause.PLUGIN); // Paper
+        minecraftserver.a(collection1);
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 52bb528e75eb43156ee2bf19877bc051a35bb6e3..e0f6afc17b1a2c71bef8d2bd22ebec88c72e7cbe 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -69,6 +69,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
@@ -252,6 +253,8 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
         // CraftBukkit end
 
+        MultiPaper.onStart(); // MultiPaper
+
         if (!this.getOnlineMode()) {
             DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
             DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
diff --git a/src/main/java/net/minecraft/server/level/ChunkProviderServer.java b/src/main/java/net/minecraft/server/level/ChunkProviderServer.java
index e542fe5fb63064e67c7fde8fad614826d6f3344c..ecdde15413cce7e02caed8028bddfd5d94559933 100644
--- a/src/main/java/net/minecraft/server/level/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/level/ChunkProviderServer.java
@@ -46,6 +46,7 @@ import net.minecraft.world.level.storage.Convertable;
 import net.minecraft.world.level.storage.WorldData;
 import net.minecraft.world.level.storage.WorldPersistentData;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ChunkProviderServer extends IChunkProvider {
 
@@ -693,6 +694,7 @@ public class ChunkProviderServer extends IChunkProvider {
 
     @Override
     public boolean a(BlockPosition blockposition) {
+        if (!MultiPaper.shouldTickChunk(world, world.getChunkIfLoaded(blockposition))) return false;
         // Paper start - optimize is ticking ready type functions
         // is ticking ready
         PlayerChunk playerChunk = this.getChunk(MCUtil.getCoordinateKey(blockposition));
@@ -861,6 +863,8 @@ public class ChunkProviderServer extends IChunkProvider {
                         Chunk chunk = (Chunk) optional1.get();
                         ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
 
+                        if (!MultiPaper.shouldTickChunk(this.world, chunk)) return; // MultiPaper - Should we tick this chunk?
+
                         if (!this.playerChunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, false)) { // Paper - optimise isOutsideOfRange
                             chunk.setInhabitedTime(chunk.getInhabitedTime() + j);
                             if (flag1 && (this.allowMonsters || this.allowAnimals) && this.world.getWorldBorder().isInBounds(chunk.getPos()) && !this.playerChunkMap.isOutsideOfRange(playerchunk, chunkcoordintpair, true)) { // Spigot // Paper - optimise isOutsideOfRange
diff --git a/src/main/java/net/minecraft/server/level/EntityPlayer.java b/src/main/java/net/minecraft/server/level/EntityPlayer.java
index 37c9b5fd712e30a9a0faccc840f738f4b2cfc723..936da1cc31ba8beee7b735d34cd07809dbc4e361 100644
--- a/src/main/java/net/minecraft/server/level/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/level/EntityPlayer.java
@@ -238,6 +238,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public final int[] mobCounts = new int[ENUMCREATURETYPE_TOTAL_ENUMS]; // Paper
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleMobDistanceMap;
     // Paper end
+    public boolean isBeingSentToAnotherServer = false; // MultiPaper
 
     // CraftBukkit start
     public String displayName;
@@ -249,6 +250,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public int newTotalExp = 0;
     public boolean keepLevel = false;
     public double maxHealthCache;
+    public boolean shouldTickEntities = true; // MultiPaper
     public boolean joining = true;
     public boolean sentListPacket = false;
     public boolean supressTrackerForLogin = false; // Paper
@@ -407,6 +409,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.ci = new Vec3D(nbttagcompound1.getDouble("x"), nbttagcompound1.getDouble("y"), nbttagcompound1.getDouble("z"));
         }
 
+        this.isBeingSentToAnotherServer = nbttagcompound.getBoolean("isBeingSentToAnotherServer"); // MultiPaper
+
         this.cd = nbttagcompound.getBoolean("seenCredits");
         if (nbttagcompound.hasKeyOfType("recipeBook", 10)) {
             this.recipeBook.a(nbttagcompound.getCompound("recipeBook"), this.server.getCraftingManager());
@@ -470,6 +474,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             }
         }
 
+        nbttagcompound.setBoolean("isBeingSentToAnotherServer", this.isBeingSentToAnotherServer); // MultiPaper
+
         if (persistVehicle && entity1 != null && entity != this && entity.hasSinglePlayerPassenger()) {
             // CraftBukkit end
             NBTTagCompound nbttagcompound2 = new NBTTagCompound();
diff --git a/src/main/java/net/minecraft/server/level/PlayerChunk.java b/src/main/java/net/minecraft/server/level/PlayerChunk.java
index a323b76f68c273a73cb3f20167a668b2100f4944..480a904788a6e3abe471494398ed09a79c7e6157 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunk.java
@@ -97,7 +97,7 @@ public class PlayerChunk {
         // it's important that we use getChunkAtIfLoadedImmediately to mirror the chunk sending logic used
         // in Chunk's neighbour callback
         Chunk ret = this.chunkMap.world.getChunkProvider().getChunkAtIfLoadedImmediately(this.location.x, this.location.z);
-        if (ret != null && ret.areNeighboursLoaded(1)) {
+        if (ret != null) { // MultiPaper somehow checking for neighbours breaks it
             return ret;
         }
         return null;
diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index 300884804bf9ac3fba7c30a04d8adf52e3dd2e3e..9b192db10d7fdc5ecf7d8b938e3d93675426fe5f 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -109,6 +109,8 @@ import org.apache.logging.log4j.Logger;
 
 import org.bukkit.entity.Player; // CraftBukkit
 import org.spigotmc.AsyncCatcher;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.Zone;
 
 public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
@@ -922,8 +924,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
             do {
                 boolean isShuttingDown = world.getMinecraftServer().hasStopped(); // Paper
+
+                if (!isShuttingDown) new Exception("PlayerChunkMap.save has been called even though the server isn't shutting down!").printStackTrace(); // MultiPaper
+
                 mutableboolean.setFalse();
                 list.stream().map((playerchunk) -> {
+                    MultiPaper.releaseChunk(playerchunk.location, playerchunk.getWorld());
+
                     CompletableFuture completablefuture;
 
                     do {
@@ -1028,6 +1035,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.LOW_PRIORITY);
 
         if (!chunk.isNeedsSaving()) {
+            MultiPaper.notifyChunkNotSaving(chunk.getPos(), this.world);
             return;
         }
 
@@ -1088,6 +1096,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     }
                     this.autoSaveQueue.remove(playerchunk); // Paper
 
+                    MultiPaper.releaseChunk(ichunkaccess.getPos(), this.world); // MultiPaper
+
                     try {
                         this.asyncSave(ichunkaccess); // Paper - async chunk saving
                     } catch (Throwable ex) {
@@ -1483,6 +1493,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
         this.m.a(ichunkaccess.getPos());
         if (!ichunkaccess.isNeedsSaving()) {
+            MultiPaper.notifyChunkNotSaving(ichunkaccess.getPos(), this.world);
             return false;
         } else {
             ichunkaccess.setLastSaved(this.world.getTime());
@@ -1673,6 +1684,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, world); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1684,6 +1696,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, world, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1746,6 +1764,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             // Paper start - async io
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         NBTTagCompound compound = this.readChunkData(chunkPos);
 
         return ChunkRegionLoader.getStatus(compound);
@@ -1854,6 +1874,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Paper - OBFHELPER
     private boolean b(EntityPlayer entityplayer) {
+        if (Zone.isBeingSentToAnotherServer(entityplayer.getBukkitEntity())) return true; // MultiPaper
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
 
diff --git a/src/main/java/net/minecraft/server/level/PlayerInteractManager.java b/src/main/java/net/minecraft/server/level/PlayerInteractManager.java
index 1511cf54fea53577a2808b5d84417eee834db984..21b33edd0a37dcf9854fb735ea810d8142d7aa2d 100644
--- a/src/main/java/net/minecraft/server/level/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/level/PlayerInteractManager.java
@@ -81,7 +81,7 @@ public class PlayerInteractManager {
         this.gamemode = enumgamemode;
         enumgamemode.a(this.player.abilities);
         this.player.updateAbilities();
-        this.player.server.getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_GAME_MODE, new EntityPlayer[]{this.player}), this.player); // CraftBukkit
+        this.player.server.getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_GAME_MODE, new EntityPlayer[]{this.player})); // CraftBukkit // MultiPaper - original sendAll
         this.world.everyoneSleeping();
     }
 
diff --git a/src/main/java/net/minecraft/server/level/WorldServer.java b/src/main/java/net/minecraft/server/level/WorldServer.java
index 0a698a5a4a6502a488c9afb0ad97165e60030896..5236c1a67bbb917a87969d9d95a540ede86c5850 100644
--- a/src/main/java/net/minecraft/server/level/WorldServer.java
+++ b/src/main/java/net/minecraft/server/level/WorldServer.java
@@ -167,6 +167,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class WorldServer extends World implements GeneratorAccessSeed {
@@ -326,7 +327,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
         convertable = convertable_conversionsession;
         uuid = WorldUUID.getUUID(convertable_conversionsession.folder.toFile());
         // CraftBukkit end
-        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList) {
+        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList && false) { // MultiPaper disable
             this.nextTickListBlock = new com.destroystokyo.paper.server.ticklist.PaperTickList<>(this, (block) -> {
                 return block == null || block.getBlockData().isAir();
             }, IRegistry.BLOCK::getKey, this::b, "Blocks"); // Paper - Timings
@@ -615,6 +616,8 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 Entity entity = (Entity) entry.getValue();
                 Entity entity1 = entity.getVehicle();
 
+                if (!MultiPaper.shouldTickEntity(this, entity)) continue; // MultiPaper - Should we tick this entity?
+
                 /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
                 if (!this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
                     entity.die();
diff --git a/src/main/java/net/minecraft/server/network/PlayerConnection.java b/src/main/java/net/minecraft/server/network/PlayerConnection.java
index 4a3f6f26da0d99ee2ff6942c2ff7d0595b53b684..5c17f52103637e7d5400a64b6882472fd061e771 100644
--- a/src/main/java/net/minecraft/server/network/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/network/PlayerConnection.java
@@ -218,6 +218,7 @@ import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class PlayerConnection implements PacketListenerPlayIn {
@@ -1392,10 +1393,16 @@ public class PlayerConnection implements PacketListenerPlayIn {
                                 }
 
                                 // Prevent 40 event-calls for less than a single pixel of movement >.>
-                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getX(), 2);
                                 float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
 
                                 if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isFrozen()) {
+                                    // MultiPaper start - Detect chunk movements
+                                    if ((int) lastPosX >> 4 != (int) to.getX() >> 4 || (int) lastPosZ >> 4 != (int) to.getZ() >> 4) {
+                                        MultiPaper.isChunkLocked((WorldServer) this.player.world, (int) to.getX() >> 4, (int) to.getZ() >> 4);
+                                    }
+                                    // MultiPaper end
+                                    
                                     this.lastPosX = to.getX();
                                     this.lastPosY = to.getY();
                                     this.lastPosZ = to.getZ();
@@ -1542,6 +1549,12 @@ public class PlayerConnection implements PacketListenerPlayIn {
             this.teleportAwait = 0;
         }
 
+        // MultiPaper start - Detect chunk movements
+        if ((int) lastPosX >> 4 != (int) teleportPos.x >> 4 || (int) lastPosZ >> 4 != (int) teleportPos.z >> 4) {
+            MultiPaper.isChunkLocked((WorldServer) this.player.world, (int) teleportPos.x >> 4, (int) teleportPos.z >> 4);
+        }
+        // MultiPaper end
+
         // CraftBukkit start - update last location
         this.lastPosX = this.teleportPos.x;
         this.lastPosY = this.teleportPos.y;
@@ -1792,6 +1805,13 @@ public class PlayerConnection implements PacketListenerPlayIn {
                     return;
                 }
             }
+
+            // MultiPaper start - Find player on another server
+            Location location = MultiPaper.getPlayerLocation(packetplayinspectate.getUUID());
+            if (location != null) {
+                this.player.getBukkitEntity().teleportAsync(location, PlayerTeleportEvent.TeleportCause.SPECTATE);
+            }
+            // MultiPaper end
         }
 
     }
@@ -2143,6 +2163,7 @@ public class PlayerConnection implements PacketListenerPlayIn {
                         recipient.sendMessage(PlayerConnection.this.player.getUniqueID(), s);
                     }
                 }
+                MultiPaper.broadcastPacket(PlayerConnection.this.player.getUniqueID(), s); // MultiPaper
             }
         }
     }
@@ -2689,6 +2710,12 @@ public class PlayerConnection implements PacketListenerPlayIn {
                         return;
                     }
 
+                    // MultiPaper start - don't let them click items if they shouldn't be ticked
+                    if (!MultiPaper.isPlayerSafe(player)) {
+                        event.setCancelled(true);
+                    }
+                    // MultiPaper end
+
                     switch (event.getResult()) {
                         case ALLOW:
                         case DEFAULT:
diff --git a/src/main/java/net/minecraft/server/players/JsonList.java b/src/main/java/net/minecraft/server/players/JsonList.java
index c960852dc60d0598012c5eef0d139fe38bde63fb..bb58172148c8eb836ac17681e0219761bd543552 100644
--- a/src/main/java/net/minecraft/server/players/JsonList.java
+++ b/src/main/java/net/minecraft/server/players/JsonList.java
@@ -24,6 +24,7 @@ import net.minecraft.SystemUtils;
 import net.minecraft.util.ChatDeserializer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class JsonList<K, V extends JsonListEntry<K>> {
 
@@ -161,7 +162,7 @@ public abstract class JsonList<K, V extends JsonListEntry<K>> {
         Throwable throwable = null;
 
         try {
-            JsonList.b.toJson(jsonarray, bufferedwriter);
+            MultiPaper.writeJson(this.c.getName(), JsonList.b.toJson(jsonarray)); // JsonList.b.toJson(jsonarray, bufferedwriter); // MultiPaper
         } catch (Throwable throwable1) {
             throwable = throwable1;
             throw throwable1;
@@ -184,11 +185,11 @@ public abstract class JsonList<K, V extends JsonListEntry<K>> {
 
     public void load() throws IOException {
         if (this.c.exists()) {
-            BufferedReader bufferedreader = Files.newReader(this.c, StandardCharsets.UTF_8);
+            BufferedReader bufferedreader = null; // Files.newReader(this.c, StandardCharsets.UTF_8); // MultiPaper
             Throwable throwable = null;
 
             try {
-                JsonArray jsonarray = (JsonArray) JsonList.b.fromJson(bufferedreader, JsonArray.class);
+                JsonArray jsonarray = JsonList.b.fromJson(MultiPaper.readJson(this.c.getName()), JsonArray.class); // (JsonArray) JsonList.b.fromJson(bufferedreader, JsonArray.class); // MultiPaper
                 com.google.common.base.Preconditions.checkState(jsonarray != null, "The file \"" + this.c.getName() + "\" is either empty or corrupt"); // Paper
 
                 this.d.clear();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 2df8e914f66176e22aeddf8b94a83af5ea921d88..d17b1ae8d7683c05d94cf74e9041345fca4427c9 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -122,6 +122,9 @@ import org.bukkit.event.player.PlayerJoinEvent;
 import org.bukkit.event.player.PlayerLoginEvent;
 import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.PlayerInfoManager;
+import puregero.multipaper.Zone;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -337,13 +340,19 @@ public abstract class PlayerList {
         }
         // CraftBukkit start
         chatmessage.a(EnumChatFormat.YELLOW);
+        // MultiPaper start
+        if (entityplayer.isBeingSentToAnotherServer) {
+            entityplayer.isBeingSentToAnotherServer = false;
+            chatmessage = null;
+        }
+        // MultiPaper end
         IChatBaseComponent joinMessage = chatmessage; // Paper - Adventure
 
         playerconnection.a(entityplayer.locX(), entityplayer.locY(), entityplayer.locZ(), entityplayer.yaw, entityplayer.pitch);
         this.players.add(entityplayer);
         this.playersByName.put(entityplayer.getName().toLowerCase(java.util.Locale.ROOT), entityplayer); // Spigot
         this.j.put(entityplayer.getUniqueID(), entityplayer);
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[]{entityplayer})); // CraftBukkit - replaced with loop below
+        this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[]{entityplayer})); // MultiPaper - Keep original sendAll
 
         // Paper start - correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
         entityplayer.supressTrackerForLogin = true;
@@ -369,6 +378,11 @@ public abstract class PlayerList {
         }
         // CraftBukkit end
 
+        MultiPaper.lockPlayer(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.lockAdvancements(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.lockStats(entityplayer.getUniqueIDString()); // MultiPaper
+        PlayerInfoManager.send(entityplayer); // MultiPaper
+
         // CraftBukkit start - sendAll above replaced with this loop
         PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, entityplayer);
 
@@ -376,7 +390,7 @@ public abstract class PlayerList {
             EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
 
             if (entityplayer1.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer1.playerConnection.sendPacket(packet);
+                // entityplayer1.playerConnection.sendPacket(packet); // MultiPaper - Keep original sendAll
             }
 
             if (!entityplayer.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
@@ -594,9 +608,12 @@ public abstract class PlayerList {
         }
 
         PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(cserver.getPlayer(entityplayer), net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, com.destroystokyo.paper.PaperConfig.useDisplayNameInQuit ? entityplayer.getBukkitEntity().displayName() : net.kyori.adventure.text.Component.text(entityplayer.getName())), entityplayer.quitReason); // Paper - quit reason
+        if (entityplayer.isBeingSentToAnotherServer) playerQuitEvent.setQuitMessage(null); // MultiPaper - No quit message if they're going to another server
         if (entityplayer.didPlayerJoinEvent) cserver.getPluginManager().callEvent(playerQuitEvent); // Paper - if we disconnected before join ever fired, don't fire quit
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
+        Zone.onPlayerDisconnect(entityplayer.getBukkitEntity()); // MultiPaper
+
         if (server.isMainThread()) entityplayer.playerTick(); // SPIGOT-924 // Paper - don't tick during emergency shutdowns (Watchdog)
         // CraftBukkit end
 
@@ -619,6 +636,9 @@ public abstract class PlayerList {
         // Paper end
 
         this.savePlayerFile(entityplayer);
+        MultiPaper.releasePlayer(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.releaseAdvancements(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.releaseStats(entityplayer.getUniqueIDString()); // MultiPaper
         if (entityplayer.isPassenger()) {
             Entity entity = entityplayer.getRootVehicle();
 
@@ -673,13 +693,13 @@ public abstract class PlayerList {
         // Paper end
 
         // CraftBukkit start
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[]{entityplayer}));
+        this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[]{entityplayer})); // MultiPaper - Keep original sendAll
         PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, entityplayer);
         for (int i = 0; i < players.size(); i++) {
             EntityPlayer entityplayer2 = (EntityPlayer) this.players.get(i);
 
             if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer2.playerConnection.sendPacket(packet);
+                // entityplayer2.playerConnection.sendPacket(packet);
             } else {
                 entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
             }
@@ -1037,6 +1057,17 @@ public abstract class PlayerList {
     }
 
     public void sendAll(Packet<?> packet) {
+        // MultiPaper start - Intercept PacketPlayOutPlayerInfo packet
+        if (packet instanceof PacketPlayOutPlayerInfo) {
+            MultiPaper.broadcastPacket(packet);
+        }
+
+        sendAllNoIntercept(packet);
+    }
+
+    public void sendAllNoIntercept(Packet<?> packet) {
+        // MultiPaper end
+
         for (int i = 0; i < this.players.size(); ++i) {
             ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
         }
@@ -1406,6 +1437,7 @@ public abstract class PlayerList {
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent, ChatMessageType chatmessagetype, UUID uuid) {
         this.server.sendMessage(ichatbasecomponent, uuid);
+        MultiPaper.broadcastPacket(new PacketPlayOutChat(CraftChatMessage.fixComponent(ichatbasecomponent), chatmessagetype, uuid)); // MultiPaper
         // CraftBukkit start - we run this through our processor first so we can get web links etc
         this.sendAll(new PacketPlayOutChat(CraftChatMessage.fixComponent(ichatbasecomponent), chatmessagetype, uuid));
         // CraftBukkit end
diff --git a/src/main/java/net/minecraft/stats/ServerStatisticManager.java b/src/main/java/net/minecraft/stats/ServerStatisticManager.java
index de87ed44e09b61f6d2e6a93d770a7c37b9f95fa1..54c23864ac6c92b64db861ad97de7de237d0680c 100644
--- a/src/main/java/net/minecraft/stats/ServerStatisticManager.java
+++ b/src/main/java/net/minecraft/stats/ServerStatisticManager.java
@@ -34,6 +34,7 @@ import net.minecraft.world.entity.player.EntityHuman;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class ServerStatisticManager extends StatisticManager {
 
@@ -53,6 +54,21 @@ public class ServerStatisticManager extends StatisticManager {
             this.a.put( wrapper, entry.getValue().intValue() );
         }
         // Spigot end
+        // MultiPaper start
+        if (true) {
+            try {
+                String json = MultiPaper.readStats(this.d.getName().split("\\.")[0]);
+                if (!json.isEmpty()) {
+                    this.a(minecraftserver.getDataFixer(), json);
+                }
+            } catch (IOException ioexception) {
+                ServerStatisticManager.LOGGER.error("Couldn't read statistics file {}", file, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                ServerStatisticManager.LOGGER.error("Couldn't parse statistics file {}", file, jsonparseexception);
+            }
+            return;
+        }
+        // MultiPaper end
         if (file.isFile()) {
             try {
                 this.a(minecraftserver.getDataFixer(), FileUtils.readFileToString(file));
@@ -68,6 +84,12 @@ public class ServerStatisticManager extends StatisticManager {
     public void save() {
         if ( org.spigotmc.SpigotConfig.disableStatSaving ) return; // Spigot
         try {
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeStats(this.d.getName().split("\\.")[0], this.b());
+                return;
+            }
+            // MultiPaper end
             FileUtils.writeStringToFile(this.d, this.b());
         } catch (IOException ioexception) {
             ServerStatisticManager.LOGGER.error("Couldn't save stats", ioexception);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 429f0591c6a55f6c5d08a0755f7d39da676468bc..ba3d0db8b0e2eaac455a913b69104562d59b1e59 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -2684,11 +2684,6 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
                 // CraftBukkit end
 
                 this.world.getMethodProfiler().exitEnter("reloading");
-                // Paper start - Change lead drop timing to prevent dupe
-                if (this instanceof EntityInsentient) {
-                    ((EntityInsentient) this).unleash(true, true); // Paper drop lead
-                }
-                // Paper end
                 Entity entity = this.getEntityType().a((World) worldserver);
 
                 if (entity != null) {
@@ -2702,6 +2697,10 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, ne
                     // CraftBukkit start - Forward the CraftEntity to the new entity
                     this.getBukkitEntity().setHandle(entity);
                     entity.bukkitEntity = this.getBukkitEntity();
+
+                    if (this instanceof EntityInsentient) {
+                        ((EntityInsentient) this).unleash(true, true); // Paper drop lead
+                    }
                     // CraftBukkit end
                 }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java
index ce165233739c7b92a76031b949f269bd0a11149c..2660df000cb4007b085b1d15327606382f53005e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/VillagePlace.java
@@ -6,6 +6,8 @@ import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
+import puregero.multipaper.MultiPaper;
+
 import java.io.File;
 import java.util.Collections;
 import java.util.Comparator;
@@ -297,7 +299,10 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
             }
             return ret;
         }
-        return super.read(chunkcoordintpair);
+        // MultiPaper start
+        return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair);
+        // return super.read(chunkcoordintpair);
+        // MultiPaper end
     }
 
     @Override
@@ -308,7 +313,10 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
-        super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper start
+        MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound);
+        //super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper end
     }
     // Paper end
 
diff --git a/src/main/java/net/minecraft/world/entity/player/EntityHuman.java b/src/main/java/net/minecraft/world/entity/player/EntityHuman.java
index ec0956a98c133bcd3d4f92f696c667eab6ff98f1..914886836cb9ed29dfe844167db4c9267e2c5c34 100644
--- a/src/main/java/net/minecraft/world/entity/player/EntityHuman.java
+++ b/src/main/java/net/minecraft/world/entity/player/EntityHuman.java
@@ -124,8 +124,13 @@ import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityExhaustionEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import org.bukkit.util.Vector;
 // CraftBukkit end
 
+// MultiPaper start
+import puregero.multipaper.MultiPaper;
+// MultiPaper end
+
 public abstract class EntityHuman extends EntityLiving {
 
     public static final EntitySize bh = EntitySize.b(0.6F, 1.8F);
@@ -683,7 +688,7 @@ public abstract class EntityHuman extends EntityLiving {
             PlayerDropItemEvent event = new PlayerDropItemEvent(player, drop);
             this.world.getServer().getPluginManager().callEvent(event);
 
-            if (event.isCancelled()) {
+            if (event.isCancelled() || !MultiPaper.isPlayerSafe(this)) { // MultiPaper don't drop items if they shouldn't be ticked
                 org.bukkit.inventory.ItemStack cur = player.getInventory().getItemInHand();
                 if (flag1 && (cur == null || cur.getAmount() == 0)) {
                     // The complete stack was dropped
diff --git a/src/main/java/net/minecraft/world/level/World.java b/src/main/java/net/minecraft/world/level/World.java
index 78dcba08d6d796d5d97c8304bf1f1e7d1e650d5d..934d6544a24dcd17120fd5f1d136efbc12baceb1 100644
--- a/src/main/java/net/minecraft/world/level/World.java
+++ b/src/main/java/net/minecraft/world/level/World.java
@@ -91,6 +91,7 @@ import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -250,7 +251,7 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         });
         // CraftBukkit end
         timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
-        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.keepSpawnInMemory = false; // this.paperConfig.keepSpawnInMemory; // Paper // MultiPaper - default to false
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
     }
@@ -854,6 +855,8 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
             if (!tileentity.isRemoved() && tileentity.hasWorld()) {
                 BlockPosition blockposition = tileentity.getPosition();
 
+                if (!MultiPaper.shouldTickChunk((WorldServer) this, getChunkIfLoaded(blockposition))) continue; // MultiPaper - Don't tick this tile entity rn
+
                 Chunk chunk; PlayerChunk playerChunk; if ((chunk = tileentity.getCurrentChunk()) != null && (playerChunk = chunk.playerChunk) != null && playerChunk.isTickingReady() && this.getWorldBorder().isInBounds(blockposition)) { // Paper - optimized tick ready check by inlining ChunkProviderServer.a(BlockPosition). Chunk lookup is no longer required and we can use the PlayerChunk directly available through the tile entity
                     try {
                         gameprofilerfiller.a(() -> {
diff --git a/src/main/java/net/minecraft/world/level/chunk/Chunk.java b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
index 34a9f7b2f998f77b1279516cd09397ab6c2ac1cc..d5eb3d7847ddd6c11e13b7976a543a13c65d4ebe 100644
--- a/src/main/java/net/minecraft/world/level/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/Chunk.java
@@ -68,6 +68,7 @@ import net.minecraft.world.level.material.FluidTypes;
 import net.minecraft.world.phys.AxisAlignedBB;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class Chunk implements IChunkAccess {
 
@@ -856,6 +857,7 @@ public class Chunk implements IChunkAccess {
         this.setNeighbourLoaded(0, 0, this);
         this.loadedTicketLevel = true;
         // Paper end - neighbour cache
+        MultiPaper.lockChunk(this.loc, this.world); // MultiPaper
         org.bukkit.Server server = this.world.getServer();
         ((WorldServer)this.world).getChunkProvider().addLoadedChunk(this); // Paper
         if (server != null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 4999ba61fb04713ffe3d23c556f732dc4abbf0bc..953d35c758162008e42c8be7bfc9e1050658ea61 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -88,6 +88,9 @@ public class RegionFile implements AutoCloseable {
             ((java.nio.Buffer) this.h).limit(1024);
             ((java.nio.Buffer) this.g).position(4096);
             this.i = this.g.asIntBuffer();
+            // MultiPaper start
+            this.dataFile = null;
+            /*
             if (flag) {
                 this.dataFile = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC);
             } else {
@@ -135,6 +138,8 @@ public class RegionFile implements AutoCloseable {
                     }
                 }
             }
+            */
+            // MultiPaper end
 
         }
     }
@@ -403,6 +408,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     public boolean chunkExists(ChunkCoordIntPair chunkcoordintpair) {
+        if (true) return true;
         return this.getOffset(chunkcoordintpair) != 0;
     }
 
@@ -412,6 +418,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.dataFile == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/saveddata/PersistentBase.java b/src/main/java/net/minecraft/world/level/saveddata/PersistentBase.java
index f02840e04fa1644901292b3ec67720cb64c2931d..e4d8ca21e6eb5d6aee4f1e210b722f59510d7b47 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/PersistentBase.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/PersistentBase.java
@@ -7,6 +7,7 @@ import net.minecraft.nbt.NBTCompressedStreamTools;
 import net.minecraft.nbt.NBTTagCompound;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class PersistentBase {
 
@@ -46,7 +47,8 @@ public abstract class PersistentBase {
             nbttagcompound.setInt("DataVersion", SharedConstants.getGameVersion().getWorldVersion());
 
             try {
-                NBTCompressedStreamTools.a(nbttagcompound, file);
+                MultiPaper.writeData(file.getPath(), nbttagcompound); // MultiPaper
+                // NBTCompressedStreamTools.a(nbttagcompound, file); // MultiPaper
             } catch (IOException ioexception) {
                 PersistentBase.LOGGER.error("Could not save data {}", this, ioexception);
             }
diff --git a/src/main/java/net/minecraft/world/level/storage/Convertable.java b/src/main/java/net/minecraft/world/level/storage/Convertable.java
index 7475a833425d8edc488f8d7b8c68f71592783d33..2347a3307f70c9b837994cd7c70ee46978deb46a 100644
--- a/src/main/java/net/minecraft/world/level/storage/Convertable.java
+++ b/src/main/java/net/minecraft/world/level/storage/Convertable.java
@@ -46,6 +46,7 @@ import net.minecraft.world.level.levelgen.GeneratorSettingBase;
 import net.minecraft.world.level.levelgen.GeneratorSettings;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 // CraftBukkit start
 import net.minecraft.world.level.dimension.WorldDimension;
@@ -141,7 +142,7 @@ public class Convertable {
         } else {
             File file1 = new File(file, "level.dat");
 
-            if (file1.exists()) {
+            if (true || file1.exists()) { // MultiPaper
                 T t0 = bifunction.apply(file1, this.f);
 
                 if (t0 != null) {
@@ -157,7 +158,7 @@ public class Convertable {
     @Nullable
     private static DataPackConfiguration b(File file, DataFixer datafixer) {
         try {
-            NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(file);
+            NBTTagCompound nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NBTCompressedStreamTools.a(file); // MultiPaper
             NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Data");
 
             nbttagcompound1.remove("Player");
@@ -174,7 +175,7 @@ public class Convertable {
     private static BiFunction<File, DataFixer, WorldDataServer> b(DynamicOps<NBTBase> dynamicops, DataPackConfiguration datapackconfiguration) {
         return (file, datafixer) -> {
             try {
-                NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(file);
+                NBTTagCompound nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NBTCompressedStreamTools.a(file); // MultiPaper
                 NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Data");
                 NBTTagCompound nbttagcompound2 = nbttagcompound1.hasKeyOfType("Player", 10) ? nbttagcompound1.getCompound("Player") : null;
 
@@ -196,7 +197,7 @@ public class Convertable {
     private BiFunction<File, DataFixer, WorldInfo> a(File file, boolean flag) {
         return (file1, datafixer) -> {
             try {
-                NBTTagCompound nbttagcompound = NBTCompressedStreamTools.a(file1);
+                NBTTagCompound nbttagcompound = MultiPaper.readLevel(file.getName()); // NBTCompressedStreamTools.a(file1); // MultiPaper
                 NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Data");
 
                 nbttagcompound1.remove("Player");
@@ -327,6 +328,13 @@ public class Convertable {
             nbttagcompound2.set("Data", nbttagcompound1);
 
             try {
+                // MultiPaper start
+                if (true) {
+                    MultiPaper.writeLevel(file.getName(), nbttagcompound2);
+                    return;
+                }
+                // MultiPaper end
+
                 File file1 = File.createTempFile("level", ".dat", file);
 
                 NBTCompressedStreamTools.a(nbttagcompound2, file1);
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldNBTStorage.java b/src/main/java/net/minecraft/world/level/storage/WorldNBTStorage.java
index 4d30ca69dd303f1d76c8e6292021deda97851773..b5a6be103da15d13add1701e243dd885500db1ae 100644
--- a/src/main/java/net/minecraft/world/level/storage/WorldNBTStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/WorldNBTStorage.java
@@ -17,6 +17,7 @@ import java.io.FileInputStream;
 import java.io.InputStream;
 import net.minecraft.server.level.EntityPlayer;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class WorldNBTStorage {
@@ -35,6 +36,14 @@ public class WorldNBTStorage {
         if (org.spigotmc.SpigotConfig.disablePlayerDataSaving) return; // Spigot
         try {
             NBTTagCompound nbttagcompound = entityhuman.save(new NBTTagCompound());
+
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writePlayer(entityhuman.getUniqueIDString(), nbttagcompound);
+                return;
+            }
+            // MultiPaper end
+
             File file = File.createTempFile(entityhuman.getUniqueIDString() + "-", ".dat", this.playerDir);
 
             NBTCompressedStreamTools.a(nbttagcompound, file);
@@ -53,6 +62,9 @@ public class WorldNBTStorage {
         NBTTagCompound nbttagcompound = null;
 
         try {
+            nbttagcompound = MultiPaper.readPlayer(entityhuman.getUniqueIDString()); // MultiPaper
+
+            if (false) { // MultiPaper
             File file = new File(this.playerDir, entityhuman.getUniqueIDString() + ".dat");
             // Spigot Start
             boolean usingWrongFile = false;
@@ -76,12 +88,14 @@ public class WorldNBTStorage {
                 file.renameTo( new File( file.getPath() + ".offline-read" ) );
             }
             // Spigot End
+            } // MultiPaper
         } catch (Exception exception) {
             WorldNBTStorage.LOGGER.warn("Failed to load player data for {}", entityhuman.getDisplayName().getString());
         }
 
         if (nbttagcompound != null) {
             // CraftBukkit start
+            /* // MultiPlayer
             if (entityhuman instanceof EntityPlayer) {
                 CraftPlayer player = (CraftPlayer) entityhuman.getBukkitEntity();
                 // Only update first played if it is older than the one we have
@@ -91,6 +105,7 @@ public class WorldNBTStorage {
                 }
             }
             // CraftBukkit end
+            */ // MultiPlayer
             int i = nbttagcompound.hasKeyOfType("DataVersion", 3) ? nbttagcompound.getInt("DataVersion") : -1;
 
             entityhuman.load(GameProfileSerializer.a(this.a, DataFixTypes.PLAYER, nbttagcompound, i));
@@ -102,6 +117,8 @@ public class WorldNBTStorage {
     // CraftBukkit start
     public NBTTagCompound getPlayerData(String s) {
         try {
+            if (true) return MultiPaper.readPlayer(s); // MultiPaper
+
             File file1 = new File(this.playerDir, s + ".dat");
 
             if (file1.exists()) {
diff --git a/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java b/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java
index d61960d80599dc5e7b70cc990e4b0b174eb6e34e..a7227f9203dd1e6b36e24c1fee814a212debc4be 100644
--- a/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java
+++ b/src/main/java/net/minecraft/world/level/storage/WorldPersistentData.java
@@ -2,13 +2,8 @@ package net.minecraft.world.level.storage;
 
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.DataFixer;
-import java.io.DataInput;
-import java.io.DataInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PushbackInputStream;
+
+import java.io.*;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Supplier;
@@ -21,6 +16,7 @@ import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.saveddata.PersistentBase;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class WorldPersistentData {
 
@@ -68,10 +64,12 @@ public class WorldPersistentData {
         try {
             File file = this.a(s);
 
-            if (file.exists()) {
+            if (true || file.exists()) { // MultiPaper - Always run
                 T t0 = supplier.get(); // Paper - decompile fix
                 NBTTagCompound nbttagcompound = this.a(s, SharedConstants.getGameVersion().getWorldVersion());
 
+                if (nbttagcompound == null) return null; // MultiPaper
+
                 t0.a(nbttagcompound.getCompound("data"));
                 return t0;
             }
@@ -88,7 +86,14 @@ public class WorldPersistentData {
 
     public NBTTagCompound a(String s, int i) throws IOException {
         File file = this.a(s);
-        FileInputStream fileinputstream = new FileInputStream(file);
+        // MultiPaper start
+        byte[] data = MultiPaper.readData(file.getPath());
+        if (data == null || data.length == 0) {
+            return null;
+        }
+        // FileInputStream fileinputstream = new FileInputStream(file);
+        ByteArrayInputStream fileinputstream = new ByteArrayInputStream(data);
+        // MultiPaper end
         Throwable throwable = null;
 
         Object object;
@@ -202,4 +207,10 @@ public class WorldPersistentData {
         }
 
     }
+
+    // MultiPaper start - save a PersistentBase
+    public void save(PersistentBase persistentbase) {
+        persistentbase.a(this.a(persistentbase.getId()));
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 03b8d67a5f0088c0254b2099f27e8dcae32a6221..7cd584605bfd5a8756f33797eaacc18e2b519ba8 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -227,6 +227,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import puregero.multipaper.MultiPaper;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -1560,6 +1561,12 @@ public final class CraftServer implements Server {
 
         message = broadcastMessageEvent.message(); // Paper - Adventure
 
+        // MultiPaper start
+        if (permission.equals(BROADCAST_CHANNEL_USERS)) {
+            MultiPaper.broadcastPacket(null, message);
+        }
+        // MultiPaper end
+
         for (CommandSender recipient : recipients) {
             recipient.sendMessage(message);
         }
@@ -2351,6 +2358,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent component) {
+            MultiPaper.broadcastPacket(null, component); // MultiPaper
+
             for (Player player : getOnlinePlayers()) {
                 player.spigot().sendMessage(component);
             }
@@ -2358,6 +2367,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent... components) {
+            MultiPaper.broadcastPacket(null, components); // MultiPaper
+
             for (Player player : getOnlinePlayers()) {
                 player.spigot().sendMessage(components);
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 16567619d7ca84a997ef46417d72f92e6db6993d..23d3450e04c106ab4743de6383d7698d8141b53b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -505,6 +505,7 @@ public class CraftWorld implements World {
         org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
         if (isChunkLoaded(x, z)) {
             world.getChunkProvider().removeTicket(TicketType.PLUGIN, new ChunkCoordIntPair(x, z), 0, Unit.INSTANCE); // Paper
+            world.getChunkProvider().removeTicket(TicketType.PLAYER, new ChunkCoordIntPair(x, z), 0, new ChunkCoordIntPair(x, z)); // MultiPaper
         }
 
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
index 2fd69c0f915f1c3cb1c410d5dab0498f05d5c888..9b803b658153d31b1b8f8a3e74570c77a6c262b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
@@ -4,13 +4,28 @@ import java.util.Map;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.SimpleCommandMap;
+import puregero.multipaper.ServersCommand;
 
 public class CraftCommandMap extends SimpleCommandMap {
 
     public CraftCommandMap(Server server) {
         super(server);
+        setDefaultCommands(); // MultiPaper
     }
 
+    // MultiPaper start
+    @Override
+    public void clearCommands() {
+        super.clearCommands();
+
+        setDefaultCommands();
+    }
+
+    private void setDefaultCommands() {
+        register("multipaper", new ServersCommand("servers"));
+    }
+    // MultiPaper end
+
     public Map<String, Command> getKnownCommands() {
         return knownCommands;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e5549439b3d4d608cf37dd33b6c8c9e10dfe9328..cc78554f3ba05bc7b5072d9f86c21d9ea6fb9f98 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -426,11 +426,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             name = getName();
         }
         getHandle().listName = name.equals(getName()) ? null : CraftChatMessage.fromStringOrNull(name);
-        for (EntityPlayer player : (List<EntityPlayer>) server.getHandle().players) {
-            if (player.getBukkitEntity().canSee(this)) {
-                player.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, getHandle()));
-            }
-        }
+        // MultiPaper start - Use sendAll
+        getHandle().getMinecraftServer().getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, getHandle()));
+        // for (EntityPlayer player : (List<EntityPlayer>) server.getHandle().players) {
+        //    if (player.getBukkitEntity().canSee(this)) {
+        //        player.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, getHandle()));
+        //    }
+        // }
+        // MultiPaper end
     }
 
     private net.kyori.adventure.text.Component playerListHeader; // Paper - Adventure
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index 926440e846eff2c1aaa262aa2b3975b7dd225332..adbae37fdd55780cdeaf34e6d2dbb3cf3decea54 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -224,6 +224,7 @@ import org.bukkit.inventory.meta.BookMeta;
 import org.bukkit.potion.PotionEffect;
 
 import org.bukkit.event.entity.SpawnerSpawnEvent; // Spigot
+import puregero.multipaper.MultiPaper;
 
 public class CraftEventFactory {
     public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.BURN);
@@ -530,6 +531,12 @@ public class CraftEventFactory {
         }
         craftServer.getPluginManager().callEvent(event);
 
+        // MultiPaper start - don't interact if they shouldn't be ticked
+        if (!MultiPaper.isPlayerSafe(who)) {
+            event.setCancelled(true);
+        }
+        // MultiPaper end
+
         return event;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
index f101ed6c5a5e16e5804b36f1182edca874981831..ad648caa334afb1424705f2630a2b7debcaafdef 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
@@ -1,14 +1,10 @@
 package org.bukkit.craftbukkit.util;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
+import java.io.*;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public final class WorldUUID {
 
@@ -18,6 +14,38 @@ public final class WorldUUID {
     }
 
     public static UUID getUUID(File baseDir) {
+    // MultiPaper start
+        DataInputStream dis = null;
+        try {
+            dis = MultiPaper.readUid(baseDir.getName());
+            return new UUID(dis.readLong(), dis.readLong());
+        } catch (IOException ex) {
+            LOGGER.warn("Failed to read " + baseDir.getName() + "'s uid.dat, generating new random UUID", ex);
+        } finally {
+            if (dis != null) {
+                try {
+                    dis.close();
+                } catch (IOException ex) {
+                    // NOOP
+                }
+            }
+        }
+
+        UUID uuid = UUID.randomUUID();
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DataOutputStream dos = new DataOutputStream(baos);
+            dos.writeLong(uuid.getMostSignificantBits());
+            dos.writeLong(uuid.getLeastSignificantBits());
+            MultiPaper.writeUid(baseDir.getName(), baos.toByteArray());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return uuid;
+    }
+
+    public static UUID _getUUID(File baseDir) {
+    // MultiPaper end
         File file1 = new File(baseDir, "uid.dat");
         if (file1.exists()) {
             DataInputStream dis = null;
diff --git a/src/main/java/puregero/multipaper/BungeeCord.java b/src/main/java/puregero/multipaper/BungeeCord.java
new file mode 100644
index 0000000000000000000000000000000000000000..4cfbad5085f4ce84ac840e4bc775a73ec604c2a7
--- /dev/null
+++ b/src/main/java/puregero/multipaper/BungeeCord.java
@@ -0,0 +1,25 @@
+package puregero.multipaper;
+
+import com.google.common.io.ByteArrayDataOutput;
+import com.google.common.io.ByteStreams;
+import io.netty.buffer.Unpooled;
+import net.minecraft.server.MinecraftKey;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketPlayOutCustomPayload;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+public class BungeeCord {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static void connectPlayer(Player p, String server) {
+        LOGGER.info("Sending " + p.getName() + " to server: " + server);
+        ByteArrayDataOutput out = ByteStreams.newDataOutput();
+        out.writeUTF("Connect");
+        out.writeUTF(server);
+        PacketPlayOutCustomPayload packet = new PacketPlayOutCustomPayload(new MinecraftKey("bungeecord:main"), new PacketDataSerializer(Unpooled.wrappedBuffer(out.toByteArray())));
+        ((CraftPlayer) p).getHandle().playerConnection.sendPacket(packet);
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..a905eca60fccc47d9f6c9746e760d4322ca66766
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,33 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+    
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+        
+        return super.equals(other);
+    }
+    
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+        
+        return name.hashCode() ^ i ^ j;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/DataOutputSender.java b/src/main/java/puregero/multipaper/DataOutputSender.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b042efc6942050dc290001eafc0f97f0917ce82
--- /dev/null
+++ b/src/main/java/puregero/multipaper/DataOutputSender.java
@@ -0,0 +1,30 @@
+package puregero.multipaper;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.util.function.Consumer;
+
+public class DataOutputSender extends DataOutputStream {
+    private final MultiPaperConnection connection;
+    private final int id;
+
+    public DataOutputSender(MultiPaperConnection connection) throws IOException {
+        this(connection, (int) (Math.random() * Integer.MAX_VALUE));
+    }
+
+    public DataOutputSender(MultiPaperConnection connection, int id) throws IOException {
+        super(new ByteArrayOutputStream());
+        this.connection = connection;
+        this.id = id;
+
+        writeInt(id);
+    }
+
+    public void send(@Nullable Consumer<DataInputStream> callback) throws IOException {
+        connection.send(((ByteArrayOutputStream) out).toByteArray(), id, callback);
+    }
+
+    public int getId() {
+        return id;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ExternalServer.java b/src/main/java/puregero/multipaper/ExternalServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8943de3e4ee0d3e3d3c91864ebbc4fe58056daa9
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalServer.java
@@ -0,0 +1,58 @@
+package puregero.multipaper;
+
+import java.util.ArrayList;
+import java.util.UUID;
+
+public class ExternalServer {
+    private final String name;
+    private final boolean me;
+    private int averageTickTime;
+    private double tps;
+    private long lastAlive;
+    private ArrayList<UUID> players = new ArrayList<>();
+
+    public ExternalServer(String name, boolean me) {
+        this.name = name;
+        this.me = me;
+    }
+
+    public int getAverageTickTime() {
+        return averageTickTime;
+    }
+
+    public void setAverageTickTime(int averageTickTime) {
+        this.averageTickTime = averageTickTime;
+    }
+
+    public long getLastAlive() {
+        return lastAlive;
+    }
+
+    public void setLastAlive(long lastAlive) {
+        this.lastAlive = lastAlive;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public boolean isMe() {
+        return me;
+    }
+
+    public boolean isAlive() {
+        return getLastAlive() > System.currentTimeMillis() - 2500;
+    }
+
+    public ArrayList<UUID> getPlayers() {
+        return players;
+    }
+
+    public double getTps() {
+        return tps;
+    }
+
+    public void setTps(double tps) {
+        this.tps = tps;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..488cf1a8e75636ac0caf3f993b2b32dd7e688cac
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -0,0 +1,367 @@
+package puregero.multipaper;
+
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.minecraft.server.*;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Player;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.util.HashSet;
+import java.util.UUID;
+
+public class MultiPaper {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static MultiPaperConnection multiPaperConnection = null;
+    private static long last10Seconds = System.currentTimeMillis();
+    private static HashSet<ChunkKey> lockedChunks = new HashSet<>();
+
+    private static MultiPaperConnection getConnection() {
+        if (multiPaperConnection == null) {
+            multiPaperConnection = new MultiPaperConnection();
+        }
+
+        return multiPaperConnection;
+    }
+
+    private static void tick() {
+        boolean hasBeen10Seconds = last10Seconds < System.currentTimeMillis() - 10 * 1000;
+
+        if (hasBeen10Seconds) last10Seconds = System.currentTimeMillis();
+
+        Bukkit.getWorlds().forEach(world -> {
+            WorldPersistentData persistentData = ((CraftWorld) world).getHandle().getWorldPersistentData();
+            persistentData.data.values().forEach(value -> {
+                if (value != null && (value instanceof PersistentIdCounts || (value instanceof WorldMap && hasBeen10Seconds))) {
+                    persistentData.save(value);
+                }
+            });
+        });
+    }
+
+    public static NBTTagCompound readChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) throws IOException {
+        return readRegionFileNBT(worldServer, "region", chunkcoordintpair);
+    }
+
+    public static void writeChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer, NBTTagCompound nbttagcompound) throws IOException {
+        writeRegionFileNBT(worldServer, "region", chunkcoordintpair, nbttagcompound);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        return getConnection().readChunk(world, path, cx, cz).join();
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+
+    public static NBTTagCompound readRegionFileNBT(WorldServer worldServer, String path, ChunkCoordIntPair chunkcoordintpair) throws IOException {
+        DataInput in = readRegionFile(worldServer.worldDataServer.getName(), path, chunkcoordintpair.x, chunkcoordintpair.z);
+
+        return in == null ? null : NBTCompressedStreamTools.a(in);
+    }
+
+    public static void writeRegionFileNBT(WorldServer worldServer, String path, ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
+        writeRegionFile(worldServer.worldDataServer.getName(), path, chunkcoordintpair.x, chunkcoordintpair.z, nbtToBytes(nbttagcompound));
+    }
+
+    public static NBTTagCompound readLevel(String world) throws IOException {
+        DataInput in = getConnection().readLevel(world).join();
+
+        return in == null ? null : NBTCompressedStreamTools.a((InputStream) in);
+    }
+
+    public static void writeLevel(String world, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writeLevel(world, nbtCompressToBytes(nbttagcompound));
+    }
+
+    public static String readJson(String name) throws IOException {
+        return getConnection().readJson(name).join();
+    }
+
+    public static void writeJson(String name, String json) throws IOException {
+        getConnection().writeJson(name, json);
+    }
+
+    public static NBTTagCompound readPlayer(String uuid) throws IOException {
+        DataInput in = getConnection().readPlayer(uuid).join();
+
+        return in == null ? null : NBTCompressedStreamTools.a((InputStream) in);
+    }
+
+    public static void writePlayer(String uuid, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writePlayer(uuid, nbtCompressToBytes(nbttagcompound));
+    }
+
+    public static void lockPlayer(String uuid) {
+        try {
+            getConnection().lockPlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releasePlayer(String uuid) {
+        try {
+            getConnection().releasePlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static DataInputStream readUid(String world) throws IOException {
+        return getConnection().readUid(world).join();
+    }
+
+    public static void writeUid(String world, byte[] data) throws IOException {
+        getConnection().writeUid(world, data);
+    }
+
+    public static void lockChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
+        try {
+            if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z)) {
+                return;
+            }
+
+            getConnection().lockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z).thenAccept(holder -> {
+                if (!Zone.shouldLockChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z)) {
+                    releaseChunk(chunkcoordintpair, worldServer);
+                    return;
+                }
+
+                lockedChunks.add(new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z));
+
+                new Thread(() -> {
+                    if (holder != null) {
+                        Zone.doMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z), holder);
+                    } else {
+                        Zone.checkIfShouldMerge(worldServer.getWorld().getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z));
+                    }
+                }).start();
+            });
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+    
+    public static void releaseChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
+        try {
+            lockedChunks.remove(new ChunkKey(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z));
+            getConnection().releaseChunk(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void notifyChunkNotSaving(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
+        try {
+            getConnection().notifyChunkNotSaving(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void sendTickTime(long time) {
+        tick();
+        try {
+            getConnection().writeTickTime(time);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readAdvancements(String uuid) throws IOException {
+        return getConnection().readAdvancements(uuid).join();
+    }
+
+    public static void writeAdvancements(String uuid, String json) throws IOException {
+        getConnection().writeAdvancements(uuid, json);
+    }
+
+    public static void lockAdvancements(String uuid) {
+        try {
+            getConnection().lockAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseAdvancements(String uuid) {
+        try {
+            getConnection().releaseAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readStats(String uuid) throws IOException {
+        return getConnection().readStats(uuid).join();
+    }
+
+    public static void writeStats(String uuid, String json) throws IOException {
+        getConnection().writeStats(uuid, json);
+    }
+
+    public static void lockStats(String uuid) {
+        try {
+            getConnection().lockStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseStats(String uuid) {
+        try {
+            getConnection().releaseStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(Packet<?> packet) {
+        try {
+            getConnection().broadcastPacket(packet);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(UUID from, String message) {
+        if (from == null) {
+            from = SystemUtils.getNullUUID();
+        }
+
+        for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
+            broadcastPacket(new PacketPlayOutChat(component, from.equals(SystemUtils.getNullUUID()) ? ChatMessageType.SYSTEM : ChatMessageType.CHAT, from));
+        }
+    }
+
+    public static void broadcastPacket(UUID from, BaseComponent... components) {
+        if (from == null) {
+            from = SystemUtils.getNullUUID();
+        }
+
+        PacketPlayOutChat packet = new PacketPlayOutChat(null, from.equals(SystemUtils.getNullUUID()) ? ChatMessageType.SYSTEM : ChatMessageType.CHAT, SystemUtils.b);
+        packet.components = components;
+        broadcastPacket(packet);
+    }
+
+    public static void onStart() {
+        try {
+            getConnection().sendStart();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static byte[] readData(String path) {
+        try {
+            return getConnection().readData(path).join();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public static void writeData(String path, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writeData(path, nbtCompressToBytes(nbttagcompound));
+    }
+
+    private static byte[] nbtToBytes(NBTTagCompound nbttagcompound) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    private static byte[] nbtCompressToBytes(NBTTagCompound nbttagcompound) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NBTCompressedStreamTools.a(nbttagcompound, buffer);
+        return buffer.toByteArray();
+    }
+
+    public static String getBungeeCordName() throws IOException {
+        File file = new File("bungeecordname.txt");
+        if (!file.isFile()) {
+            Files.write(file.toPath(), ("server" + Double.toString(Math.random()).substring(2, 7)).getBytes());
+        }
+        return new String(Files.readAllBytes(file.toPath())).trim();
+    }
+
+    public static ExternalServer getMe() {
+        return multiPaperConnection.getServersMap().get(multiPaperConnection.getBungeeCordName());
+    }
+
+    public static Iterable<ExternalServer> getServers() {
+        return multiPaperConnection.getServersMap().values();
+    }
+
+    public static Location getPlayerLocation(UUID uuid) {
+        return multiPaperConnection.playerLocations.get(uuid);
+    }
+
+    private static int chunkDistance(Entity entity1, Entity entity2) {
+        return Math.max(Math.abs(entity1.chunkX - entity2.chunkX), Math.abs(entity1.chunkZ - entity2.chunkZ));
+    }
+
+    private static int chunkDistance(Entity entity, Chunk chunk) {
+        return Math.max(Math.abs(entity.chunkX - chunk.getPos().x), Math.abs(entity.chunkZ - chunk.getPos().z));
+    }
+    
+    public static boolean isPlayerSafe(EntityHuman player) {
+        if (!(player instanceof EntityPlayer)) {
+            return true;
+        }
+        
+        return !Zone.isBeingSentToAnotherServer(((EntityPlayer) player).getBukkitEntity()) && isChunkLocked((WorldServer) player.world, player.chunkX, player.chunkZ);
+    }
+
+    public static boolean isChunkLocked(WorldServer world, int chunkX, int chunkZ) {
+        boolean isLocked = lockedChunks.contains(new ChunkKey(world.worldDataServer.getName(), chunkX, chunkZ));
+        
+        if (isLocked) {
+            return true;
+        }
+        
+        if (world.isChunkLoaded(chunkX, chunkZ)) {
+            // The chunk is loaded, so why isn't it locked?
+            lockChunk(new ChunkCoordIntPair(chunkX, chunkZ), world);
+        }
+        
+        return false;
+    }
+
+    public static boolean shouldTickEntity(WorldServer worldServer, Entity entity) {
+        for (EntityPlayer player : worldServer.players) {
+            if (isPlayerSafe(player) && player.shouldTickEntities && chunkDistance(player, entity) <= Bukkit.getViewDistance()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static boolean shouldTickChunk(WorldServer worldServer, Chunk chunk) {
+        if (chunk == null) {
+            return false;
+        }
+
+        for (EntityPlayer player : worldServer.players) {
+            if (isPlayerSafe(player) && player.shouldTickEntities && chunkDistance(player, chunk) <= Bukkit.getViewDistance()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static void setPlayerShouldTickEntities(Player player, boolean shouldTickEntities) {
+        ((CraftPlayer) player).getHandle().shouldTickEntities = shouldTickEntities;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..37b3cb2fa82dbb65188c866e5c1ae19c9ac7c1ea
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -0,0 +1,760 @@
+package puregero.multipaper;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.server.*;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.*;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.net.Socket;
+import java.net.SocketException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
+
+public class MultiPaperConnection extends Thread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private Socket socket;
+    private HashMap<Integer, Request> callbacks = new HashMap<>();
+    private HashMap<String, ExternalServer> serversMap = new HashMap<>();
+    private String myName = null;
+    public HashMap<UUID, Location> playerLocations = new HashMap<>();
+
+    public MultiPaperConnection() {
+        start();
+    }
+
+    public void send(byte[] bytes, int id, @Nullable Consumer<DataInputStream> callback) throws IOException {
+        while (true) {
+            try {
+                synchronized (socket) {
+                    if (callback != null) {
+                        callbacks.put(id, new Request(bytes, callback));
+                    }
+                    socket.getOutputStream().write(bytes);
+                    return;
+                }
+            } catch (Exception e) {
+                if (socket != null) {
+                    e.printStackTrace();
+                }
+            }
+
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                throw new IOException(e);
+            }
+        }
+    }
+
+    public DataOutputSender buffer(int id) throws IOException {
+        return new DataOutputSender(this, id);
+    }
+
+    private static String getServer() {
+        try {
+            File file = new File("multipaperserver.txt");
+            if (!file.isFile()) {
+                Files.write(file.toPath(), ("localhost:35353").getBytes());
+            }
+            return new String(Files.readAllBytes(file.toPath())).trim();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return "localhost:35353";
+        }
+    }
+
+    @Override
+    public void run() {
+        while (true) {
+            String server = getServer();
+            LOGGER.info("Connecting to " + server + "...");
+            String[] serverParts = server.split(":");
+            try (Socket socket = new Socket(serverParts[0], Integer.parseInt(serverParts[1]))) {
+                this.socket = socket;
+                LOGGER.info("Connected to " + server);
+
+                synchronized (socket) {
+                    DataOutputStream out = new DataOutputStream(socket.getOutputStream());
+                    out.writeUTF(myName = MultiPaper.getBungeeCordName());
+
+                    // Resend requests on this new socket
+                    for (Request request : callbacks.values()) {
+                        socket.getOutputStream().write(request.getData());
+                    }
+                }
+
+                DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
+                while (!socket.isClosed()) {
+                    int id = in.readInt();
+                    String command = in.readUTF();
+
+                    Request request = callbacks.remove(id);
+
+                    if (request != null) {
+                        request.getCallback().accept(in);
+                        continue;
+                    }
+
+                    // Run command(DataInputStream in);
+                    this.getClass().getMethod(command, DataInputStream.class, DataOutputSender.class).invoke(this, in, buffer(id));
+                }
+            } catch (EOFException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+
+    public void loadJson(DataInputStream in, DataOutputSender out) throws IOException {
+        String file = in.readUTF();
+        LOGGER.info("Reloading json " + file);
+        new Thread(() -> {
+            try {
+                if (DedicatedServer.getServer() == null) {
+                    return;
+                }
+
+                switch (file) {
+                    case "banned-players.json":
+                        DedicatedServer.getServer().getPlayerList().getProfileBans().load();
+                        checkBans();
+                        break;
+                    case "banned-ips.json":
+                        DedicatedServer.getServer().getPlayerList().getIPBans().load();
+                        break;
+                    case "ops.json":
+                        DedicatedServer.getServer().getPlayerList().getOPs().load();
+                        break;
+                    case "whitelist.json":
+                        DedicatedServer.getServer().getPlayerList().getWhitelist().load();
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Invalid json file to load " + file);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }).start();
+    }
+
+    private String p(long n, String s){
+        if(n != 1)return n + " " + s + "s";
+        return n + " " + s;
+    }
+    public String prettyTime(long millis){
+        long seconds = millis/1000;
+        if(seconds >= 60*60*24)
+            return p(seconds/60/60/24,"day") + " and " + p((seconds/60/60)%24,"hour");
+        if(seconds >= 60*60)
+            return p(seconds/60/60,"hour") + " and " + p((seconds/60)%60,"minute");
+        if(seconds >= 60)
+            return p(seconds/60,"minute") + " and " + p((seconds)%60,"second");
+        return p(seconds,"second");
+    }
+    private void checkBans() {
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            BanEntry b = Bukkit.getBanList(BanList.Type.NAME).getBanEntry(player.getName());
+            if (b != null) {
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    Date expire = b.getExpiration();
+                    if (expire != null) {
+                        long t = (expire.getTime() - System.currentTimeMillis());
+                        if (t < 0) return; // Ban expired
+                        player.kickPlayer("You have been banned for:\n" + b.getReason() + "\nYour ban will end in " + prettyTime(t));
+                    } else {
+                        player.kickPlayer("You have been banned for:\n" + b.getReason());
+                    }
+                }, 0, "MultiPaper-KickPlayer");
+            }
+        }
+    }
+
+    public void savePlayer(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.saveData();
+        }
+        out.writeUTF("wrotePlayer");
+        out.send(null);
+    }
+
+    public void saveAdvancements(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getAdvancementData().b(); // Saves world/advancements
+        }
+        out.writeUTF("wroteAdvancements");
+        out.send(null);
+    }
+
+    public void saveStats(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getStatisticManager().save(); // Saves world/stats
+        }
+        out.writeUTF("wroteStats");
+        out.send(null);
+    }
+
+    public void serverInfo(DataInputStream in, DataOutputSender out) throws IOException {
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+        server.setAverageTickTime(in.readInt());
+        server.setLastAlive(System.currentTimeMillis());
+    }
+
+    public void broadcastPacket(DataInputStream in, DataOutputSender out) throws IOException {
+        try {
+            String className = in.readUTF();
+            int length = in.readInt();
+            ByteBuf buf = Unpooled.buffer(length, length);
+            int i;
+            while ((i = buf.writeBytes(in, length)) < length) {
+                length -= i;
+            }
+            Packet<?> packet = (Packet<?>) Class.forName(className).getConstructor().newInstance();
+            packet.a(new PacketDataSerializer(buf));
+            if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
+                DedicatedServer.getServer().getPlayerList().sendAllNoIntercept(packet);
+            }
+
+            if (packet instanceof PacketPlayOutPlayerInfo) {
+                PlayerInfoManager.handle((PacketPlayOutPlayerInfo) packet);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void clearData(DataInputStream in, DataOutputSender out) throws IOException {
+        String pathStr = in.readUTF();
+        File path = new File(pathStr);
+        String file = path.getName().substring(0, path.getName().length() - 4); // Remove .dat suffix
+        while (!path.getParentFile().equals(new File(".")) && !path.getParentFile().equals(path)) {
+            path = path.getParentFile();
+        }
+
+        World world = Bukkit.getWorld(path.getName());
+        if (world == null) {
+            throw new IllegalArgumentException("Unknown world '" + path.getPath() + "' in path " + pathStr);
+        }
+
+        // Clear the data from the world's data cache
+        ((CraftWorld) world).getHandle().getWorldPersistentData().data.remove(file);
+    }
+
+    public void playerList(DataInputStream in, DataOutputSender out) throws IOException {
+        serversMap.values().forEach(server -> server.getPlayers().clear());
+        playerLocations.clear();
+
+        String server;
+        while (!(server = in.readUTF()).isEmpty()) {
+            ExternalServer externalServer = serversMap.get(server);
+
+            double tps = in.readDouble();
+            if (externalServer != null) {
+                externalServer.setTps(tps);
+            }
+
+            int count = in.readInt();
+            for (int i = 0; i < count; i++) {
+                UUID uuid = new UUID(in.readLong(), in.readLong());
+                String world = in.readUTF();
+                double x = in.readDouble();
+                double y = in.readDouble();
+                double z = in.readDouble();
+                float yaw = in.readFloat();
+                float pitch = in.readFloat();
+
+                if (Bukkit.getServer() != null) {
+                    playerLocations.put(uuid, new Location(Bukkit.getWorld(world), x, y, z, yaw, pitch));
+                }
+
+                if (externalServer != null) {
+                    externalServer.getPlayers().add(uuid);
+                }
+            }
+        }
+
+        if (Bukkit.getServer() == null || MinecraftServer.getServer() == null) {
+            out.writeUTF("playerList");
+            out.writeDouble(20);
+            out.writeInt(0);
+        } else {
+            Collection<? extends Player> players = Bukkit.getOnlinePlayers();
+            out.writeUTF("playerList");
+            out.writeDouble(MinecraftServer.getServer().recentTps[0]);
+            out.writeInt(players.size());
+            for (Player player : players) {
+                out.writeLong(player.getUniqueId().getMostSignificantBits());
+                out.writeLong(player.getUniqueId().getLeastSignificantBits());
+                out.writeUTF(player.getWorld().getName());
+                out.writeDouble(player.getLocation().getX());
+                out.writeDouble(player.getLocation().getY());
+                out.writeDouble(player.getLocation().getZ());
+                out.writeFloat(player.getLocation().getYaw());
+                out.writeFloat(player.getLocation().getPitch());
+            }
+        }
+        out.send(null);
+
+        sendLoadedChunkList();
+    }
+
+    public void chunkData(DataInputStream in, DataOutputSender out) throws IOException {
+        int length = in.readInt();
+        in.skipBytes(length);
+        LOGGER.info("Unsolicited chunk data of length: " + length + " bytes");
+    }
+
+    public void lockedChunk(DataInputStream in, DataOutputSender out) throws IOException {
+        String locker = in.readUTF();
+        LOGGER.info("Unsolicited locked chunk with locker: " + (locker.length() == 0 ? "null" : locker));
+    }
+
+    public void start(DataInputStream in, DataOutputSender out) throws IOException {
+        if (DedicatedServer.getServer() != null) {
+            MultiPaper.broadcastPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, DedicatedServer.getServer().getPlayerList().players.toArray(new EntityPlayer[0])));
+        }
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        AtomicBoolean hasReturned = new AtomicBoolean(false);
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                hasReturned.set(true);
+
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        new Thread(() -> {
+            int i = 0;
+            while (!hasReturned.get()) {
+                if (++i % 15 == 0) {
+                    if (DedicatedServer.getServer().hasStopped()) {
+                        LOGGER.info("No response for readChunk " + world + "," + path + "," + cx + "," + cz + ", but server has stopped, aborting operation.");
+                        future.complete(null);
+                        return;
+                    }
+                    LOGGER.info("No response for readChunk " + world + "," + path + "," + cx + "," + cz + ", resending...");
+                    try {
+                        out.send(callback);
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                        return;
+                    }
+                }
+                try {
+                    Thread.sleep(1000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                    return;
+                }
+            }
+        }).start();
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readLevel(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readLevel");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeLevel(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeLevel");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<String> readJson(String name) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readJson");
+        out.writeUTF(name);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeJson(String name, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeJson");
+        out.writeUTF(name);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readPlayer(String uuid) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readPlayer");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writePlayer(String uuid, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writePlayer");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockPlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockPlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releasePlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releasePlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<DataInputStream> readUid(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readUid");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeUid(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeUid");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void writeTickTime(long time) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeTickTime");
+        out.writeLong(time);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> lockChunk(String world, int cx, int cz) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(in -> {
+            try {
+                String holder = in.readUTF();
+                future.complete(holder.isEmpty() ? null : holder);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void releaseChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void notifyChunkNotSaving(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkNotSaving");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readAdvancements(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readAdvancements");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeAdvancements(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeAdvancements");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readStats(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readStats");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeStats(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeStats");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void broadcastPacket(Packet<?> packet) throws IOException {
+        ByteBuf buf = Unpooled.buffer();
+        packet.b(new PacketDataSerializer(buf));
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("broadcastPacket");
+        out.writeUTF(packet.getClass().getName());
+        out.writeInt(buf.readableBytes());
+        buf.readBytes(out, buf.readableBytes());
+        out.send(null);
+    }
+
+    public void sendStart() throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("start");
+        out.send(null);
+    }
+
+    public CompletableFuture<byte[]> readData(String path) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readData");
+        out.writeUTF(path);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeData(String path, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeData");
+        out.writeUTF(path);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    private void sendLoadedChunkList() throws IOException {
+        if (Bukkit.getServer() != null) {
+            List<Chunk> chunks = new ArrayList<>();
+
+            for (World world : Bukkit.getWorlds()) {
+                chunks.addAll(Arrays.asList(world.getLoadedChunks()));
+            }
+
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("loadedChunkList");
+            out.writeInt(chunks.size());
+
+            for (Chunk chunk : chunks) {
+                out.writeUTF(chunk.getWorld().getName());
+                out.writeInt(chunk.getX());
+                out.writeInt(chunk.getZ());
+            }
+
+            out.send(null);
+        }
+    }
+
+    public HashMap<String, ExternalServer> getServersMap() {
+        return serversMap;
+    }
+
+    public String getBungeeCordName() {
+        return myName;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/PlayerInfoManager.java b/src/main/java/puregero/multipaper/PlayerInfoManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..e976c9f81faa553d37c3f17ea2407162c92d5e3d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/PlayerInfoManager.java
@@ -0,0 +1,62 @@
+package puregero.multipaper;
+
+import net.minecraft.server.DedicatedServer;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PacketPlayOutPlayerInfo;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+import java.util.HashMap;
+import java.util.UUID;
+
+public class PlayerInfoManager {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static HashMap<UUID, PacketPlayOutPlayerInfo.PlayerInfoData> playerInfos = new HashMap<>();
+
+    public static void handle(PacketPlayOutPlayerInfo packet) {
+        for (PacketPlayOutPlayerInfo.PlayerInfoData info : packet.getPlayerInfoDatas()) {
+            UUID uuid = info.a().getId();
+
+            if (packet.getAction() == PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER) {
+                playerInfos.put(uuid, info);
+                return;
+            }
+
+            if (packet.getAction() == PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER) {
+                CraftPlayer player = Bukkit.getServer() == null ? null : (CraftPlayer) Bukkit.getPlayer(uuid);
+                if (player != null) {
+                    DedicatedServer.getServer().getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, player.getHandle()));
+                }
+
+                playerInfos.remove(uuid);
+                return;
+            }
+
+            PacketPlayOutPlayerInfo.PlayerInfoData infoData = playerInfos.get(uuid);
+
+            if (infoData == null) {
+                return;
+            }
+
+            if (info.b != 0) {
+                infoData.b = info.b;
+            }
+
+            if (info.c != null) {
+                infoData.c = info.c;
+            }
+
+            if (info.e != null) {
+                infoData.e = info.e;
+            }
+        }
+    }
+
+    public static void send(EntityPlayer player) {
+        player.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(playerInfos.values()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/Request.java b/src/main/java/puregero/multipaper/Request.java
new file mode 100644
index 0000000000000000000000000000000000000000..19b017cb8118b72d06c7016605cf17bb9dcad131
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Request.java
@@ -0,0 +1,27 @@
+package puregero.multipaper;
+
+import java.io.DataInputStream;
+import java.util.function.Consumer;
+
+public class Request {
+    private final byte[] data;
+    private final Consumer<DataInputStream> callback;
+    private final long time = System.currentTimeMillis();
+
+    public Request(byte[] data, Consumer<DataInputStream> callback) {
+        this.data = data;
+        this.callback = callback;
+    }
+
+    public byte[] getData() {
+        return data;
+    }
+
+    public Consumer<DataInputStream> getCallback() {
+        return callback;
+    }
+
+    public long getTime() {
+        return time;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ServersCommand.java b/src/main/java/puregero/multipaper/ServersCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6f77bfe0b0d11c4e312d73aa5021ebe97e0db8f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ServersCommand.java
@@ -0,0 +1,42 @@
+package puregero.multipaper;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class ServersCommand extends Command {
+    public ServersCommand(String command) {
+        super(command);
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        sender.sendMessage(ChatColor.GRAY + "[Servers] (Avg Tick Time / Tps / Player Count)");
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            String tickTime = Integer.toString(server.getAverageTickTime()) + "ms";
+            if (server.getAverageTickTime() < 40) {
+                tickTime = ChatColor.GREEN + tickTime;
+            } else if (server.getAverageTickTime() < 50) {
+                tickTime = ChatColor.YELLOW + tickTime;
+            } else {
+                tickTime = ChatColor.RED + tickTime;
+            }
+
+            String tpsString = String.format("%.1f tps", server.getTps());
+
+            String playersString = server.getPlayers().size() + " player";
+            if (server.getPlayers().size() != 1) {
+                playersString += "s";
+            }
+
+            if (!server.isAlive()) {
+                sender.sendMessage(ChatColor.DARK_GRAY + "[" + server.getName() + "] " + server.getAverageTickTime() + "ms, " + tpsString + ", " + playersString);
+            } else {
+                sender.sendMessage(ChatColor.GREEN + "[" + (server.isMe() ? ChatColor.GOLD : "") + server.getName() + ChatColor.GREEN + "] " + tickTime + ", " + tpsString + ", " + playersString);
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ShutdownHandler.java b/src/main/java/puregero/multipaper/ShutdownHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..bab74c4a99e7dc4b488c62b204c8441e6369aebb
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ShutdownHandler.java
@@ -0,0 +1,71 @@
+package puregero.multipaper;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+public class ShutdownHandler {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static void onStop() {
+        movePlayersToDifferentServer();
+    }
+
+    private static void movePlayersToDifferentServer() {
+        HashSet<Player> moved = new HashSet<>();
+        int tries = 0;
+        do {
+            moved.clear();
+
+            if (tries++ > 10) {
+                LOGGER.warn("Given up sending players to another server, disconnecting them instead");
+                return;
+            }
+
+            for (Player player : Bukkit.getOnlinePlayers()) {
+                if (moved.contains(player) || ((CraftPlayer) player).getHandle().playerConnection.isDisconnected()) {
+                    continue;
+                }
+
+                String server = randomServer();
+
+                if (server == null) {
+                    LOGGER.info("No other servers are online, disconnecting players instead");
+                    return;
+                }
+
+                moved.addAll(Zone.doMerge(player.getChunk(), server));
+            }
+
+            LOGGER.info("Moving players to different servers... (" + moved.size() + " players to go)");
+
+            if (!moved.isEmpty()) {
+                // Wait for players to get moved
+                try {
+                    Thread.sleep(2500);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                    return;
+                }
+            }
+        } while (!moved.isEmpty());
+    }
+
+    private static String randomServer() {
+        List<String> servers = new ArrayList<>();
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server != MultiPaper.getMe() && server.isAlive()) {
+                servers.add(server.getName());
+            }
+        }
+
+        return servers.isEmpty() ? null : servers.get((int) (Math.random() * servers.size()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab8cf248ff8496e37f11ba49481e41118c2bf381
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -0,0 +1,223 @@
+package puregero.multipaper;
+
+import net.minecraft.server.WorldServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftChunk;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class Zone {
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static final int SHOULD_MERGE_CHUNK_LIMIT = 15;
+
+    private static HashSet<Player> beingSentToAnotherServer = new HashSet<>();
+    private static HashMap<Player, Zone> zonesToUnload = new HashMap<>();
+
+    private static List<Consumer<Chunk>> chunkSaveHandlers = new ArrayList<>();
+
+    public static void registerChunkSaveHandler(Consumer<Chunk> handler) {
+        chunkSaveHandlers.add(handler);
+    }
+
+    public static boolean shouldLockChunk(String world, int cx, int cz) {
+        for (Player player : Bukkit.getWorld(world).getPlayers()) {
+            if (!beingSentToAnotherServer.contains(player) &&
+                    Math.abs((player.getLocation().getBlockX() >> 4) - cx) <= Bukkit.getViewDistance() + 6 &&
+                    Math.abs((player.getLocation().getBlockZ() >> 4) - cz) <= Bukkit.getViewDistance() + 6) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public static boolean isBeingSentToAnotherServer(Player player) {
+        return beingSentToAnotherServer.contains(player);
+    }
+
+    public static Collection<Player> doMerge(Chunk chunk, String server) {
+        Zone zone = new Zone(chunk);
+
+        if (zone.players.size() > 0) {
+            return doMerge(chunk, zone, server);
+        }
+
+        return zone.players;
+    }
+
+    private static Collection<Player> doMerge(Chunk chunk, Zone zone1, String server) {
+        LOGGER.info("Merging " + zone1.players.size() + " players and " + zone1.chunks.size() + " chunks with server " + server);
+
+        HashSet<Player> toSend = new HashSet<>();
+        for (Player player : zone1.players) {
+            if (beingSentToAnotherServer.add(player)) {
+                zonesToUnload.put(player, zone1);
+                toSend.add(player);
+            }
+        }
+
+        try {
+            Thread.sleep(50);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+
+        Zone zone = new Zone(chunk);
+
+        for (Chunk c : zone.chunks) {
+            net.minecraft.server.Chunk nmsChunk = ((CraftChunk) c).getHandle();
+            MultiPaper.releaseChunk(nmsChunk.getPos(), nmsChunk.world);
+            chunkSaveHandlers.forEach(handler -> handler.accept(c));
+            nmsChunk.world.getChunkProvider().playerChunkMap.saveChunk(nmsChunk);
+        }
+
+        WorldServer worldServer = ((CraftChunk) chunk).getHandle().world;
+        if (worldServer.getMinecraftServer().hasStopped()) {
+            LOGGER.info("Server is stopping, flushing chunk writes");
+            worldServer.asyncChunkTaskManager.flush();
+        }
+
+        for (Player player : toSend) {
+            ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
+            BungeeCord.connectPlayer(player, server);
+        }
+
+        ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> zone.chunks.forEach(Chunk::unload), 0, "Unload Chunks");
+
+        return toSend;
+    }
+
+    public static void checkIfShouldMerge(Chunk chunk) {
+        ExternalServer serverTo = MultiPaper.getMe();
+
+        // Find server with lowest average tick time
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server.getAverageTickTime() < serverTo.getAverageTickTime() - 20 &&
+                    server.isAlive()) {
+                serverTo = server;
+            }
+        }
+
+        if (serverTo.isMe()) {
+            // Can't merge with yourself
+            return;
+        }
+
+        Zone zone = new Zone(chunk, SHOULD_MERGE_CHUNK_LIMIT);
+
+        if (zone.chunks.size() >= SHOULD_MERGE_CHUNK_LIMIT) {
+            // Too many chunks loaded, probably not worth merging
+            return;
+        }
+
+        if (zone.players.isEmpty()) {
+            // No one to merge
+            return;
+        }
+
+        HashSet<Player> nearbyPlayers = new HashSet<>();
+        for (Player player : chunk.getWorld().getPlayers()) {
+            if (!zone.players.contains(player) &&
+                    Math.abs(player.getChunk().getX() - chunk.getX()) < Bukkit.getViewDistance() * 5 &&
+                    Math.abs(player.getChunk().getZ() - chunk.getZ()) < Bukkit.getViewDistance() * 5) {
+                nearbyPlayers.add(player);
+            }
+        }
+
+        if (!nearbyPlayers.isEmpty()) {
+            // There are nearby players on this server, this will probably mean
+            // that if we merge with another server, we might end up merging
+            // back very soon
+            return;
+        }
+
+        Zone.doMerge(chunk, zone, serverTo.getName());
+    }
+
+    public static void onPlayerDisconnect(Player player) {
+        Location location = player.getLocation();
+        String name = player.getName();
+        ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+            beingSentToAnotherServer.remove(player);
+
+            Zone zone = zonesToUnload.remove(player);
+            if (zone != null) {
+                Zone zone2 = new Zone(location.getWorld(), location.getBlockX() >> 4, location.getBlockZ() >> 4);
+
+                zone.chunks.forEach(zone2::mapChunks);
+
+                if (zone2.players.isEmpty()) {
+                    LOGGER.info(name + " has left: Unloading zone with " + zone2.chunks.size() + " loaded chunks");
+                    zone2.chunks.forEach(Chunk::unload);
+                }
+            }
+        }, 1, "Remove player from beingSentToAnotherServer");
+    }
+
+    private final HashSet<Chunk> chunks = new HashSet<>();
+    private final HashSet<Player> players = new HashSet<>();
+    private final int chunkLimit;
+
+    private Zone(Chunk chunk) {
+        this(chunk, Integer.MAX_VALUE);
+    }
+
+    private Zone(Chunk chunk, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(chunk);
+        mapPlayers(chunk.getWorld());
+    }
+
+    private Zone(World world, int cx, int cz) {
+        this(world, cx, cz, Integer.MAX_VALUE);
+    }
+
+    private Zone(World world, int cx, int cz, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(world, cx, cz);
+        mapPlayers(world);
+    }
+
+    private void mapChunks(Chunk chunk) {
+        if (chunks.contains(chunk)) {
+            return;
+        }
+
+        if (chunk.isLoaded()) {
+            chunks.add(chunk);
+        }
+
+        if (chunks.size() > chunkLimit) {
+            return;
+        }
+
+        mapChunks(chunk.getWorld(), chunk.getX(), chunk.getZ());
+    }
+
+    private void mapChunks(World world, int cx, int cz) {
+        for (int dx = -2; dx <= 2; dx ++) {
+            for (int dz = -2; dz <= 2; dz ++) {
+                if (world.isChunkLoaded(cx + dx, cz + dz)) {
+                    mapChunks(world.getChunkAt(cx + dx, cz + dz));
+                }
+            }
+        }
+    }
+
+    private void mapPlayers(World world) {
+        for (Player player : world.getPlayers()) {
+            if (chunks.contains(player.getChunk())) {
+                players.add(player);
+            }
+        }
+    }
+}
