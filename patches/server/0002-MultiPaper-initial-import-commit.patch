From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 17 Jan 2021 15:56:33 +1000
Subject: [PATCH] MultiPaper initial import commit


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 26e18a08a7f0bd704ff3055ce3a7814191450c85..e04573d6564e4200192b3115a6ccc08cee9d8ac6 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -690,7 +690,7 @@ public class PaperWorldConfig {
 
     public long delayChunkUnloadsBy;
     private void delayChunkUnloadsBy() {
-        delayChunkUnloadsBy = PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s"));
+        delayChunkUnloadsBy = 0; // PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s")); // MultiPaper disable delay
         if (delayChunkUnloadsBy > 0) {
             log("Delaying chunk unloads by " + delayChunkUnloadsBy + " seconds");
             delayChunkUnloadsBy *= 20;
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index eb0053850f53ceb60eb1ae3ac0e34034648fe1eb..d7ffacd252564332b2aa8facef42040cae3f71d8 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -30,6 +30,7 @@ import org.bukkit.event.Event;
 import org.bukkit.event.HandlerList;
 import org.bukkit.event.player.AsyncPlayerChatEvent;
 import org.bukkit.event.player.PlayerChatEvent;
+import puregero.multipaper.MultiPaper;
 
 public final class ChatProcessor {
     // <-- copied from adventure-text-serializer-legacy
@@ -181,6 +182,8 @@ public final class ChatProcessor {
                 viewer.sendMessage(player, renderer.render(player, displayName, message, viewer), MessageType.CHAT);
             }
         }
+
+        MultiPaper.broadcastPacket(event.getPlayer().getUniqueId(), renderer.render(player, displayName, message, player)); // MultiPaper broadcast chat message
     }
 
     private AsyncChatEvent createAsync(final ChatRenderer renderer, final Set<Audience> viewers, final Component message) {
diff --git a/src/main/java/net/minecraft/advancements/CriterionProgress.java b/src/main/java/net/minecraft/advancements/CriterionProgress.java
index 322f0fd9eff00085c2e9765395c7dcdef8bc9e12..6503e0c6007174d983ab69149230d2a1910421d2 100644
--- a/src/main/java/net/minecraft/advancements/CriterionProgress.java
+++ b/src/main/java/net/minecraft/advancements/CriterionProgress.java
@@ -43,7 +43,11 @@ public class CriterionProgress {
     }
 
     public JsonElement serializeToJson() {
-        return (JsonElement)(this.obtained != null ? new JsonPrimitive(DATE_FORMAT.format(this.obtained)) : JsonNull.INSTANCE);
+        try {
+            return (JsonElement)(this.obtained != null ? new JsonPrimitive(DATE_FORMAT.format(this.obtained)) : JsonNull.INSTANCE);
+        } catch (Exception e) {
+            return JsonNull.INSTANCE;
+        }
     }
 
     public static CriterionProgress fromNetwork(FriendlyByteBuf buf) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
index 420cc7ab5f7245f31dd5b333eacf4e306fc6e7c1..feb99e1b386445c2a2ebd46931da852f3a673219 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundPlayerInfoPacket.java
@@ -62,6 +62,49 @@ public class ClientboundPlayerInfoPacket implements Packet<ClientGamePacketListe
         return this.action;
     }
 
+    // MultiPaper start
+    public PacketPlayOutPlayerInfo(Iterable<PlayerUpdate> iterable) {
+        this.action = EnumPlayerInfoAction.ADD_PLAYER;
+
+        Iterator<PlayerUpdate> iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            this.entries.add(iterator.next());
+        }
+    }
+
+    public List<ClientboundPlayerInfoPacket.PlayerUpdate> getPlayerUpdates() {
+        return entries;
+    }
+    // MultiPaper end
+
+    @Override
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = (PacketPlayOutPlayerInfo.EnumPlayerInfoAction) packetdataserializer.a(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.class);
+        int i = packetdataserializer.i();
+
+        for (int j = 0; j < i; ++j) {
+            GameProfile gameprofile = null;
+            int k = 0;
+            EnumGamemode enumgamemode = null;
+            IChatBaseComponent ichatbasecomponent = null;
+
+            switch (this.a) {
+                case ADD_PLAYER:
+                    gameprofile = new GameProfile(packetdataserializer.k(), packetdataserializer.e(16));
+                    int l = packetdataserializer.i();
+
+                    for (int i1 = 0; i1 < l; ++i1) {
+                        String s = packetdataserializer.e(32767);
+                        String s1 = packetdataserializer.e(32767);
+
+                        if (packetdataserializer.readBoolean()) {
+                            gameprofile.getProperties().put(s, new Property(s, s1, packetdataserializer.e(32767)));
+                        } else {
+                            gameprofile.getProperties().put(s, new Property(s, s1));
+                        }
+                    }
+
     @Nullable
     static Component readDisplayName(FriendlyByteBuf buf) {
         return buf.readBoolean() ? buf.readComponent() : null;
@@ -186,11 +229,13 @@ public class ClientboundPlayerInfoPacket implements Packet<ClientGamePacketListe
     }
 
     public static class PlayerUpdate {
-        private final int latency;
-        private final GameType gameMode;
-        private final GameProfile profile;
+        // MultiPaper start - make not final and public
+        public int latency;
+        public GameType gameMode;
+        public GameProfile profile;
         @Nullable
-        private final Component displayName;
+        public Component displayName;
+        // MultiPaper end
 
         public PlayerUpdate(GameProfile profile, int latency, @Nullable GameType gameMode, @Nullable Component displayName) {
             this.profile = profile;
diff --git a/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java b/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
index 4d36dcce588a503ba879528d98241ee86f70d48c..3dcd095be2eae5e531b1c41fdfc898196ee2b6a4 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ServerboundTeleportToEntityPacket.java
@@ -32,4 +32,10 @@ public class ServerboundTeleportToEntityPacket implements Packet<ServerGamePacke
     public Entity getEntity(ServerLevel world) {
         return world.getEntity(this.uuid);
     }
+    
+    // MultiPaper start - Expose uuid
+    public UUID getUUID() {
+        return a;
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3bf39c2d2aa3fc4fd0815dacea57e4899ec0da0e..36759054f7fceaad5566d48d573ef8eb13c19b54 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -190,6 +190,9 @@ import org.bukkit.event.server.ServerLoadEvent;
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
 
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.ShutdownHandler;
+
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
 
     private static MinecraftServer SERVER; // Paper
@@ -946,6 +949,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // CraftBukkit end
         MinecraftServer.LOGGER.info("Stopping server");
         MinecraftTimings.stopServer(); // Paper
+        ShutdownHandler.onStop(); // MultiPaper
         // CraftBukkit start
         if (this.server != null) {
             this.server.disablePlugins();
@@ -1475,6 +1479,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         tickTimes60s.add(this.tickCount, l);
         // Paper end
 
+        MultiPaper.sendTickTime(i1 - i); // MultiPaper
         this.frameTimer.logFrameDuration(i1 - i);
         this.profiler.pop();
         org.spigotmc.WatchdogThread.tick(); // Spigot
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 7d6dc0a8ee35274052b122bbc446bc54750de0a6..04f196390a3dd4b8193b9220887093fa3ebaf52a 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -52,6 +52,8 @@ import net.minecraft.world.level.GameRules;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import puregero.multipaper.MultiPaper;
+
 public class PlayerAdvancements {
 
     private static final Logger LOGGER = LogManager.getLogger();
@@ -156,9 +158,15 @@ public class PlayerAdvancements {
     }
 
     private void load(ServerAdvancementManager advancementLoader) {
-        if (this.file.isFile()) {
+        String json = null;
+        try {
+            json = MultiPaper.readAdvancements(player.getUniqueIDString());
+        } catch (IOException e1) {
+            e1.printStackTrace();
+        }
+        if ((json != null && !json.isEmpty()) || this.file.isFile()) {
             try {
-                JsonReader jsonreader = new JsonReader(new StringReader(Files.toString(this.file, StandardCharsets.UTF_8)));
+                JsonReader jsonreader = new JsonReader(new StringReader(json));
 
                 try {
                     jsonreader.setLenient(false);
@@ -239,7 +247,18 @@ public class PlayerAdvancements {
         jsonelement.getAsJsonObject().addProperty("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
 
         try {
+<<<<<<< HEAD
             FileOutputStream fileoutputstream = new FileOutputStream(this.file);
+=======
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeAdvancements(player.getUniqueIDString(), AdvancementDataPlayer.b.toJson(jsonelement));
+                return;
+            }
+            // MultiPaper end
+            FileOutputStream fileoutputstream = new FileOutputStream(this.f);
+            Throwable throwable = null;
+>>>>>>> MultiPaper initial import commit
 
             try {
                 OutputStreamWriter outputstreamwriter = new OutputStreamWriter(fileoutputstream, Charsets.UTF_8.newEncoder());
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index eeefbb86cb88bd1b132bb6e22b4a4572cfb5e22c..961ebbd8433e4974e8e9334e4d3c64c0188bde97 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -70,6 +70,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements ServerInterface {
@@ -275,6 +276,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
         // CraftBukkit end
 
+        MultiPaper.onStart(); // MultiPaper
+        
         if (!this.usesAuthentication()) {
             DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
             DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7f7bc04a30a0422b2d589adb488082c0aa5326dc..e269f5b17859c1de6ad6ecbcf5fd222aa020c568 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -104,6 +104,11 @@ import org.apache.logging.log4j.Logger;
 
 import org.bukkit.entity.Player; // CraftBukkit
 
+// MultiPaper start
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.Zone;
+// MultiPaper end
+
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
     private static final byte CHUNK_TYPE_REPLACEABLE = -1;
@@ -954,6 +959,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
             do {
                 boolean isShuttingDown = level.getServer().hasStopped(); // Paper
+
+                if (!isShuttingDown) new Exception("ChunkMap.saveAllChunks has been called even though the server isn't shutting down!").printStackTrace(); // MultiPaper
+                
                 mutableboolean.setFalse();
                 list.stream().map((playerchunk) -> {
                     CompletableFuture completablefuture;
@@ -1063,6 +1071,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             poiData, null, com.destroystokyo.paper.io.PrioritizedTaskQueue.LOW_PRIORITY);
 
         if (!chunk.isUnsaved()) {
+            MultiPaper.notifyChunkNotSaving(chunk.getPos(), this.world);
             return;
         }
 
@@ -1485,6 +1494,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         try (co.aikar.timings.Timing ignored = this.level.timings.chunkSave.startTiming()) { // Paper
         this.poiManager.flush(chunk.getPos());
         if (!chunk.isUnsaved()) {
+            MultiPaper.notifyChunkNotSaving(ichunkaccess.getPos(), this.world);
             return false;
         } else {
             chunk.setLastSaved(this.level.getGameTime()); // Paper - track save time
@@ -1672,6 +1682,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             return ret;
         }
+        if (true) return MultiPaper.readChunk(chunkcoordintpair, world); // MultiPaper
         return super.read(chunkcoordintpair);
     }
 
@@ -1683,6 +1694,12 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
+        // MultiPaper start
+        if (true) {
+            MultiPaper.writeChunk(chunkcoordintpair, world, nbttagcompound);
+            return;
+        }
+        // MultiPaper end
         super.write(chunkcoordintpair, nbttagcompound);
     }
     // Paper end
@@ -1726,6 +1743,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             return status;
         }
 
+        if (true) return null; // MultiPaper - Don't load chunk status from the disk
+
         this.readChunk(chunkPos);
 
         return regionFile.getStatusIfCached(chunkPos.x, chunkPos.z);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 82d3cfb2d346a8b929e9469ae09369f6a639f81d..0ad49b556f0ddbcf2854cadae5f7aa406b5f3b45 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -46,11 +46,12 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import puregero.multipaper.MultiPaper;
 
 public class ServerChunkCache extends ChunkSource {
 
     public static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
-    private final DistanceManager distanceManager;
+    public final DistanceManager distanceManager; // MultiPaper - make public
     public final ChunkGenerator generator;
     final ServerLevel level;
     public final Thread mainThread;
@@ -840,6 +841,8 @@ public class ServerChunkCache extends ChunkSource {
                     this.level.getProfiler().push("broadcast");
                     LevelChunk chunk = (LevelChunk) optional.get();
 
+                    if (!MultiPaper.shouldTickChunk(this.world, chunk)) return; // MultiPaper - Should we tick this chunk?
+
                     this.level.timings.broadcastChunkUpdates.startTiming(); // Paper - timings
                     playerchunk.broadcastChanges(chunk);
                     this.level.timings.broadcastChunkUpdates.stopTiming(); // Paper - timings
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index b3312fa2fd218ffcfaa61d98584003c97fbda4ce..39e4e2ec68a5e9f96d9e00ecdedf732d7b146baf 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -164,6 +164,7 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class ServerLevel extends net.minecraft.world.level.Level implements WorldGenLevel {
@@ -327,7 +328,7 @@ public class ServerLevel extends net.minecraft.world.level.Level implements Worl
         };
         registryblocks = Registry.FLUID;
         Objects.requireNonNull(registryblocks);
-        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList) {
+        if (com.destroystokyo.paper.PaperConfig.useOptimizedTickList && false) { // MultiPaper disable
             this.blockTicks = new com.destroystokyo.paper.server.ticklist.PaperTickList<>(this, predicate, Registry.BLOCK::getKey, this::tickBlock, "Blocks"); // Paper - Timings
             this.liquidTicks = new com.destroystokyo.paper.server.ticklist.PaperTickList<>(this, predicate2, Registry.FLUID::getKey, this::tickLiquid, "Fluids"); // Paper timings
         } else {
@@ -617,6 +618,7 @@ public class ServerLevel extends net.minecraft.world.level.Level implements Worl
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
+<<<<<<< HEAD
             this.entityTickList.forEach((entity) -> {
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
@@ -631,6 +633,24 @@ public class ServerLevel extends net.minecraft.world.level.Level implements Worl
                             if (!entity1.isRemoved() && entity1.hasPassenger(entity)) {
                                 return;
                             }
+=======
+            while (objectiterator.hasNext()) {
+                Entry<Entity> entry = (Entry) objectiterator.next();
+                Entity entity = (Entity) entry.getValue();
+                Entity entity1 = entity.getVehicle();
+
+                if (!MultiPaper.shouldTickEntity(this, entity)) continue; // MultiPaper - Should we tick this entity?
+
+                /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
+                if (!this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
+                    entity.die();
+                }
+
+                if (!this.server.getSpawnNPCs() && entity instanceof NPC) {
+                    entity.die();
+                }
+                // CraftBukkit end */
+>>>>>>> MultiPaper initial import commit
 
                             entity.stopRiding();
                         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 181ab56448796a617f30f1b9e0fec8917b5d8e07..658d6d93b88e030b481f8daee73439708ca9e53e 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -234,6 +234,7 @@ public class ServerPlayer extends Player {
     public final int[] mobCounts = new int[ENUMCREATURETYPE_TOTAL_ENUMS]; // Paper
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
     // Paper end
+    public boolean isBeingSentToAnotherServer = false; // MultiPaper
 
     // CraftBukkit start
     public String displayName;
@@ -245,6 +246,7 @@ public class ServerPlayer extends Player {
     public int newTotalExp = 0;
     public boolean keepLevel = false;
     public double maxHealthCache;
+    public boolean shouldTickEntities = true; // MultiPaper
     public boolean joining = true;
     public boolean sentListPacket = false;
     public boolean supressTrackerForLogin = false; // Paper
@@ -447,6 +449,8 @@ public class ServerPlayer extends Player {
             this.enteredNetherPosition = new Vec3(nbttagcompound1.getDouble("x"), nbttagcompound1.getDouble("y"), nbttagcompound1.getDouble("z"));
         }
 
+        this.isBeingSentToAnotherServer = nbttagcompound.getBoolean("isBeingSentToAnotherServer"); // MultiPaper
+        
         this.seenCredits = nbt.getBoolean("seenCredits");
         if (nbt.contains("recipeBook", 10)) {
             this.recipeBook.fromNbt(nbt.getCompound("recipeBook"), this.server.getRecipeManager());
@@ -509,6 +513,8 @@ public class ServerPlayer extends Player {
             }
         }
 
+        nbttagcompound.setBoolean("isBeingSentToAnotherServer", this.isBeingSentToAnotherServer); // MultiPaper
+        
         if (persistVehicle && entity1 != null && entity != this && entity.hasExactlyOnePlayerPassenger()) {
             // CraftBukkit end
             CompoundTag nbttagcompound2 = new CompoundTag();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 7d2ac8aa97805e8b022d3982b1332c5055fc8b90..17c50ef8a6fc302c4dff4cad118e8a18ce07d3ec 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -215,6 +215,7 @@ import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, ServerGamePacketListener {
@@ -1423,7 +1424,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                                 }
 
                                 // Prevent 40 event-calls for less than a single pixel of movement >.>
-                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getX(), 2);
                                 float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
 
                                 if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isImmobile()) {
@@ -1837,6 +1838,13 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                     return;
                 }
             }
+
+            // MultiPaper start - Find player on another server
+            Location location = MultiPaper.getPlayerLocation(packetplayinspectate.getUUID());
+            if (location != null) {
+                this.player.getBukkitEntity().teleportAsync(location, PlayerTeleportEvent.TeleportCause.SPECTATE);
+            }
+            // MultiPaper end
         }
 
     }
@@ -2160,6 +2168,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
                         recipient.sendMessage(ServerGamePacketListenerImpl.this.player.getUUID(), s);
                     }
                 }
+                MultiPaper.broadcastPacket(PlayerConnection.this.player.getUniqueID(), s); // MultiPaper
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index d76d8d8db7921d16f87dd162ccd115e351cde106..8d9265c599569fda3db74b9f544c3afc9c0d8888 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -116,6 +116,9 @@ import org.bukkit.event.player.PlayerJoinEvent;
 import org.bukkit.event.player.PlayerLoginEvent;
 import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.PlayerInfoManager;
+import puregero.multipaper.Zone;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -277,6 +280,13 @@ public abstract class PlayerList {
         player.getRecipeBook().sendInitialRecipeBook(player);
         this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
         this.server.invalidateStatus();
+
+        // MultiPaper start - Check if player should move servers
+        if (Zone.checkIfShouldMerge(player.getBukkitEntity())) {
+            return;
+        }
+        // MultiPaper end
+
         // Paper start - async load spawn in chunk
         ServerLevel finalWorldserver = worldserver1;
         int chunkX = loc.getBlockX() >> 4;
@@ -332,13 +342,19 @@ public abstract class PlayerList {
         }
         // CraftBukkit start
         chatmessage.withStyle(ChatFormatting.YELLOW);
+        // MultiPaper start
+        if (player.isBeingSentToAnotherServer) {
+            player.isBeingSentToAnotherServer = false;
+            chatmessage = null;
+        }
+        // MultiPaper end
         Component joinMessage = chatmessage; // Paper - Adventure
 
         playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
         this.players.add(player);
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[]{entityplayer})); // CraftBukkit - replaced with loop below
+        this.sendAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, new ServerPlayer[]{player})); // CraftBukkit - replaced with loop below // MultiPaper - Keep original sendAll
 
         // Paper start - correctly register player BEFORE PlayerJoinEvent, so the entity is valid and doesn't require tick delay hacks
         player.supressTrackerForLogin = true;
@@ -364,6 +380,11 @@ public abstract class PlayerList {
         }
         // CraftBukkit end
 
+        MultiPaper.lockPlayer(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.lockAdvancements(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.lockStats(entityplayer.getUniqueIDString()); // MultiPaper
+        PlayerInfoManager.send(entityplayer); // MultiPaper
+
         // CraftBukkit start - sendAll above replaced with this loop
         ClientboundPlayerInfoPacket packet = new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.ADD_PLAYER, player);
 
@@ -371,7 +392,7 @@ public abstract class PlayerList {
             ServerPlayer entityplayer1 = (ServerPlayer) this.players.get(i);
 
             if (entityplayer1.getBukkitEntity().canSee(player.getBukkitEntity())) {
-                entityplayer1.connection.send(packet);
+                // entityplayer1.connection.send(packet); // MultiPaper - Keep original sendAll
             }
 
             if (!player.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
@@ -590,6 +611,7 @@ public abstract class PlayerList {
         }
 
         PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(this.cserver.getPlayer(entityplayer), net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, com.destroystokyo.paper.PaperConfig.useDisplayNameInQuit ? entityplayer.getBukkitEntity().displayName() : net.kyori.adventure.text.Component.text(entityplayer.getScoreboardName())), entityplayer.quitReason); // Paper - quit reason
+        if (entityplayer.isBeingSentToAnotherServer) playerQuitEvent.setQuitMessage(null); // MultiPaper - No quit message if they're going to another server
         if (entityplayer.didPlayerJoinEvent) this.cserver.getPluginManager().callEvent(playerQuitEvent); // Paper - if we disconnected before join ever fired, don't fire quit
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
 
@@ -615,6 +637,9 @@ public abstract class PlayerList {
         // Paper end
 
         this.save(entityplayer);
+        MultiPaper.releasePlayer(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.releaseAdvancements(entityplayer.getUniqueIDString()); // MultiPaper
+        MultiPaper.releaseStats(entityplayer.getUniqueIDString()); // MultiPaper
         if (entityplayer.isPassenger()) {
             Entity entity = entityplayer.getRootVehicle();
 
@@ -661,13 +686,13 @@ public abstract class PlayerList {
         // Paper end
 
         // CraftBukkit start
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[]{entityplayer}));
+        this.sendAll(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.REMOVE_PLAYER, new EntityPlayer[]{entityplayer})); // MultiPaper - Keep original sendAll
         ClientboundPlayerInfoPacket packet = new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.REMOVE_PLAYER, entityplayer);
         for (int i = 0; i < this.players.size(); i++) {
             ServerPlayer entityplayer2 = (ServerPlayer) this.players.get(i);
 
             if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer2.connection.send(packet);
+                // entityplayer2.connection.send(packet); // MultiPaper - Keep original sendAll
             } else {
                 entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
             }
@@ -1015,6 +1040,17 @@ public abstract class PlayerList {
     }
 
     public void broadcastAll(Packet<?> packet) {
+        // MultiPaper start - Intercept ClientboundPlayerInfoPacket packet
+        if (packet instanceof ClientboundPlayerInfoPacket) {
+            MultiPaper.broadcastPacket(packet);
+        }
+
+        broadcastAllNoIntercept(packet);
+    }
+
+    public void broadcastAllNoIntercept(Packet<?> packet) {
+        // MultiPaper end
+
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
@@ -1384,6 +1420,7 @@ public abstract class PlayerList {
 
     public void broadcastMessage(Component message, ChatType type, UUID sender) {
         this.server.sendMessage(message, sender);
+        MultiPaper.broadcastPacket(new PacketPlayOutChat(CraftChatMessage.fixComponent(messages), type, sender)); // MultiPaper
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/net/minecraft/server/players/StoredUserList.java b/src/main/java/net/minecraft/server/players/StoredUserList.java
index 9152c6c9e7e5c8fdb9183c2b4f088a810621b333..8d6f203d4caee6fc03f070aedd1864d80b20618c 100644
--- a/src/main/java/net/minecraft/server/players/StoredUserList.java
+++ b/src/main/java/net/minecraft/server/players/StoredUserList.java
@@ -26,6 +26,7 @@ import net.minecraft.Util;
 import net.minecraft.util.GsonHelper;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
 
@@ -162,7 +163,7 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
         BufferedWriter bufferedwriter = Files.newWriter(this.file, StandardCharsets.UTF_8);
 
         try {
-            StoredUserList.GSON.toJson(jsonarray, bufferedwriter);
+            MultiPaper.writeJson(this.file.getName(), StoredUserList.GSON.toJson(jsonarray)); // StoredUserList.GSON.toJson(jsonarray, bufferedwriter); // MultiPaper
         } catch (Throwable throwable) {
             if (bufferedwriter != null) {
                 try {
@@ -182,11 +183,18 @@ public abstract class StoredUserList<K, V extends StoredUserEntry<K>> {
     }
 
     public void load() throws IOException {
-        if (this.file.exists()) {
-            BufferedReader bufferedreader = Files.newReader(this.file, StandardCharsets.UTF_8);
+        if (true || this.file.exists()) {
+            BufferedReader bufferedreader = null; // Files.newReader(this.file, StandardCharsets.UTF_8); // MultiPaper
+            
+            // MultiPaper start
+            String json = MultiPaper.readJson(this.file.getName());
+            if (json == null || json.isEmpty()) {
+                return;
+            }
+            // MultiPaper end
 
             try {
-                JsonArray jsonarray = (JsonArray) StoredUserList.GSON.fromJson(bufferedreader, JsonArray.class);
+                JsonArray jsonarray = (JsonArray) StoredUserList.GSON.fromJson(json, JsonArray.class); // StoredUserList.GSON.fromJson(bufferedreader, JsonArray.class); // MultiPaper
                 com.google.common.base.Preconditions.checkState(jsonarray != null, "The file \"" + this.file.getName() + "\" is either empty or corrupt"); // Paper
 
                 this.map.clear();
diff --git a/src/main/java/net/minecraft/stats/ServerStatsCounter.java b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
index 9f3355dbbbab1ab88cf2b7034130c2888e38d7a7..17650b6af16dcc46e0b66ec8027dacb3c0e3a0f7 100644
--- a/src/main/java/net/minecraft/stats/ServerStatsCounter.java
+++ b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
@@ -36,6 +36,7 @@ import net.minecraft.world.entity.player.Player;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class ServerStatsCounter extends StatsCounter {
 
@@ -54,6 +55,21 @@ public class ServerStatsCounter extends StatsCounter {
             this.stats.put( wrapper, entry.getValue().intValue() );
         }
         // Spigot end
+        // MultiPaper start
+        if (true) {
+            try {
+                String json = MultiPaper.readStats(this.d.getName().split("\\.")[0]);
+                if (!json.isEmpty()) {
+                    this.a(minecraftserver.getDataFixer(), json);
+                }
+            } catch (IOException ioexception) {
+                ServerStatisticManager.LOGGER.error("Couldn't read statistics file {}", file, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                ServerStatisticManager.LOGGER.error("Couldn't parse statistics file {}", file, jsonparseexception);
+            }
+            return;
+        }
+        // MultiPaper end
         if (file.isFile()) {
             try {
                 this.parseLocal(server.getFixerUpper(), FileUtils.readFileToString(file));
@@ -69,6 +85,12 @@ public class ServerStatsCounter extends StatsCounter {
     public void save() {
         if ( org.spigotmc.SpigotConfig.disableStatSaving ) return; // Spigot
         try {
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writeStats(this.file.getName().split("\\.")[0], this.toJson());
+                return;
+            }
+            // MultiPaper end
             FileUtils.writeStringToFile(this.file, this.toJson());
         } catch (IOException ioexception) {
             ServerStatsCounter.LOGGER.error("Couldn't save stats", ioexception);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index af90013d48e2dd827e045e2fc0f7f5be0dbaa33f..15c740b67bc5de2a5bbca2d5956340f5e19ca244 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -147,6 +147,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, net.minecraft.server.KeyedObject { // Paper
@@ -2982,11 +2983,6 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
                 // CraftBukkit end
 
                 this.level.getProfiler().popPush("reloading");
-                // Paper start - Change lead drop timing to prevent dupe
-                if (this instanceof Mob) {
-                    ((Mob) this).dropLeash(true, true); // Paper drop lead
-                }
-                // Paper end
                 Entity entity = this.getType().create((Level) worldserver);
 
                 if (entity != null) {
@@ -3000,6 +2996,10 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
                     // CraftBukkit start - Forward the CraftEntity to the new entity
                     this.getBukkitEntity().setHandle(entity);
                     entity.bukkitEntity = this.getBukkitEntity();
+
+                    if (this instanceof Mob) {
+                        ((Mob) this).dropLeash(true, true); // Paper drop lead
+                    }
                     // CraftBukkit end
                 }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
index 6c3455823f996e0421975b7f4a00f4e333e9f514..f4877977eea4481ce883f6394d025dde9d253d51 100644
--- a/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/village/poi/PoiManager.java
@@ -6,6 +6,8 @@ import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
+import puregero.multipaper.MultiPaper;
+
 import java.io.File;
 import java.util.Collections;
 import java.util.Comparator;
@@ -292,7 +294,10 @@ public class PoiManager extends SectionStorage<PoiSection> {
             }
             return ret;
         }
-        return super.read(chunkcoordintpair);
+        // MultiPaper start
+        return MultiPaper.readRegionFileNBT(world, "poi", chunkcoordintpair);
+        // return super.read(chunkcoordintpair);
+        // MultiPaper end
     }
 
     @Override
@@ -303,7 +308,10 @@ public class PoiManager extends SectionStorage<PoiSection> {
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
             return;
         }
-        super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper start
+        MultiPaper.writeRegionFileNBT(world, "poi", chunkcoordintpair, nbttagcompound);
+        //super.write(chunkcoordintpair, nbttagcompound);
+        // MultiPaper end
     }
     // Paper end
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index d286d88a3c3f93dbfa92de9421e320c92cd96350..34da23baafa5f4584461dbbbc8e5004fe820fc8e 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -124,6 +124,7 @@ import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.entity.EntityExhaustionEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerVelocityEvent;
+import org.bukkit.util.Vector;
 // CraftBukkit end
 
 public abstract class Player extends LivingEntity {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 870ff060e34de4ec49ad5496e79c2bd543297c41..aabc338374feed6f152a554aaecca687fc77029d 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -100,6 +100,10 @@ import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
+// MultiPaper start
+import puregero.multipaper.MultiPaper;
+// MultiPaper end
+
 public abstract class Level implements LevelAccessor, AutoCloseable {
 
     protected static final Logger LOGGER = LogManager.getLogger();
@@ -265,7 +269,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         });
         // CraftBukkit end
         timings = new co.aikar.timings.WorldTimingsHandler(this); // Paper - code below can generate new world and access timings
-        this.keepSpawnInMemory = this.paperConfig.keepSpawnInMemory; // Paper
+        this.keepSpawnInMemory = false; // this.paperConfig.keepSpawnInMemory; // Paper // MultiPaper - default to false
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
         this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
         this.chunkPacketBlockController = this.paperConfig.antiXray ?
@@ -840,6 +844,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 toRemove.add(tickingblockentity); // Paper - use removeAll
                 // Spigot end
             } else {
+                if (!MultiPaper.shouldTickChunk((ServerLevel) this, getChunkIfLoaded(tickingblockentity.getPosition()))) continue; // MultiPaper - Don't tick this tile entity rn
                 tickingblockentity.tick();
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index f0c537e1d6b32ecde52b3d456f0f3889ff554824..5d292ca81c5d7f516a1902b3a8d9271f4b83b055 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -37,6 +37,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class ProtoChunk implements ChunkAccess {
     private static final Logger LOGGER = LogManager.getLogger();
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index c22391a0d4b7db49bd3994b0887939a7d8019391..f857c2ca9e803adafde5a9b56b784d15aafca730 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -97,6 +97,9 @@ public class RegionFile implements AutoCloseable {
             ((java.nio.Buffer) this.offsets).limit(1024); // CraftBukkit - decompile error
             ((java.nio.Buffer) this.header).position(4096); // CraftBukkit - decompile error
             this.timestamps = this.header.asIntBuffer();
+            // MultiPaper start
+            this.file = null;
+            /*
             if (dsync) {
                 this.file = FileChannel.open(file, StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.DSYNC);
             } else {
@@ -144,6 +147,8 @@ public class RegionFile implements AutoCloseable {
                     }
                 }
             }
+            */
+            // MultiPaper end
 
         }
     }
@@ -422,8 +427,14 @@ public class RegionFile implements AutoCloseable {
         return this.offsets.get(RegionFile.getOffsetIndex(pos));
     }
 
+<<<<<<< HEAD
     public boolean hasChunk(ChunkPos pos) {
         return this.getOffset(pos) != 0;
+=======
+    public boolean chunkExists(ChunkCoordIntPair chunkcoordintpair) {
+        if (true) return true;
+        return this.getOffset(chunkcoordintpair) != 0;
+>>>>>>> MultiPaper initial import commit
     }
 
     private static int getChunkLocation(int x, int z) { return (x & 31) + (z & 31) * 32; } // Paper - OBFHELPER - sort of, mirror of logic below
@@ -432,6 +443,12 @@ public class RegionFile implements AutoCloseable {
     }
 
     public void close() throws IOException {
+        // MultiPaper start
+        if (this.dataFile == null) {
+            this.closed = true;
+            return;
+        }
+        // MultiPaper end
         // Paper start - Prevent regionfiles from being closed during use
         this.fileLock.lock();
         synchronized (this) {
diff --git a/src/main/java/net/minecraft/world/level/saveddata/SavedData.java b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
index 5d60a4ebbd039077c4d2458ac8d8110097eb74a3..ebb867b3d7f0969308b0c408729dc4e7336cb567 100644
--- a/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
+++ b/src/main/java/net/minecraft/world/level/saveddata/SavedData.java
@@ -7,6 +7,7 @@ import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public abstract class SavedData {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -33,6 +34,7 @@ public abstract class SavedData {
             compoundTag.putInt("DataVersion", SharedConstants.getCurrentVersion().getWorldVersion());
 
             try {
+                MultiPaper.writeData(file.getPath(), compoundTag); // MultiPaper
                 NbtIo.writeCompressed(compoundTag, file);
             } catch (IOException var4) {
                 LOGGER.error("Could not save data {}", this, var4);
diff --git a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
index c8ed0673ff819cb88d0ee6f53f2a2b9b46b203d4..975e537ecdd1bdb0352413e272f1f86c3a666372 100644
--- a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -7,6 +7,7 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.PushbackInputStream;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Function;
 import java.util.function.Supplier;
@@ -19,6 +20,7 @@ import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.saveddata.SavedData;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class DimensionDataStorage {
     private static final Logger LOGGER = LogManager.getLogger();
@@ -61,8 +63,11 @@ public class DimensionDataStorage {
     private <T extends SavedData> T readSavedData(Function<CompoundTag, T> function, String id) {
         try {
             File file = this.getDataFile(id);
-            if (file.exists()) {
+            if (true || file.exists()) { // MultiPaper - Always run
                 CompoundTag compoundTag = this.readTagFromDisk(id, SharedConstants.getCurrentVersion().getWorldVersion());
+
+                if (compoundTag == null) return null; // MultiPaper
+
                 return function.apply(compoundTag.getCompound("data"));
             }
         } catch (Exception var5) {
@@ -78,7 +83,14 @@ public class DimensionDataStorage {
 
     public CompoundTag readTagFromDisk(String id, int dataVersion) throws IOException {
         File file = this.getDataFile(id);
-        FileInputStream fileInputStream = new FileInputStream(file);
+        // MultiPaper start
+        byte[] data = MultiPaper.readData(file.getPath());
+        if (data == null || data.length == 0) {
+            return null;
+        }
+        // FileInputStream fileInputStream = new FileInputStream(file);
+        ByteArrayInputStream fileInputStream = new ByteArrayInputStream(data);
+        // MultiPaper end
 
         CompoundTag var8;
         try {
@@ -160,4 +172,10 @@ public class DimensionDataStorage {
 
         });
     }
+
+    // MultiPaper start - save a PersistentBase
+    public void save(PersistentBase persistentbase) {
+        persistentbase.a(this.a(persistentbase.getId()));
+    }
+    // MultiPaper end
 }
diff --git a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
index 5d5d9e812d7774dd0704f3d9d2e1289d546b26c9..ddc05e67dc373999aa864582738023fc18356892 100644
--- a/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
+++ b/src/main/java/net/minecraft/world/level/storage/LevelStorageSource.java
@@ -60,6 +60,7 @@ import net.minecraft.world.level.levelgen.NoiseGeneratorSettings;
 import net.minecraft.world.level.levelgen.WorldGenSettings;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public class LevelStorageSource {
 
@@ -190,7 +191,7 @@ public class LevelStorageSource {
         } else {
             File file1 = new File(file, "level.dat");
 
-            if (file1.exists()) {
+            if (true || file1.exists()) { // MultiPaper
                 T t0 = levelDataParser.apply(file1, this.fixerUpper);
 
                 if (t0 != null) {
@@ -206,7 +207,7 @@ public class LevelStorageSource {
     @Nullable
     private static DataPackConfig getDataPacks(File file, DataFixer datafixer) {
         try {
-            CompoundTag nbttagcompound = NbtIo.readCompressed(file);
+            CompoundTag nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NbtIo.readCompressed(file); // MultiPaper
             CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
 
             nbttagcompound1.remove("Player");
@@ -223,7 +224,7 @@ public class LevelStorageSource {
     static BiFunction<File, DataFixer, PrimaryLevelData> getLevelData(DynamicOps<Tag> dynamicops, DataPackConfig datapackconfiguration) {
         return (file, datafixer) -> {
             try {
-                CompoundTag nbttagcompound = NbtIo.readCompressed(file);
+                CompoundTag nbttagcompound = MultiPaper.readLevel(file.getParentFile().getName()); // NbtIo.readCompressed(file); // MultiPaper
                 CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
                 CompoundTag nbttagcompound2 = nbttagcompound1.contains("Player", 10) ? nbttagcompound1.getCompound("Player") : null;
 
@@ -245,7 +246,7 @@ public class LevelStorageSource {
     BiFunction<File, DataFixer, LevelSummary> levelSummaryReader(File file, boolean locked) {
         return (file1, datafixer) -> {
             try {
-                CompoundTag nbttagcompound = NbtIo.readCompressed(file1);
+                CompoundTag nbttagcompound = MultiPaper.readLevel(file.getName()); // NbtIo.readCompressed(file1); // MultiPaper
                 CompoundTag nbttagcompound1 = nbttagcompound.getCompound("Data");
 
                 nbttagcompound1.remove("Player");
@@ -396,6 +397,13 @@ public class LevelStorageSource {
             nbttagcompound2.put("Data", nbttagcompound1);
 
             try {
+                // MultiPaper start
+                if (true) {
+                    MultiPaper.writeLevel(file.getName(), nbttagcompound2);
+                    return;
+                }
+                // MultiPaper end
+
                 File file1 = File.createTempFile("level", ".dat", file);
 
                 NbtIo.writeCompressed(nbttagcompound2, file1);
diff --git a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
index 6727468946ea5f60bd80549f827a7c2b9a42b98b..864ac275677636d9a496315fc064e36c44575174 100644
--- a/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/PlayerDataStorage.java
@@ -17,6 +17,7 @@ import org.apache.logging.log4j.Logger;
 import java.io.FileInputStream;
 import java.io.InputStream;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public class PlayerDataStorage {
@@ -35,6 +36,14 @@ public class PlayerDataStorage {
         if (org.spigotmc.SpigotConfig.disablePlayerDataSaving) return; // Spigot
         try {
             CompoundTag nbttagcompound = player.saveWithoutId(new CompoundTag());
+
+            // MultiPaper start
+            if (true) {
+                MultiPaper.writePlayer(player.getStringUUID(), nbttagcompound);
+                return;
+            }
+            // MultiPaper end
+
             File file = File.createTempFile(player.getStringUUID() + "-", ".dat", this.playerDir);
 
             NbtIo.writeCompressed(nbttagcompound, file);
@@ -53,6 +62,9 @@ public class PlayerDataStorage {
         CompoundTag nbttagcompound = null;
 
         try {
+            nbttagcompound = MultiPaper.readPlayer(player.getStringUUID()); // MultiPaper
+
+            if (false) { // MultiPaper
             File file = new File(this.playerDir, player.getStringUUID() + ".dat");
             // Spigot Start
             boolean usingWrongFile = false;
@@ -76,12 +88,14 @@ public class PlayerDataStorage {
                 file.renameTo( new File( file.getPath() + ".offline-read" ) );
             }
             // Spigot End
+            } // MultiPaper
         } catch (Exception exception) {
             PlayerDataStorage.LOGGER.warn("Failed to load player data for {}", player.getName().getString());
         }
 
         if (nbttagcompound != null) {
             // CraftBukkit start
+            /* // MultiPlayer
             if (player instanceof ServerPlayer) {
                 CraftPlayer player1 = (CraftPlayer) player.getBukkitEntity();
                 // Only update first played if it is older than the one we have
@@ -91,6 +105,7 @@ public class PlayerDataStorage {
                 }
             }
             // CraftBukkit end
+            */ // MultiPlayer
             int i = nbttagcompound.contains("DataVersion", 3) ? nbttagcompound.getInt("DataVersion") : -1;
 
             player.load(NbtUtils.update(this.fixerUpper, DataFixTypes.PLAYER, nbttagcompound, i));
@@ -102,6 +117,8 @@ public class PlayerDataStorage {
     // CraftBukkit start
     public CompoundTag getPlayerData(String s) {
         try {
+            if (true) return MultiPaper.readPlayer(s); // MultiPaper
+
             File file1 = new File(this.playerDir, s + ".dat");
 
             if (file1.exists()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 8a98bd1018afd934696fedbed24e271ab6b75f51..3b8f476e9291517a5888ca54560b90529c51f46a 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -225,6 +225,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import puregero.multipaper.MultiPaper;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -1586,6 +1587,12 @@ public final class CraftServer implements Server {
 
         message = broadcastMessageEvent.message(); // Paper - Adventure
 
+        // MultiPaper start
+        if (permission.equals(BROADCAST_CHANNEL_USERS)) {
+            MultiPaper.broadcastPacket(null, message);
+        }
+        // MultiPaper end
+
         for (CommandSender recipient : recipients) {
             recipient.sendMessage(message);
         }
@@ -2375,6 +2382,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent component) {
+            MultiPaper.broadcastPacket(null, component); // MultiPaper
+            
             for (Player player : CraftServer.this.getOnlinePlayers()) {
                 player.spigot().sendMessage(component);
             }
@@ -2382,6 +2391,8 @@ public final class CraftServer implements Server {
 
         @Override
         public void broadcast(BaseComponent... components) {
+            MultiPaper.broadcastPacket(null, components); // MultiPaper
+
             for (Player player : CraftServer.this.getOnlinePlayers()) {
                 player.spigot().sendMessage(components);
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 3403b75c8311f1e52a0533363c5f0307442f8a15..7aeb758b9c8c4119a92a9cb75cb0a4c0c0553052 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -521,6 +521,7 @@ public class CraftWorld implements World {
         org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
         if (this.isChunkLoaded(x, z)) {
             this.world.getChunkSource().removeRegionTicket(TicketType.PLUGIN, new ChunkPos(x, z), 0, Unit.INSTANCE); // Paper
+            this.world.getChunkSource().removeRegionTicket(TicketType.PLAYER, new ChunkPos(x, z), 0, new ChunkPos(x, z)); // MultiPaper
         }
 
         return true;
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
index 2fd69c0f915f1c3cb1c410d5dab0498f05d5c888..9b803b658153d31b1b8f8a3e74570c77a6c262b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftCommandMap.java
@@ -4,13 +4,28 @@ import java.util.Map;
 import org.bukkit.Server;
 import org.bukkit.command.Command;
 import org.bukkit.command.SimpleCommandMap;
+import puregero.multipaper.ServersCommand;
 
 public class CraftCommandMap extends SimpleCommandMap {
 
     public CraftCommandMap(Server server) {
         super(server);
+        setDefaultCommands(); // MultiPaper
     }
 
+    // MultiPaper start
+    @Override
+    public void clearCommands() {
+        super.clearCommands();
+
+        setDefaultCommands();
+    }
+
+    private void setDefaultCommands() {
+        register("multipaper", new ServersCommand("servers"));
+    }
+    // MultiPaper end
+
     public Map<String, Command> getKnownCommands() {
         return knownCommands;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 76e2ae09855e0efaaa0856d2f49e4968adbccbdc..ac39f6506ba57f8df15045abb808d0bddd088c39 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -427,11 +427,14 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             name = getName();
         }
         this.getHandle().listName = name.equals(getName()) ? null : CraftChatMessage.fromStringOrNull(name);
-        for (ServerPlayer player : (List<ServerPlayer>) server.getHandle().players) {
-            if (player.getBukkitEntity().canSee(this)) {
-                player.connection.send(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
-            }
-        }
+        // MultiPaper start - Use sendAll
+        getHandle().getMinecraftServer().getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, getHandle()));
+        // for (ServerPlayer player : (List<ServerPlayer>) server.getHandle().players) {
+        //     if (player.getBukkitEntity().canSee(this)) {
+        //         player.connection.send(new ClientboundPlayerInfoPacket(ClientboundPlayerInfoPacket.Action.UPDATE_DISPLAY_NAME, this.getHandle()));
+        //     }
+        // }
+        // MultiPaper end
     }
 
     private net.kyori.adventure.text.Component playerListHeader; // Paper - Adventure
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index a59a449c0a7b76527f009031aee2d11d6b43cadf..a4725a948b22a497d737d12fb297955f58cc5b9a 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -216,6 +216,7 @@ import org.bukkit.inventory.meta.BookMeta;
 import org.bukkit.potion.PotionEffect;
 
 import org.bukkit.event.entity.SpawnerSpawnEvent; // Spigot
+import puregero.multipaper.MultiPaper;
 
 public class CraftEventFactory {
     public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.ON_FIRE);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
index 738100ffa60647790f0921cf31d5bbc2714e27dd..9c33b240d4bb01ad9eed9e5ba17458fd1374e4bf 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/WorldUUID.java
@@ -1,14 +1,10 @@
 package org.bukkit.craftbukkit.util;
 
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
+import java.io.*;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import puregero.multipaper.MultiPaper;
 
 public final class WorldUUID {
 
@@ -18,6 +14,38 @@ public final class WorldUUID {
     }
 
     public static UUID getUUID(File baseDir) {
+    // MultiPaper start
+        DataInputStream dis = null;
+        try {
+            dis = MultiPaper.readUid(baseDir.getName());
+            return new UUID(dis.readLong(), dis.readLong());
+        } catch (IOException ex) {
+            LOGGER.warn("Failed to read " + baseDir.getName() + "'s uid.dat, generating new random UUID", ex);
+        } finally {
+            if (dis != null) {
+                try {
+                    dis.close();
+                } catch (IOException ex) {
+                    // NOOP
+                }
+            }
+        }
+
+        UUID uuid = UUID.randomUUID();
+        try {
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            DataOutputStream dos = new DataOutputStream(baos);
+            dos.writeLong(uuid.getMostSignificantBits());
+            dos.writeLong(uuid.getLeastSignificantBits());
+            MultiPaper.writeUid(baseDir.getName(), baos.toByteArray());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return uuid;
+    }
+
+    public static UUID _getUUID(File baseDir) {
+    // MultiPaper end
         File file1 = new File(baseDir, "uid.dat");
         if (file1.exists()) {
             DataInputStream dis = null;
diff --git a/src/main/java/puregero/multipaper/ChunkKey.java b/src/main/java/puregero/multipaper/ChunkKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..a905eca60fccc47d9f6c9746e760d4322ca66766
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ChunkKey.java
@@ -0,0 +1,33 @@
+package puregero.multipaper;
+
+public class ChunkKey {
+    private final String name;
+    private final int x;
+    private final int z;
+
+    public ChunkKey(String name, int x, int z) {
+        this.name = name;
+        this.x = x;
+        this.z = z;
+    }
+    
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof ChunkKey) {
+            return ((ChunkKey) other).name.equals(name)
+                    && ((ChunkKey) other).x == x
+                    && ((ChunkKey) other).z == z;
+        }
+        
+        return super.equals(other);
+    }
+    
+    @Override
+    public int hashCode() {
+        // Taken from ChunkCoordIntPair
+        int i = 1664525 * this.x + 1013904223;
+        int j = 1664525 * (this.z ^ -559038737) + 1013904223;
+        
+        return name.hashCode() ^ i ^ j;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/DataOutputSender.java b/src/main/java/puregero/multipaper/DataOutputSender.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b042efc6942050dc290001eafc0f97f0917ce82
--- /dev/null
+++ b/src/main/java/puregero/multipaper/DataOutputSender.java
@@ -0,0 +1,30 @@
+package puregero.multipaper;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.util.function.Consumer;
+
+public class DataOutputSender extends DataOutputStream {
+    private final MultiPaperConnection connection;
+    private final int id;
+
+    public DataOutputSender(MultiPaperConnection connection) throws IOException {
+        this(connection, (int) (Math.random() * Integer.MAX_VALUE));
+    }
+
+    public DataOutputSender(MultiPaperConnection connection, int id) throws IOException {
+        super(new ByteArrayOutputStream());
+        this.connection = connection;
+        this.id = id;
+
+        writeInt(id);
+    }
+
+    public void send(@Nullable Consumer<DataInputStream> callback) throws IOException {
+        connection.send(((ByteArrayOutputStream) out).toByteArray(), id, callback);
+    }
+
+    public int getId() {
+        return id;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ExternalServer.java b/src/main/java/puregero/multipaper/ExternalServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a35379f75384aaf7b31d74ecbd5c801179d980b
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalServer.java
@@ -0,0 +1,58 @@
+package puregero.multipaper;
+
+import java.util.ArrayList;
+import java.util.UUID;
+
+public class ExternalServer {
+    private final String name;
+    private final boolean me;
+    private int averageTickTime;
+    private double tps;
+    private long lastAlive;
+    private ArrayList<UUID> players = new ArrayList<>();
+
+    public ExternalServer(String name, boolean me) {
+        this.name = name;
+        this.me = me;
+    }
+
+    public int getAverageTickTime() {
+        return averageTickTime;
+    }
+
+    public void setAverageTickTime(int averageTickTime) {
+        this.averageTickTime = averageTickTime;
+    }
+
+    public long getLastAlive() {
+        return lastAlive;
+    }
+
+    public void setLastAlive(long lastAlive) {
+        this.lastAlive = lastAlive;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public boolean isMe() {
+        return me;
+    }
+
+    public boolean isAlive() {
+        return getLastAlive() > System.currentTimeMillis() - 2500 && getTps() > 0;
+    }
+
+    public ArrayList<UUID> getPlayers() {
+        return players;
+    }
+
+    public double getTps() {
+        return tps;
+    }
+
+    public void setTps(double tps) {
+        this.tps = tps;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..279e5e4d1f96884b23e1646eebbc399e1e47b851
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -0,0 +1,392 @@
+package puregero.multipaper;
+
+import net.kyori.adventure.text.Component;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.minecraft.SystemUtils;
+import net.minecraft.nbt.NBTCompressedStreamTools;
+import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.network.chat.ChatMessageType;
+import net.minecraft.network.chat.IChatBaseComponent;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.PacketPlayOutChat;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.EntityPlayer;
+import net.minecraft.server.level.WorldServer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.level.ChunkCoordIntPair;
+import net.minecraft.world.level.chunk.Chunk;
+import net.minecraft.world.level.saveddata.maps.PersistentIdCounts;
+import net.minecraft.world.level.saveddata.maps.WorldMap;
+import net.minecraft.world.level.storage.WorldPersistentData;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Player;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class MultiPaper {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private static MultiPaperConnection multiPaperConnection = null;
+    private static long last10Seconds = System.currentTimeMillis();
+    private static MultiPaperPlugin plugin = null;
+
+    public static MultiPaperConnection getConnection() {
+        if (multiPaperConnection == null) {
+            multiPaperConnection = new MultiPaperConnection();
+        }
+
+        return multiPaperConnection;
+    }
+
+    private static void tick() {
+        if (plugin == null) {
+            plugin = new MultiPaperPlugin();
+            new MultiPaperListener(plugin);
+        }
+        
+        boolean hasBeen10Seconds = last10Seconds < System.currentTimeMillis() - 10 * 1000;
+
+        if (hasBeen10Seconds) last10Seconds = System.currentTimeMillis();
+        
+        checkIfPlayersNeedToBeMoved();
+
+        Bukkit.getWorlds().forEach(world -> {
+            WorldPersistentData persistentData = ((CraftWorld) world).getHandle().getWorldPersistentData();
+            persistentData.data.values().forEach(value -> {
+                if (value != null && (value instanceof PersistentIdCounts || (value instanceof WorldMap && hasBeen10Seconds))) {
+                    persistentData.save(value);
+                }
+            });
+        });
+    }
+
+    private static void checkIfPlayersNeedToBeMoved() {
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            if (player.getLastLogin() < System.currentTimeMillis() - 5 * 1000L) {
+                String server = Zone.getServer(player.getLocation());
+
+                if (server != null) {
+                    Zone.doMerge(player, server);
+                }
+            }
+        }
+    }
+
+    public static NBTTagCompound readChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) throws IOException {
+        return readRegionFileNBT(worldServer, "region", chunkcoordintpair);
+    }
+
+    public static void writeChunk(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer, NBTTagCompound nbttagcompound) throws IOException {
+        writeRegionFileNBT(worldServer, "region", chunkcoordintpair, nbttagcompound);
+    }
+
+    public static DataInput readRegionFile(String world, String path, int cx, int cz) throws IOException {
+        while (true) {
+            try {
+                return getConnection().readChunk(world, path, cx, cz).get(15, TimeUnit.SECONDS);
+            } catch (InterruptedException | ExecutionException e) {
+                throw new IOException(e);
+            } catch (TimeoutException e) {
+                if (DedicatedServer.getServer().hasStopped()) {
+                    LOGGER.info("No response for readRegionFile " + world + "," + path + "," + cx + "," + cz + ", but server has stopped, aborting operation.");
+                    return null;
+                }
+                LOGGER.info("No response for readRegionFile " + world + "," + path + "," + cx + "," + cz + ", resending...");
+            }
+        }
+    }
+
+    public static void writeRegionFile(String world, String path, int cx, int cz, byte[] bytes) throws IOException {
+        getConnection().writeChunk(world, path, cx, cz, bytes);
+    }
+
+    public static NBTTagCompound readRegionFileNBT(WorldServer worldServer, String path, ChunkCoordIntPair chunkcoordintpair) throws IOException {
+        DataInput in = readRegionFile(worldServer.worldDataServer.getName(), path, chunkcoordintpair.x, chunkcoordintpair.z);
+
+        return in == null ? null : NBTCompressedStreamTools.a(in);
+    }
+
+    public static void writeRegionFileNBT(WorldServer worldServer, String path, ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
+        writeRegionFile(worldServer.worldDataServer.getName(), path, chunkcoordintpair.x, chunkcoordintpair.z, nbtToBytes(nbttagcompound));
+    }
+
+    public static NBTTagCompound readLevel(String world) throws IOException {
+        DataInput in = getConnection().readLevel(world).join();
+
+        return in == null ? null : NBTCompressedStreamTools.a((InputStream) in);
+    }
+
+    public static void writeLevel(String world, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writeLevel(world, nbtCompressToBytes(nbttagcompound));
+    }
+
+    public static String readJson(String name) throws IOException {
+        return getConnection().readJson(name).join();
+    }
+
+    public static void writeJson(String name, String json) throws IOException {
+        getConnection().writeJson(name, json);
+    }
+
+    public static NBTTagCompound readPlayer(String uuid) throws IOException {
+        DataInput in = getConnection().readPlayer(uuid).join();
+
+        return in == null ? null : NBTCompressedStreamTools.a((InputStream) in);
+    }
+
+    public static void writePlayer(String uuid, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writePlayer(uuid, nbtCompressToBytes(nbttagcompound));
+    }
+
+    public static void lockPlayer(String uuid) {
+        try {
+            getConnection().lockPlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releasePlayer(String uuid) {
+        try {
+            getConnection().releasePlayer(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static DataInputStream readUid(String world) throws IOException {
+        return getConnection().readUid(world).join();
+    }
+
+    public static void writeUid(String world, byte[] data) throws IOException {
+        getConnection().writeUid(world, data);
+    }
+
+    public static void willSaveChunk(World world, int cx, int cz) {
+        try {
+            getConnection().willSaveChunk(world.getName(), cx, cz);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void willSaveChunk(org.bukkit.Chunk chunk) {
+        willSaveChunk(chunk.getWorld(), chunk.getX(), chunk.getZ());
+    }
+
+    public static void notifyChunkNotSaving(ChunkCoordIntPair chunkcoordintpair, WorldServer worldServer) {
+        try {
+            getConnection().notifyChunkNotSaving(worldServer.worldDataServer.getName(), chunkcoordintpair.x, chunkcoordintpair.z);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void sendTickTime(long time) {
+        tick();
+        try {
+            getConnection().writeTickTime(time);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readAdvancements(String uuid) throws IOException {
+        return getConnection().readAdvancements(uuid).join();
+    }
+
+    public static void writeAdvancements(String uuid, String json) throws IOException {
+        getConnection().writeAdvancements(uuid, json);
+    }
+
+    public static void lockAdvancements(String uuid) {
+        try {
+            getConnection().lockAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseAdvancements(String uuid) {
+        try {
+            getConnection().releaseAdvancements(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static String readStats(String uuid) throws IOException {
+        return getConnection().readStats(uuid).join();
+    }
+
+    public static void writeStats(String uuid, String json) throws IOException {
+        getConnection().writeStats(uuid, json);
+    }
+
+    public static void lockStats(String uuid) {
+        try {
+            getConnection().lockStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void releaseStats(String uuid) {
+        try {
+            getConnection().releaseStats(uuid);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(Packet<?> packet) {
+        try {
+            getConnection().broadcastPacket(packet);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void broadcastPacket(UUID from, String message) {
+        if (from == null) {
+            from = SystemUtils.getNullUUID();
+        }
+
+        for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
+            broadcastPacket(new PacketPlayOutChat(component, from.equals(SystemUtils.getNullUUID()) ? ChatMessageType.SYSTEM : ChatMessageType.CHAT, from));
+        }
+    }
+
+    public static void broadcastPacket(UUID from, BaseComponent... components) {
+        if (from == null) {
+            from = SystemUtils.getNullUUID();
+        }
+
+        PacketPlayOutChat packet = new PacketPlayOutChat(null, from.equals(SystemUtils.getNullUUID()) ? ChatMessageType.SYSTEM : ChatMessageType.CHAT, SystemUtils.b);
+        packet.components = components;
+        broadcastPacket(packet);
+    }
+
+    public static void broadcastPacket(UUID from, Component message) {
+        if (from == null) {
+            from = SystemUtils.getNullUUID();
+        }
+
+        PacketPlayOutChat packet = new PacketPlayOutChat(null, from.equals(SystemUtils.getNullUUID()) ? ChatMessageType.SYSTEM : ChatMessageType.CHAT, SystemUtils.b);
+        packet.adventure$message = message;
+        broadcastPacket(packet);
+    }
+
+    public static void onStart() {
+        try {
+            getConnection().sendStart();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static byte[] readData(String path) {
+        if (path.contains("raids.dat")) {
+            // Don't load raids from dist
+            return null;
+        }
+        
+        try {
+            return getConnection().readData(path).join();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public static void writeData(String path, NBTTagCompound nbttagcompound) throws IOException {
+        getConnection().writeData(path, nbtCompressToBytes(nbttagcompound));
+    }
+
+    private static byte[] nbtToBytes(NBTTagCompound nbttagcompound) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) new DataOutputStream(buffer));
+        return buffer.toByteArray();
+    }
+
+    private static byte[] nbtCompressToBytes(NBTTagCompound nbttagcompound) throws IOException {
+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+        NBTCompressedStreamTools.a(nbttagcompound, buffer);
+        return buffer.toByteArray();
+    }
+
+    public static String getBungeeCordName() throws IOException {
+        File file = new File("bungeecordname.txt");
+        if (!file.isFile()) {
+            Files.write(file.toPath(), ("server" + Double.toString(Math.random()).substring(2, 7)).getBytes());
+        }
+        return new String(Files.readAllBytes(file.toPath())).trim();
+    }
+
+    public static ExternalServer getMe() {
+        return multiPaperConnection.getServersMap().get(multiPaperConnection.getBungeeCordName());
+    }
+
+    public static Iterable<ExternalServer> getServers() {
+        return multiPaperConnection.getServersMap().values();
+    }
+
+    public static Location getPlayerLocation(UUID uuid) {
+        return multiPaperConnection.playerLocations.get(uuid);
+    }
+
+    public static int chunkDistance(Entity entity1, Entity entity2) {
+        return chunkDistance(entity1.chunkX, entity1.chunkZ, entity2.chunkX, entity2.chunkZ);
+    }
+
+    public static int chunkDistance(Location loc1, Location loc2) {
+        return chunkDistance(loc1.getBlockX() >> 4, loc1.getBlockZ() >> 4, loc2.getBlockX() >> 4, loc2.getBlockZ() >> 4);
+    }
+
+    public static int chunkDistance(Entity entity, Chunk chunk) {
+        return chunkDistance(entity.chunkX, entity.chunkZ, chunk.getPos().x, chunk.getPos().z);
+    }
+
+    public static int chunkDistance(int cx1, int cz1, int cx2, int cz2) {
+        return Math.max(Math.abs(cx1 - cx2), Math.abs(cz1 - cz2));
+    }
+
+    public static boolean shouldTickEntity(WorldServer worldServer, Entity entity) {
+        return shouldTickChunk(worldServer, entity.getCurrentChunk());
+    }
+
+    public static boolean shouldTickChunk(WorldServer worldServer, Chunk chunk) {
+        if (chunk == null) {
+            return false;
+        }
+
+        boolean playerNearby = false;
+        
+        for (EntityPlayer player : worldServer.players) {
+            if (chunkDistance(player, chunk) <= Bukkit.getViewDistance() * 2) {
+                playerNearby = true;
+                if (player.shouldTickEntities) {
+                    return true;
+                }
+            }
+        }
+
+        return !playerNearby;
+    }
+
+    public static void setPlayerShouldTickEntities(Player player, boolean shouldTickEntities) {
+        ((CraftPlayer) player).getHandle().shouldTickEntities = shouldTickEntities;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..426b80b4113c87e5d138736b337a1ba8db0b84f9
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -0,0 +1,708 @@
+package puregero.multipaper;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.PacketDataSerializer;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.PacketPlayOutPlayerInfo;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.EntityPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.*;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+
+import javax.annotation.Nullable;
+import java.io.*;
+import java.net.Socket;
+import java.net.SocketException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.*;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.InflaterInputStream;
+
+public class MultiPaperConnection extends Thread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private Socket socket;
+    private HashMap<Integer, Request> callbacks = new HashMap<>();
+    private HashMap<String, ExternalServer> serversMap = new HashMap<>();
+    private String myName = null;
+    private WriterWorkerThread writer = new WriterWorkerThread(() -> socket);
+    public HashMap<UUID, Location> playerLocations = new HashMap<>();
+
+    public MultiPaperConnection() {
+        super("MultiPaperConnection Thread");
+        start();
+    }
+
+    public void send(byte[] bytes, int id, @Nullable Consumer<DataInputStream> callback) {
+        Request request = new Request(bytes, callback);
+        if (callback != null) {
+            callbacks.put(id, request);
+        }
+        writer.write(request);
+    }
+
+    public DataOutputSender buffer(int id) throws IOException {
+        return new DataOutputSender(this, id);
+    }
+
+    private static String getServer() {
+        try {
+            File file = new File("multipaperserver.txt");
+            if (!file.isFile()) {
+                Files.write(file.toPath(), ("localhost:35353").getBytes());
+            }
+            return new String(Files.readAllBytes(file.toPath())).trim();
+        } catch (IOException e) {
+            e.printStackTrace();
+            return "localhost:35353";
+        }
+    }
+
+    @Override
+    public void run() {
+        while (true) {
+            String server = getServer();
+            LOGGER.info("Connecting to " + server + "...");
+            String[] serverParts = server.split(":");
+            try (Socket socket = new Socket(serverParts[0], Integer.parseInt(serverParts[1]))) {
+                DataOutputStream out = new DataOutputStream(socket.getOutputStream());
+                out.writeUTF(myName = MultiPaper.getBungeeCordName());
+                
+                this.socket = socket;
+                LOGGER.info("Connected to " + server);
+
+                synchronized (socket) {
+                    // Resend requests on this new socket
+                    for (Request request : callbacks.values()) {
+                        if (request.setLastSocket(socket)) {
+                            socket.getOutputStream().write(request.getData());
+                        }
+                    }
+                }
+
+                DataInputStream in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
+                while (!socket.isClosed()) {
+                    int id = in.readInt();
+                    String command = in.readUTF();
+
+                    Request request = callbacks.remove(id);
+
+                    if (request != null) {
+                        request.getCallback().accept(in);
+                        continue;
+                    }
+
+                    // Run command(DataInputStream in);
+                    this.getClass().getMethod(command, DataInputStream.class, DataOutputSender.class).invoke(this, in, buffer(id));
+                }
+            } catch (EOFException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+
+    public void loadJson(DataInputStream in, DataOutputSender out) throws IOException {
+        String file = in.readUTF();
+        LOGGER.info("Reloading json " + file);
+        new Thread(() -> {
+            try {
+                if (DedicatedServer.getServer() == null) {
+                    return;
+                }
+
+                switch (file) {
+                    case "banned-players.json":
+                        DedicatedServer.getServer().getPlayerList().getProfileBans().load();
+                        checkBans();
+                        break;
+                    case "banned-ips.json":
+                        DedicatedServer.getServer().getPlayerList().getIPBans().load();
+                        break;
+                    case "ops.json":
+                        DedicatedServer.getServer().getPlayerList().getOPs().load();
+                        break;
+                    case "whitelist.json":
+                        DedicatedServer.getServer().getPlayerList().getWhitelist().load();
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Invalid json file to load " + file);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }).start();
+    }
+
+    private String p(long n, String s){
+        if(n != 1)return n + " " + s + "s";
+        return n + " " + s;
+    }
+    public String prettyTime(long millis){
+        long seconds = millis/1000;
+        if(seconds >= 60*60*24)
+            return p(seconds/60/60/24,"day") + " and " + p((seconds/60/60)%24,"hour");
+        if(seconds >= 60*60)
+            return p(seconds/60/60,"hour") + " and " + p((seconds/60)%60,"minute");
+        if(seconds >= 60)
+            return p(seconds/60,"minute") + " and " + p((seconds)%60,"second");
+        return p(seconds,"second");
+    }
+    private void checkBans() {
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            BanEntry b = Bukkit.getBanList(BanList.Type.NAME).getBanEntry(player.getName());
+            if (b != null) {
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(() -> {
+                    Date expire = b.getExpiration();
+                    if (expire != null) {
+                        long t = (expire.getTime() - System.currentTimeMillis());
+                        if (t < 0) return; // Ban expired
+                        player.kickPlayer("You have been banned for:\n" + b.getReason() + "\nYour ban will end in " + prettyTime(t));
+                    } else {
+                        player.kickPlayer("You have been banned for:\n" + b.getReason());
+                    }
+                }, 0, "MultiPaper-KickPlayer");
+            }
+        }
+    }
+
+    public void savePlayer(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.saveData();
+        }
+        out.writeUTF("wrotePlayer");
+        out.send(null);
+    }
+
+    public void saveAdvancements(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getAdvancementData().b(); // Saves world/advancements
+        }
+        out.writeUTF("wroteAdvancements");
+        out.send(null);
+    }
+
+    public void saveStats(DataInputStream in, DataOutputSender out) throws IOException {
+        UUID uuid = UUID.fromString(in.readUTF());
+        CraftPlayer player = (CraftPlayer) Bukkit.getPlayer(uuid);
+        if (player != null) {
+            player.getHandle().getStatisticManager().save(); // Saves world/stats
+        }
+        out.writeUTF("wroteStats");
+        out.send(null);
+    }
+
+    public void serverInfo(DataInputStream in, DataOutputSender out) throws IOException {
+        ExternalServer server = serversMap.computeIfAbsent(in.readUTF(), key -> new ExternalServer(key, key.equals(myName)));
+        server.setAverageTickTime(in.readInt());
+        server.setLastAlive(System.currentTimeMillis());
+    }
+
+    public void broadcastPacket(DataInputStream in, DataOutputSender out) throws IOException {
+        try {
+            String className = in.readUTF();
+            int length = in.readInt();
+            ByteBuf buf = Unpooled.buffer(length, length);
+            int i;
+            while ((i = buf.writeBytes(in, length)) < length) {
+                length -= i;
+            }
+            Packet<?> packet = (Packet<?>) Class.forName(className).getConstructor().newInstance();
+            packet.a(new PacketDataSerializer(buf));
+            if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
+                DedicatedServer.getServer().getPlayerList().sendAllNoIntercept(packet);
+            }
+
+            if (packet instanceof PacketPlayOutPlayerInfo) {
+                PlayerInfoManager.handle((PacketPlayOutPlayerInfo) packet);
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void clearData(DataInputStream in, DataOutputSender out) throws IOException {
+        String pathStr = in.readUTF();
+        File path = new File(pathStr);
+        String file = path.getName().substring(0, path.getName().length() - 4); // Remove .dat suffix
+        while (!path.getParentFile().equals(new File(".")) && !path.getParentFile().equals(path)) {
+            path = path.getParentFile();
+        }
+
+        World world = Bukkit.getWorld(path.getName());
+        if (world == null) {
+            throw new IllegalArgumentException("Unknown world '" + path.getPath() + "' in path " + pathStr);
+        }
+
+        // Clear the data from the world's data cache
+        ((CraftWorld) world).getHandle().getWorldPersistentData().data.remove(file);
+    }
+
+    public void playerList(DataInputStream in, DataOutputSender out) throws IOException {
+        serversMap.values().forEach(server -> server.getPlayers().clear());
+        playerLocations.clear();
+
+        String server;
+        while (!(server = in.readUTF()).isEmpty()) {
+            ExternalServer externalServer = serversMap.get(server);
+
+            double tps = in.readDouble();
+            if (externalServer != null) {
+                externalServer.setTps(tps);
+            }
+
+            int count = in.readInt();
+            for (int i = 0; i < count; i++) {
+                UUID uuid = new UUID(in.readLong(), in.readLong());
+                String world = in.readUTF();
+                double x = in.readDouble();
+                double y = in.readDouble();
+                double z = in.readDouble();
+                float yaw = in.readFloat();
+                float pitch = in.readFloat();
+
+                if (Bukkit.getServer() != null) {
+                    playerLocations.put(uuid, new Location(Bukkit.getWorld(world), x, y, z, yaw, pitch));
+                }
+
+                if (externalServer != null) {
+                    externalServer.getPlayers().add(uuid);
+                }
+            }
+        }
+
+        if (Bukkit.getServer() == null || MinecraftServer.getServer() == null) {
+            out.writeUTF("playerList");
+            out.writeDouble(20);
+            out.writeInt(0);
+            out.send(null);
+        } else if (!MinecraftServer.getServer().isStopped()) {
+            Collection<? extends Player> players = Bukkit.getOnlinePlayers();
+            out.writeUTF("playerList");
+            out.writeDouble(MinecraftServer.getServer().recentTps[0]);
+            out.writeInt(players.size());
+            for (Player player : players) {
+                out.writeLong(player.getUniqueId().getMostSignificantBits());
+                out.writeLong(player.getUniqueId().getLeastSignificantBits());
+                out.writeUTF(player.getWorld().getName());
+                out.writeDouble(player.getLocation().getX());
+                out.writeDouble(player.getLocation().getY());
+                out.writeDouble(player.getLocation().getZ());
+                out.writeFloat(player.getLocation().getYaw());
+                out.writeFloat(player.getLocation().getPitch());
+            }
+            out.send(null);
+        }
+
+        sendLoadedChunkList();
+    }
+
+    public void chunkData(DataInputStream in, DataOutputSender out) throws IOException {
+        int length = in.readInt();
+        in.skipBytes(length);
+        LOGGER.info("Unsolicited chunk data of length: " + length + " bytes");
+    }
+
+    public void lockedChunk(DataInputStream in, DataOutputSender out) throws IOException {
+        String locker = in.readUTF();
+        LOGGER.info("Unsolicited locked chunk with locker: " + (locker.length() == 0 ? "null" : locker));
+    }
+
+    public void start(DataInputStream in, DataOutputSender out) throws IOException {
+        if (DedicatedServer.getServer() != null && DedicatedServer.getServer().getPlayerList() != null) {
+            MultiPaper.broadcastPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, DedicatedServer.getServer().getPlayerList().players.toArray(new EntityPlayer[0])));
+        }
+    }
+
+    public CompletableFuture<DataInputStream> readChunk(String world, String path, int cx, int cz) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        AtomicBoolean hasReturned = new AtomicBoolean(false);
+
+        Consumer<DataInputStream> callback = in -> {
+            try {
+                hasReturned.set(true);
+
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        };
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(callback);
+
+        return future;
+    }
+
+    public void writeChunk(String world, String path, int cx, int cz, byte[] data) throws IOException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        DeflaterOutputStream deflateOut = new DeflaterOutputStream(baos);
+        deflateOut.write(data);
+        deflateOut.close();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeChunk");
+        out.writeUTF(world);
+        out.writeUTF(path);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeInt(baos.size());
+        out.write(baos.toByteArray());
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readLevel(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readLevel");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeLevel(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeLevel");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<String> readJson(String name) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readJson");
+        out.writeUTF(name);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeJson(String name, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeJson");
+        out.writeUTF(name);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public CompletableFuture<DataInputStream> readPlayer(String uuid) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readPlayer");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writePlayer(String uuid, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writePlayer");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockPlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockPlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releasePlayer(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releasePlayer");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<DataInputStream> readUid(String world) throws IOException {
+        CompletableFuture<DataInputStream> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readUid");
+        out.writeUTF(world);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data.length == 0 ? null : new DataInputStream(new ByteArrayInputStream(data)));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeUid(String world, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeUid");
+        out.writeUTF(world);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void writeTickTime(long time) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeTickTime");
+        out.writeLong(time);
+        out.send(null);
+    }
+
+    public void willSaveChunk(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("willSaveChunk");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public void notifyChunkNotSaving(String world, int cx, int cz) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkNotSaving");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readAdvancements(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readAdvancements");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeAdvancements(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeAdvancements");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseAdvancements(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseAdvancements");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public CompletableFuture<String> readStats(String uuid) throws IOException {
+        CompletableFuture<String> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readStats");
+        out.writeUTF(uuid);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(new String(data, StandardCharsets.UTF_8));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeStats(String uuid, String json) throws IOException {
+        byte[] data = json.getBytes(StandardCharsets.UTF_8);
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeStats");
+        out.writeUTF(uuid);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    public void lockStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("lockStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void releaseStats(String uuid) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("releaseStats");
+        out.writeUTF(uuid);
+        out.send(null);
+    }
+
+    public void broadcastPacket(Packet<?> packet) throws IOException {
+        ByteBuf buf = Unpooled.buffer();
+        packet.b(new PacketDataSerializer(buf));
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("broadcastPacket");
+        out.writeUTF(packet.getClass().getName());
+        out.writeInt(buf.readableBytes());
+        buf.readBytes(out, buf.readableBytes());
+        out.send(null);
+    }
+
+    public void sendStart() throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("start");
+        out.send(null);
+    }
+
+    public CompletableFuture<byte[]> readData(String path) throws IOException {
+        CompletableFuture<byte[]> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("readData");
+        out.writeUTF(path);
+        out.send(in -> {
+            try {
+                byte[] data = new byte[in.readInt()];
+                in.readFully(data);
+
+                future.complete(data);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
+
+    public void writeData(String path, byte[] data) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("writeData");
+        out.writeUTF(path);
+        out.writeInt(data.length);
+        out.write(data);
+        out.send(in -> { /* Do nothing */ });
+    }
+
+    private void sendLoadedChunkList() throws IOException {
+        if (Bukkit.getServer() != null) {
+            List<Chunk> chunks = new ArrayList<>();
+
+            for (World world : Bukkit.getWorlds()) {
+                chunks.addAll(Arrays.asList(world.getLoadedChunks()));
+            }
+
+            DataOutputSender out = new DataOutputSender(this);
+            out.writeUTF("loadedChunkList");
+            out.writeInt(chunks.size());
+
+            for (Chunk chunk : chunks) {
+                out.writeUTF(chunk.getWorld().getName());
+                out.writeInt(chunk.getX());
+                out.writeInt(chunk.getZ());
+            }
+
+            out.send(null);
+        }
+    }
+
+    public HashMap<String, ExternalServer> getServersMap() {
+        return serversMap;
+    }
+
+    public String getBungeeCordName() {
+        return myName;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperListener.java b/src/main/java/puregero/multipaper/MultiPaperListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..e928cae02d9f3327b998a2e98effb71cea5d0efa
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperListener.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.Listener;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.event.player.PlayerKickEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.plugin.Plugin;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+
+public class MultiPaperListener implements Listener {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private final Plugin plugin;
+
+    public MultiPaperListener(Plugin plugin) {
+        this.plugin = plugin;
+        Bukkit.getPluginManager().registerEvents(this, plugin);
+    }
+
+    private HashSet<Player> kickedPlayers = new HashSet<>();
+    
+    @EventHandler(priority = EventPriority.LOWEST)
+    public void onPlayerQuit(PlayerQuitEvent e) {
+        if (!kickedPlayers.remove(e.getPlayer())) {
+            willSaveChunks(e.getPlayer());
+        }
+    }
+
+    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
+    public void onPlayerQuit(PlayerKickEvent e) {
+        willSaveChunks(e.getPlayer());
+        kickedPlayers.add(e.getPlayer());
+    }
+
+    /**
+     * Mark the loaded chunks around the player as will be saved
+     * @param player Player to mark the chunks around
+     */
+    private void willSaveChunks(Player player) {
+        Zone zone = new Zone(player.getWorld(), player.getLocation().getBlockX() >> 4, player.getLocation().getBlockZ() >> 4);
+        zone.forEach(MultiPaper::willSaveChunk);
+    }
+    
+    private static final List<PlayerTeleportEvent.TeleportCause> teleportCauseCanMoveServers = Arrays.asList(
+            PlayerTeleportEvent.TeleportCause.COMMAND,
+            PlayerTeleportEvent.TeleportCause.PLUGIN,
+            PlayerTeleportEvent.TeleportCause.SPECTATE
+    );
+    
+    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
+    public void onTeleport(PlayerTeleportEvent e) {
+        if ((e.getTo().getWorld() != e.getFrom().getWorld() || e.getTo().distanceSquared(e.getFrom()) > 16 * 16)
+                && teleportCauseCanMoveServers.contains(e.getCause())) {
+            Bukkit.getScheduler().runTaskLater(plugin, () -> Zone.checkIfShouldMerge(e.getPlayer()), 0);
+        }
+    }
+    
+    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
+    public void onEntityPortal(EntityPortalEvent e) {
+        String server = Zone.getServer(e.getTo());
+        if (server != null) {
+            LOGGER.info("Disabling EntityPortalEvent{" + e.getEntity() + "," + e.getFrom() + " -> " + e.getTo() + "} as the other side is within " + server + "'s zone");
+            e.setCancelled(true);
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/MultiPaperPlugin.java b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d5a221f54bb25dbf7ddedb30979576bf5204754
--- /dev/null
+++ b/src/main/java/puregero/multipaper/MultiPaperPlugin.java
@@ -0,0 +1,129 @@
+package puregero.multipaper;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+import java.util.logging.Logger;
+
+public class MultiPaperPlugin implements Plugin {
+    
+    private JavaPluginLoader loader = new JavaPluginLoader(Bukkit.getServer());
+
+    @Override
+    public @NotNull File getDataFolder() {
+        return null;
+    }
+
+    @Override
+    public @NotNull PluginDescriptionFile getDescription() {
+        return new PluginDescriptionFile(getName(), Bukkit.getVersion(), getClass().getName());
+    }
+
+    @Override
+    public @NotNull FileConfiguration getConfig() {
+        return null;
+    }
+
+    @Override
+    public @Nullable InputStream getResource(@NotNull String filename) {
+        return null;
+    }
+
+    @Override
+    public void saveConfig() {
+
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+
+    }
+
+    @Override
+    public void saveResource(@NotNull String resourcePath, boolean replace) {
+
+    }
+
+    @Override
+    public void reloadConfig() {
+
+    }
+
+    @Override
+    public @NotNull PluginLoader getPluginLoader() {
+        return loader;
+    }
+
+    @Override
+    public @NotNull Server getServer() {
+        return null;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return true;
+    }
+
+    @Override
+    public void onDisable() {
+
+    }
+
+    @Override
+    public void onLoad() {
+
+    }
+
+    @Override
+    public void onEnable() {
+        
+    }
+
+    @Override
+    public boolean isNaggable() {
+        return false;
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+
+    }
+
+    @Override
+    public @Nullable ChunkGenerator getDefaultWorldGenerator(@NotNull String worldName, @Nullable String id) {
+        return null;
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        return null;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        return "MultiPaper";
+    }
+
+    @Override
+    public boolean onCommand(@NotNull CommandSender sender, @NotNull Command command, @NotNull String label, @NotNull String[] args) {
+        return false;
+    }
+
+    @Override
+    public @Nullable List<String> onTabComplete(@NotNull CommandSender sender, @NotNull Command command, @NotNull String alias, @NotNull String[] args) {
+        return null;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/PlayerInfoManager.java b/src/main/java/puregero/multipaper/PlayerInfoManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b0c670aa1f05f04ae8de8717893d5ebef825242
--- /dev/null
+++ b/src/main/java/puregero/multipaper/PlayerInfoManager.java
@@ -0,0 +1,62 @@
+package puregero.multipaper;
+
+import net.minecraft.network.protocol.game.PacketPlayOutPlayerInfo;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.EntityPlayer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+
+import java.util.HashMap;
+import java.util.UUID;
+
+public class PlayerInfoManager {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static HashMap<UUID, PacketPlayOutPlayerInfo.PlayerInfoData> playerInfos = new HashMap<>();
+
+    public static void handle(PacketPlayOutPlayerInfo packet) {
+        for (PacketPlayOutPlayerInfo.PlayerInfoData info : packet.getPlayerInfoDatas()) {
+            UUID uuid = info.a().getId();
+
+            if (packet.getAction() == PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER) {
+                playerInfos.put(uuid, info);
+                continue;
+            }
+
+            if (packet.getAction() == PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER) {
+                CraftPlayer player = Bukkit.getServer() == null ? null : (CraftPlayer) Bukkit.getPlayer(uuid);
+                if (player != null) {
+                    DedicatedServer.getServer().getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, player.getHandle()));
+                }
+
+                playerInfos.remove(uuid);
+                continue;
+            }
+
+            PacketPlayOutPlayerInfo.PlayerInfoData infoData = playerInfos.get(uuid);
+
+            if (infoData == null) {
+                continue;
+            }
+
+            if (info.b != 0) {
+                infoData.b = info.b;
+            }
+
+            if (info.c != null) {
+                infoData.c = info.c;
+            }
+
+            if (info.e != null) {
+                infoData.e = info.e;
+            }
+        }
+    }
+
+    public static void send(EntityPlayer player) {
+        player.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(playerInfos.values()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/Request.java b/src/main/java/puregero/multipaper/Request.java
new file mode 100644
index 0000000000000000000000000000000000000000..47f33a3aee0b5332bd4a3819d2fbe5ed23a07109
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Request.java
@@ -0,0 +1,42 @@
+package puregero.multipaper;
+
+import java.io.DataInputStream;
+import java.net.Socket;
+import java.util.function.Consumer;
+
+public class Request {
+    private Socket lastSocket;
+    private final byte[] data;
+    private final Consumer<DataInputStream> callback;
+    private final long time = System.currentTimeMillis();
+
+    public Request(byte[] data, Consumer<DataInputStream> callback) {
+        this.data = data;
+        this.callback = callback;
+    }
+
+    public byte[] getData() {
+        return data;
+    }
+
+    public Consumer<DataInputStream> getCallback() {
+        return callback;
+    }
+
+    public long getTime() {
+        return time;
+    }
+
+    /**
+     * @return True if the socket is not the same as the last socket, false
+     * otherwise
+     */
+    public synchronized boolean setLastSocket(Socket socket) {
+        if (socket == lastSocket) {
+            return false;
+        }
+        
+        lastSocket = socket;
+        return true;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ServersCommand.java b/src/main/java/puregero/multipaper/ServersCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6f77bfe0b0d11c4e312d73aa5021ebe97e0db8f
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ServersCommand.java
@@ -0,0 +1,42 @@
+package puregero.multipaper;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class ServersCommand extends Command {
+    public ServersCommand(String command) {
+        super(command);
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        sender.sendMessage(ChatColor.GRAY + "[Servers] (Avg Tick Time / Tps / Player Count)");
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            String tickTime = Integer.toString(server.getAverageTickTime()) + "ms";
+            if (server.getAverageTickTime() < 40) {
+                tickTime = ChatColor.GREEN + tickTime;
+            } else if (server.getAverageTickTime() < 50) {
+                tickTime = ChatColor.YELLOW + tickTime;
+            } else {
+                tickTime = ChatColor.RED + tickTime;
+            }
+
+            String tpsString = String.format("%.1f tps", server.getTps());
+
+            String playersString = server.getPlayers().size() + " player";
+            if (server.getPlayers().size() != 1) {
+                playersString += "s";
+            }
+
+            if (!server.isAlive()) {
+                sender.sendMessage(ChatColor.DARK_GRAY + "[" + server.getName() + "] " + server.getAverageTickTime() + "ms, " + tpsString + ", " + playersString);
+            } else {
+                sender.sendMessage(ChatColor.GREEN + "[" + (server.isMe() ? ChatColor.GOLD : "") + server.getName() + ChatColor.GREEN + "] " + tickTime + ", " + tpsString + ", " + playersString);
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ShutdownHandler.java b/src/main/java/puregero/multipaper/ShutdownHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..1bb2afccaeff7644026846f0ba3cda25062ee945
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ShutdownHandler.java
@@ -0,0 +1,63 @@
+package puregero.multipaper;
+
+import net.minecraft.server.MinecraftServer;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+
+public class ShutdownHandler {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static void onStop() {
+        markServerAsOffline();
+        savePlayers();
+        movePlayersToDifferentServer();
+    }
+
+    private static void markServerAsOffline() {
+        MultiPaper.sendTickTime(-1);
+    }
+
+    private static void savePlayers() {
+        if (MinecraftServer.getServer().getPlayerList() != null) {
+            MinecraftServer.getServer().getPlayerList().savePlayers();
+        }
+    }
+
+    private static void movePlayersToDifferentServer() {
+        HashSet<Player> moved = new HashSet<>();
+
+        for (Player player : Bukkit.getOnlinePlayers()) {
+            if (moved.contains(player)) {
+                continue;
+            }
+
+            String server = randomServer();
+
+            if (server == null) {
+                LOGGER.info("No other servers are online, disconnecting players instead");
+                return;
+            }
+
+            moved.addAll(Zone.doMerge(player, server));
+        }
+    }
+
+    private static String randomServer() {
+        List<String> servers = new ArrayList<>();
+
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server != MultiPaper.getMe() && server.isAlive()) {
+                servers.add(server.getName());
+            }
+        }
+
+        return servers.isEmpty() ? null : servers.get((int) (Math.random() * servers.size()));
+    }
+}
diff --git a/src/main/java/puregero/multipaper/WriterWorkerThread.java b/src/main/java/puregero/multipaper/WriterWorkerThread.java
new file mode 100644
index 0000000000000000000000000000000000000000..310dd44d77fdb51e8feea6b3d80b32ebb5dd8d29
--- /dev/null
+++ b/src/main/java/puregero/multipaper/WriterWorkerThread.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.LinkedList;
+import java.util.Queue;
+import java.util.function.Supplier;
+
+public class WriterWorkerThread extends Thread {
+
+    private static final int MAX_QUEUE_SIZE = 16;
+    
+    private final Supplier<Socket> socketSupplier;
+    private final Queue<Request> queue = new LinkedList<>();
+
+    public WriterWorkerThread(Supplier<Socket> socketSupplier) {
+        super("WriterWorkerThread");
+        this.socketSupplier = socketSupplier;
+        start();
+    }
+    
+    public void write(Request request) {
+        while (true) {
+            synchronized (queue) {
+                // MultiPaperConnection gets priority in the queue, it mustn't block otherwise the connection can stall
+                if (queue.size() < MAX_QUEUE_SIZE || Thread.currentThread() instanceof MultiPaperConnection) {
+                    queue.add(request);
+                    queue.notify();
+                    return;
+                }
+            }
+
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                return;
+            }
+        }
+    }
+    
+    public void run() {
+        Request toWrite;
+        
+        while (true) {
+            synchronized (queue) {
+                while (queue.isEmpty()) {
+                    try {
+                        queue.wait();
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                        return;
+                    }
+                }
+
+                toWrite = queue.poll();
+            }
+
+            try {
+                Socket socket = socketSupplier.get();
+
+                if (toWrite.setLastSocket(socket)) {
+                    synchronized (socket) {
+                        socket.getOutputStream().write(toWrite.getData());
+                        socket.getOutputStream().flush();
+                    }
+                }
+            } catch (NullPointerException | SocketException e) {
+                // Ignored
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+    
+}
diff --git a/src/main/java/puregero/multipaper/Zone.java b/src/main/java/puregero/multipaper/Zone.java
new file mode 100644
index 0000000000000000000000000000000000000000..794f61347671df8edb2fe2fac6673172890b1ef6
--- /dev/null
+++ b/src/main/java/puregero/multipaper/Zone.java
@@ -0,0 +1,181 @@
+package puregero.multipaper;
+
+import net.kyori.adventure.text.Component;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+public class Zone implements Iterable<Chunk> {
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private static List<Consumer<Chunk>> chunkSaveHandlers = new ArrayList<>();
+
+    public static void registerChunkSaveHandler(Consumer<Chunk> handler) {
+        chunkSaveHandlers.add(handler);
+    }
+
+    public static Collection<Player> doMerge(Player centerPlayer, String server) {
+        HashSet<Player> players = new HashSet<>();
+
+        recursivelyAddPlayersInSameZone(players, centerPlayer);
+        
+        LOGGER.info("Merging " + players.size() + " players with server " + server);
+
+        for (Player player : players) {
+            ((CraftPlayer) player).getHandle().isBeingSentToAnotherServer = true;
+            player.kick(Component.text("sendto:" + server));
+
+            if (player.getLocation().isChunkLoaded()) {
+                // Attempt to unload the player's chunk first to make teleporting faster
+                Chunk c = player.getChunk();
+                ((CraftScheduler) Bukkit.getScheduler()).scheduleInternalTask(c::unload, 0, "Unload Chunk");
+            }
+        }
+
+        return players;
+    }
+    
+    public static boolean inSameZone(Location location1, Location location2) {
+        return MultiPaper.chunkDistance(location1, location2) <= (12 + Bukkit.getViewDistance()) * 2;
+    }
+
+    public static String getServer(Location location) {
+        for (ExternalServer server : MultiPaper.getConnection().getServersMap().values()) {
+            if (server.isAlive() && !server.isMe()) {
+                for (UUID uuid : server.getPlayers()) {
+                    Location loc = MultiPaper.getConnection().playerLocations.get(uuid);
+                    if (Bukkit.getPlayer(uuid) == null && loc != null && loc.getWorld() == location.getWorld()
+                            && Zone.inSameZone(loc, location)) {
+                        return server.getName();
+                    }
+                }
+            }
+        }
+        
+        return null;
+    }
+
+    public static boolean checkIfShouldMerge(Player player) {
+        String serverAtLocation = getServer(player.getLocation());
+        
+        if (serverAtLocation != null) {
+            Zone.doMerge(player, serverAtLocation);
+            return true;
+        }
+        
+        ExternalServer serverTo = MultiPaper.getMe();
+
+        // Find server with lowest average tick time
+        for (ExternalServer server : MultiPaper.getServers()) {
+            if (server.getAverageTickTime() < serverTo.getAverageTickTime() - 2 &&
+                    server.isAlive()) {
+                serverTo = server;
+            }
+        }
+
+        if (serverTo.isMe()) {
+            // Can't merge with yourself
+            return false;
+        }
+        
+        HashSet<Player> players = new HashSet<>();
+        
+        recursivelyAddPlayersInSameZone(players, player);
+        
+        if (players.size() == 1) {
+            Zone.doMerge(player, serverTo.getName());
+            return true;
+        }
+        
+        return false;
+    }
+
+    private static void recursivelyAddPlayersInSameZone(HashSet<Player> players, Player player) {
+        if (players.add(player)) {
+            for (Player p : player.getWorld().getPlayers()) {
+                if (p != player && inSameZone(p.getLocation(), player.getLocation())) {
+                    recursivelyAddPlayersInSameZone(players, p);
+                }
+            }
+        }
+    }
+
+    private final HashSet<Chunk> chunks = new HashSet<>();
+    private final HashSet<Player> players = new HashSet<>();
+    private final int chunkLimit;
+
+    public Zone(Chunk chunk) {
+        this(chunk, Integer.MAX_VALUE);
+    }
+
+    public Zone(Chunk chunk, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(chunk);
+        mapPlayers(chunk.getWorld());
+    }
+
+    public Zone(World world, int cx, int cz) {
+        this(world, cx, cz, Integer.MAX_VALUE);
+    }
+
+    public Zone(World world, int cx, int cz, int chunkLimit) {
+        this.chunkLimit = chunkLimit;
+        mapChunks(world, cx, cz);
+        mapPlayers(world);
+    }
+
+    private void mapChunks(Chunk chunk) {
+        if (chunks.contains(chunk)) {
+            return;
+        }
+
+        if (chunk.isLoaded()) {
+            chunks.add(chunk);
+        }
+
+        if (chunks.size() > chunkLimit) {
+            return;
+        }
+
+        mapChunks(chunk.getWorld(), chunk.getX(), chunk.getZ());
+    }
+
+    private void mapChunks(World world, int cx, int cz) {
+        if (world == null) {
+            return;
+        }
+        
+        for (int dx = -4; dx <= 4; dx ++) {
+            for (int dz = -4; dz <= 4; dz ++) {
+                if (world.isChunkLoaded(cx + dx, cz + dz)) {
+                    mapChunks(world.getChunkAt(cx + dx, cz + dz));
+                }
+                
+            }
+        }
+    }
+
+    private void mapPlayers(World world) {
+        for (Player player : world.getPlayers()) {
+            if (chunks.contains(player.getChunk())) {
+                players.add(player);
+            }
+        }
+    }
+
+    @NotNull
+    @Override
+    public Iterator<Chunk> iterator() {
+        return chunks.iterator();
+    }
+}
