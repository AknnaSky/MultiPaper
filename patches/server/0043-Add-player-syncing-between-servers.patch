From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Mon, 15 Nov 2021 20:30:35 +1000
Subject: [PATCH] Add player syncing between servers


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 4eadc15f747528b59349f095171dd5a649a46ed9..f0af73aa7c17de5cad5c9c7c560b8ead9e5ee1a9 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -22,6 +22,8 @@ import net.minecraft.server.level.TicketType;
 import net.minecraft.util.Mth;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
+import puregero.multipaper.ExternalPlayer;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
@@ -448,6 +450,8 @@ public final class PlayerChunkLoader {
 
             this.chunkSendWaitQueue.pollFirst();
 
+            if (data.player instanceof ExternalPlayer) continue; // MultiPaper - don't send chunks to ExternalPlayers
+
             this.chunkSendQueue.add(data);
         }
 
@@ -867,6 +871,10 @@ public final class PlayerChunkLoader {
             this.player.needsChunkCenterUpdate = true;
             this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
             this.player.needsChunkCenterUpdate = false;
+
+            // MultiPaper start - Don't load chunks for an ExternalPlayer, but do broadcast changes to us
+            if (this.player instanceof ExternalPlayer) return;
+
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index eaa005c1c9b4386bcdbe1d6eb28c3eca7635066c..ee7f65f94c71654da22c413219fc43742d323cd8 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -13,14 +13,7 @@ import java.io.File;
 import java.net.SocketAddress;
 import java.nio.file.Path;
 import java.text.SimpleDateFormat;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
 import java.util.function.Function;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
@@ -119,6 +112,7 @@ import org.bukkit.event.player.PlayerJoinEvent;
 import org.bukkit.event.player.PlayerLoginEvent;
 import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -325,6 +319,7 @@ public abstract class PlayerList {
         if (!networkmanager.isConnected()) {
             return;
         }
+        MultiPaper.onPlayerJoin(player); // MultiPaper
         player.didPlayerJoinEvent = true;
         // Paper end
         TranslatableComponent chatmessage;
@@ -690,6 +685,8 @@ public abstract class PlayerList {
         this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
         // CraftBukkit end
 
+        MultiPaper.onPlayerDisconnect(entityplayer); // MultiPaper
+
         return entityplayer.didPlayerJoinEvent ? playerQuitEvent.quitMessage() : null; // CraftBukkit // Paper - Adventure // Paper - don't print quit if we never printed join
     }
 
@@ -1009,6 +1006,20 @@ public abstract class PlayerList {
         this.sendPlayerPermissionLevel(player, i);
     }
 
+    // MultiPaper start - Add player manually
+    public void addPlayer(ServerPlayer player) {
+        players.add(player);
+        playersByUUID.put(player.getUUID(), player);
+        playersByName.put(player.getScoreboardName().toLowerCase(Locale.ROOT), player);
+    }
+
+    public void removePlayer(ServerPlayer player) {
+        players.remove(player);
+        playersByUUID.remove(player.getUUID());
+        playersByName.remove(player.getScoreboardName().toLowerCase(Locale.ROOT));
+    }
+    // MultiPaper end
+
     public void tick() {
         if (++this.sendAllPlayerInfoIn > 600) {
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index aac9dd19237d0708990960d03328e7530cd7bc8e..58fdc7257858b3494aef290a5c029ffcef4e2089 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -147,6 +147,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import puregero.multipaper.MultiPaper;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, net.minecraft.server.KeyedObject { // Paper
@@ -196,7 +197,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
     protected static final Logger LOGGER = LogManager.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
-    private static final AtomicInteger ENTITY_COUNTER = new AtomicInteger();
+    private static final AtomicInteger ENTITY_COUNTER = new AtomicInteger(MultiPaper.getEntityCounterStartValue()); // MultiPape - Change start value
     private static final List<ItemStack> EMPTY_LIST = Collections.emptyList();
     public static final int BOARDING_COOLDOWN = 60;
     public static final int TOTAL_AIR_SUPPLY = 300;
@@ -494,8 +495,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
     public int sectionZ = Integer.MIN_VALUE;
     // Paper end
 
+    // MultiPaper start - New next id functionality
+    public int getNextId() {
+        return Entity.ENTITY_COUNTER.addAndGet(256);
+    }
+    // MultiPaper end
+
     public Entity(EntityType<?> type, Level world) {
-        this.id = Entity.ENTITY_COUNTER.incrementAndGet();
+        this.id = getNextId(); // MultiPaper - New id getter
         this.passengers = ImmutableList.of();
         this.deltaMovement = Vec3.ZERO;
         this.bb = Entity.INITIAL_AABB;
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe7ac552211558c40d10a739a1d719a426d85d6d
--- /dev/null
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -0,0 +1,76 @@
+package puregero.multipaper;
+
+import com.mojang.authlib.GameProfile;
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.minecraft.network.Connection;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+
+import javax.annotation.Nullable;
+import java.util.UUID;
+
+public class ExternalPlayer extends ServerPlayer {
+
+    private static final Logger LOGGER = LogManager.getLogger(ExternalPlayer.class.getSimpleName());
+    private static int nextId = -1;
+    public ExternalServerConnection externalServerConnection;
+
+    public static void create(ExternalServerConnection externalServerConnection, int id, String name, UUID uuid, String world, double x, double y, double z) {
+        nextId = id;
+        new ExternalPlayer(externalServerConnection, name, uuid, world, x, y, z);
+    }
+
+    @Override
+    public int getNextId() {
+        if (nextId == -1) {
+            LOGGER.warn("Tried to get the next id for ExternalPlayer, but it's -1");
+            return super.getNextId();
+        }
+        int id = nextId;
+        nextId = -1;
+        return id;
+    }
+
+    public ExternalPlayer(ExternalServerConnection externalServerConnection, String name, UUID uuid, String world, double x, double y, double z) {
+        super(((CraftServer) Bukkit.getServer()).getServer(), ((CraftWorld) Bukkit.getWorld(world)).getHandle(), new GameProfile(uuid, name));
+        this.externalServerConnection = externalServerConnection;
+        this.isRealPlayer = true;
+        this.didPlayerJoinEvent = true;
+        connection = new ServerGamePacketListenerImpl(getServer(), new ExternalPlayerConnection(PacketFlow.CLIENTBOUND), this);
+        setPos(x, y, z);
+        getServer().getPlayerList().addPlayer(this);
+        level.addEntity(this, CreatureSpawnEvent.SpawnReason.CUSTOM);
+        containerMenu.transferTo(containerMenu, getBukkitEntity());
+        initInventoryMenu();
+    }
+
+    private class ExternalPlayerConnection extends Connection {
+        public ExternalPlayerConnection(PacketFlow side) {
+            super(side);
+        }
+
+        @Override
+        public void setReadOnly() {
+            // Do nothing
+        }
+ 
+        @Override
+        public boolean isConnected() {
+            return true;
+        }
+
+        @Override
+        public void send(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> callback) {
+
+        }
+    }
+}
diff --git a/src/main/java/puregero/multipaper/ExternalServerConnection.java b/src/main/java/puregero/multipaper/ExternalServerConnection.java
index 73c721e4e11c8a0f13f1af8e5e289531da38a56d..896729fec75279642df2879d50125935c31e4ca2 100644
--- a/src/main/java/puregero/multipaper/ExternalServerConnection.java
+++ b/src/main/java/puregero/multipaper/ExternalServerConnection.java
@@ -1,10 +1,13 @@
 package puregero.multipaper;
 
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerPlayer;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import java.io.*;
 import java.net.Socket;
+import java.util.UUID;
 
 public class ExternalServerConnection extends Thread implements Closeable {
 
@@ -44,6 +47,35 @@ public class ExternalServerConnection extends Thread implements Closeable {
                     LOGGER.info("Connected to external server " + name);
                     externalServer = MultiPaper.getConnection().getServersMap().computeIfAbsent(name, key -> new ExternalServer(key, key.equals(MultiPaper.getBungeeCordName())));
                     externalServer.setConnection(this);
+                } else if (message.equals("createPlayer")) {
+                    int id = in.readInt();
+                    String name = in.readUTF();
+                    UUID uuid = new UUID(in.readLong(), in.readLong());
+                    String world = in.readUTF();
+                    double x = in.readDouble();
+                    double y = in.readDouble();
+                    double z = in.readDouble();
+                    MultiPaper.runSync(() -> ExternalPlayer.create(this, id, name, uuid, world, x, y, z));
+                } else if (message.equals("removePlayer")) {
+                    int id = in.readInt();
+                    ServerPlayer player = getPlayerById(id);
+                    MultiPaper.runSync(() -> player.connection.disconnect("Disconnected from external server"));
+                } else if (message.equals("movePlayer")) {
+                    int id = in.readInt();
+                    double x = in.readDouble();
+                    double y = in.readDouble();
+                    double z = in.readDouble();
+                    float yaw = in.readFloat();
+                    float pitch = in.readFloat();
+                    ServerPlayer player = getPlayerById(id);
+                    if (player != null) {
+                        MultiPaper.runSync(() -> {
+                            player.moveTo(x, y, z, yaw, pitch);
+                            player.getLevel().getChunkSource().move(player);
+                        });
+                    } else {
+                        LOGGER.warn("Tried to move a non-existant player with entity id of " + id);
+                    }
                 }
             }
         } catch (EOFException e) {
@@ -59,6 +91,66 @@ public class ExternalServerConnection extends Thread implements Closeable {
         } catch (Exception e) {
             // Ignore
         }
+
+        for (ServerPlayer player : DedicatedServer.getServer().getPlayerList().players) {
+            if (player instanceof ExternalPlayer && ((ExternalPlayer) player).externalServerConnection == this) {
+                MultiPaper.runSync(() -> player.connection.disconnect("External server disconnected"));
+            }
+        }
+    }
+
+    private ServerPlayer getPlayerById(int id) {
+        for (ServerPlayer player : DedicatedServer.getServer().getPlayerList().players) {
+            if (player.getId() == id) {
+                return player;
+            }
+        }
+        return null;
+    }
+
+    public void sendPlayerCreate(ServerPlayer player) {
+        try {
+            PacketBuffer buffer = new PacketBuffer(socket);
+            buffer.writeUTF("createPlayer");
+            buffer.writeInt(player.getId());
+            buffer.writeUTF(player.getScoreboardName());
+            buffer.writeLong(player.getUUID().getMostSignificantBits());
+            buffer.writeLong(player.getUUID().getLeastSignificantBits());
+            buffer.writeUTF(player.level.getWorld().getName());
+            buffer.writeDouble(player.getX());
+            buffer.writeDouble(player.getY());
+            buffer.writeDouble(player.getZ());
+            buffer.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void sendPlayerRemove(ServerPlayer player) {
+        try {
+            PacketBuffer buffer = new PacketBuffer(socket);
+            buffer.writeUTF("removePlayer");
+            buffer.writeInt(player.getId());
+            buffer.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void sendPlayerMove(ServerPlayer player) {
+        try {
+            PacketBuffer buffer = new PacketBuffer(socket);
+            buffer.writeUTF("movePlayer");
+            buffer.writeInt(player.getId());
+            buffer.writeDouble(player.getX());
+            buffer.writeDouble(player.getY());
+            buffer.writeDouble(player.getZ());
+            buffer.writeFloat(player.getYRot());
+            buffer.writeFloat(player.getXRot());
+            buffer.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
     }
 
     private static class PacketBuffer extends DataOutputStream {
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index e3d29fd5be7d86d4c3127573160ce02a6666e66b..d7ae0669ef10e1994c02fa8a9510c3d1f5ba8292 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,10 +1,21 @@
 package puregero.multipaper;
 
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.level.ServerPlayer;
+
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.util.HashMap;
+import java.util.UUID;
 
 public class MultiPaper {
+    // You'll want to increase this if you have more than 250 servers
+    // The bits in this value should be all 1s to optimize hashmaps and the like
+    // Eg 255 is 0b11111111
+    private static final int ENTITY_COUNTER_INCREMENT = 255;
+
     private static MultiPaperConnection multiPaperConnection = null;
     private static ExternalServerSocket externalServerSocket = null;
 
@@ -32,9 +43,33 @@ public class MultiPaper {
         return bungeeCordName;
     }
 
+    public static void runSync(Runnable runnable) {
+        MinecraftServer.getServer().scheduleOnMain(runnable);
+    }
+
+    private static HashMap<UUID, Double> lastLocations = new HashMap<UUID, Double>();
+
+    public static void tick() {
+        for (ServerPlayer player : DedicatedServer.getServer().getPlayerList().players) {
+            if (!(player instanceof ExternalPlayer)) {
+                double location = player.getX() + player.getY() * 7 + player.getZ() * 49;
+                if (location != lastLocations.getOrDefault(player.getUUID(), 0D)) {
+                    getConnection().getServersMap().values().forEach(externalServer -> {
+                        if (externalServer.getConnection() != null) {
+                            externalServer.getConnection().sendPlayerMove(player);
+                        }
+                    });
+                    lastLocations.put(player.getUUID(), location);
+                }
+            }
+        }
+    }
+
     public static void sendTickTime(long time) {
         try {
             getConnection().writeTickTime(time);
+
+            tick();
         } catch (IOException e) {
             e.printStackTrace();
         }
@@ -48,4 +83,34 @@ public class MultiPaper {
             e.printStackTrace();
         }
     }
+
+    public static void onPlayerJoin(ServerPlayer player) {
+        getConnection().getServersMap().values().forEach(externalServer -> {
+            if (externalServer.getConnection() != null) {
+                externalServer.getConnection().sendPlayerCreate(player);
+            }
+        });
+    }
+
+    public static void onPlayerDisconnect(ServerPlayer player) {
+        if (!(player instanceof ExternalPlayer)) {
+            getConnection().getServersMap().values().forEach(externalServer -> {
+                if (externalServer.getConnection() != null) {
+                    externalServer.getConnection().sendPlayerRemove(player);
+                }
+            });
+        }
+    }
+
+    public static int getEntityCounterStartValue() {
+        try {
+            return getConnection().getEntityCounterStartValue().join();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static int getEntityCounterIncrement() {
+        return ENTITY_COUNTER_INCREMENT;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index aeeffab321999a6e0c03dafc8dfd04effa3948f1..3d19e69add10e8a6a8305d9b651f30cbf4034c12 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -155,4 +155,20 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(port);
         out.send(null);
     }
+
+    public CompletableFuture<Integer> getEntityCounterStartValue() throws IOException {
+        CompletableFuture<Integer> future = new CompletableFuture<>();
+
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("getEntityCounterStartValue");
+        out.send(in -> {
+            try {
+                future.complete(in.readInt());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+
+        return future;
+    }
 }
