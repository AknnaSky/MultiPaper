From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Fri, 3 Dec 2021 00:46:03 +1000
Subject: [PATCH] Sync chunks getting upgraded


diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index ea23603358539d6b4931bbe1dec8b06a8d71306b..c0a2e42074733e63ea7a768648b00d6e33a7a869 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -761,6 +761,32 @@ public class ChunkHolder {
         this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(chunk.getWrapped())), "replaceProto");
     }
 
+    // MultiPaper start
+    public void replaceProtoChunk(ChunkAccess protoChunk) {
+        if (protoChunk instanceof ImposterProtoChunk imposterProtoChunk) {
+            protoChunk = imposterProtoChunk.getWrapped();
+        }
+
+        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> eitherFail = Either.right(new ChunkHolder.ChunkLoadingFailure() {
+            public String toString() {
+                return "Unloaded ticket level " + ChunkHolder.this.pos;
+            }
+        });
+
+        for (int i = protoChunk.getStatus().getIndex() + 1; i < this.futures.length(); ++i) {
+            this.futures.set(i, CompletableFuture.completedFuture(eitherFail));
+        }
+
+        Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure> either = Either.left(protoChunk);
+
+        for (int i = 0; i <= protoChunk.getStatus().getIndex(); ++i) {
+            this.futures.set(i, CompletableFuture.completedFuture(either));
+        }
+
+        this.updateChunkToSave(CompletableFuture.completedFuture(Either.left(protoChunk)), "replaceProtoWithProto");
+    }
+    // MultiPaper end
+
     @FunctionalInterface
     public interface LevelChangeListener {
 
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 5eeb75670d884c0be360bb5d12c99d334b08b84c..c3bfbeb232cfb8d7ab031424a74139e98ce15974 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1247,6 +1247,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         return this.protoChunkToFullChunk(holder);
                     }, list, false);
 
+                    MultiPaper.chunkChangedStatus(level, chunkcoordintpair, requiredStatus); // MultiPaper
+
                     this.progressListener.onStatusChange(chunkcoordintpair, requiredStatus);
                     return completablefuture1;
                 } catch (Exception exception) {
diff --git a/src/main/java/puregero/multipaper/MultiPaper.java b/src/main/java/puregero/multipaper/MultiPaper.java
index eb5e38063ac84a90982c3a60e367b5b116bccbf8..562d0d51c959dc0d4c8d53b1808dce9c77cf1907 100644
--- a/src/main/java/puregero/multipaper/MultiPaper.java
+++ b/src/main/java/puregero/multipaper/MultiPaper.java
@@ -1,6 +1,7 @@
 package puregero.multipaper;
 
 import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
 import net.minecraft.network.protocol.game.*;
@@ -12,6 +13,7 @@ import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.HumanoidArm;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkStatus;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.saveddata.maps.MapIndex;
@@ -42,6 +44,7 @@ public class MultiPaper {
 
     public final static ConcurrentHashMap<ChunkKey, ExternalServer> chunkOwnerToSet = new ConcurrentHashMap<>();
     public final static ConcurrentHashMap<ChunkKey, HashSet<ExternalServer>> chunkSubscribersToSet = new ConcurrentHashMap<>();
+    public final static ConcurrentHashMap<ChunkKey, Runnable> reloadChunks = new ConcurrentHashMap<>();
     private static MultiPaperConnection multiPaperConnection = null;
     private static ExternalServerSocket externalServerSocket = null;
     public static boolean levelDatNeedsSaving = false;
@@ -116,6 +119,11 @@ public class MultiPaper {
                 player.tickAttackStrength();
             }
         }
+
+        reloadChunks.entrySet().removeIf(entry -> {
+            entry.getValue().run();
+            return true;
+        });
     }
 
     public static void sendTickTime(long time, double tps) {
@@ -434,4 +442,12 @@ public class MultiPaper {
             }
         });
     }
+
+    public static void chunkChangedStatus(ServerLevel level, ChunkPos pos, ChunkStatus status) {
+        try {
+            getConnection().sendChunkChangedStatus(level.convertable.getLevelId(), pos.x, pos.z, Registry.CHUNK_STATUS.getKey(status).toString());
+        } catch (IOException e) {
+            e.printStackTrace();
+        };
+    }
 }
diff --git a/src/main/java/puregero/multipaper/MultiPaperConnection.java b/src/main/java/puregero/multipaper/MultiPaperConnection.java
index 89b51127fbc849fafa14c02d2192c7a9ad2d5632..a7c71664c642196227643e29a40ab52e8fc3b65b 100644
--- a/src/main/java/puregero/multipaper/MultiPaperConnection.java
+++ b/src/main/java/puregero/multipaper/MultiPaperConnection.java
@@ -1,6 +1,8 @@
 package puregero.multipaper;
 
+import net.minecraft.core.Registry;
 import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.entity.Entity;
@@ -14,6 +16,7 @@ import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftWorld;
 import puregero.multipaper.externalserverprotocol.EntityUpdateNBTPacket;
 import puregero.multipaper.externalserverprotocol.EntityUpdateWithDependenciesPacket;
+import puregero.multipaper.externalserverprotocol.RequestChunkPacket;
 
 import javax.annotation.Nullable;
 import java.io.*;
@@ -215,14 +218,7 @@ public class MultiPaperConnection extends Thread {
             if (server != null && chunk.getStatus() != ChunkStatus.FULL) {
                 // A server has locked the chunk, which means their chunk must be full.
                 // Let's redownload their full copy
-//                server.getConnection().requestChunk(world, cx, cz, null);
-                MultiPaper.runSync(() -> {
-                    if (Bukkit.getWorld(world).unloadChunk(cx, cz, false)) {
-                        LOGGER.info("Unloaded chunk " + world + "," + cx + "," + cz + " as someone has a full copy");
-                    } else {
-                        LOGGER.warn("Failed to unload chunk " + world + "," + cx + "," + cz + " due to someone having a full copy");
-                    }
-                });
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
             }
         }
     }
@@ -307,6 +303,24 @@ public class MultiPaperConnection extends Thread {
         });
     }
 
+    public void chunkChangedStatus(DataInputStream in, DataOutputSender out) throws IOException {
+        String world = in.readUTF();
+        int cx = in.readInt();
+        int cz = in.readInt();
+        String statusString = in.readUTF();
+        ExternalServer server = getOrCreateServer(in.readUTF());
+        ChunkStatus status = Registry.CHUNK_STATUS.get(new ResourceLocation(statusString));
+
+        if (!server.isMe()) {
+            ChunkAccess chunk = MultiPaper.getChunkAccess(world, cx, cz);
+            if (chunk == null) {
+                LOGGER.warn("Received a chunk change status notification for an unloaded chunk " + world + ";" + cx + ";" + cz + " from " + server.getName());
+            } else if (!chunk.getStatus().isOrAfter(status)) {
+                MultiPaper.reloadChunks.put(new ChunkKey(world, cx, cz), () -> server.getConnection().send(new RequestChunkPacket(world, cx, cz)));
+            }
+        }
+    }
+
     public void writeTickTime(long time, double tps) throws IOException {
         DataOutputSender out = new DataOutputSender(this);
         out.writeUTF("writeTickTime");
@@ -662,4 +676,14 @@ public class MultiPaperConnection extends Thread {
         out.writeInt(cz);
         out.send(null);
     }
+
+    public void sendChunkChangedStatus(String world, int cx, int cz, String resource) throws IOException {
+        DataOutputSender out = new DataOutputSender(this);
+        out.writeUTF("chunkChangedStatus");
+        out.writeUTF(world);
+        out.writeInt(cx);
+        out.writeInt(cz);
+        out.writeUTF(resource);
+        out.send(null);
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
index 315103b7ffa10afb3bb5a81e9b42d55ef4a9ac7c..bc1403e6c5c44007d8e6a9af28e7094380c78824 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/SendChunkPacket.java
@@ -2,8 +2,11 @@ package puregero.multipaper.externalserverprotocol;
 
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.level.ChunkHolder;
+import net.minecraft.server.level.ChunkMap;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.chunk.ImposterProtoChunk;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.storage.ChunkSerializer;
@@ -79,14 +82,16 @@ public class SendChunkPacket extends ExternalServerPacket {
             } else {
                 CompoundTag tag = NbtIo.read(new DataInputStream(new InflaterInputStream(new ByteArrayInputStream(data))));
                 ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
-                LevelChunk chunk = level.getChunkIfLoaded(cx, cz);
-                if (chunk != null) {
-                    ChunkSerializer.InProgressChunkHolder holder = ChunkSerializer.loadChunk(level, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
-                    LevelChunk newChunk = ((ImposterProtoChunk) holder.protoChunk).getWrapped();
-                    newChunk.externalOwner = chunk.externalOwner;
-                    newChunk.externalSubscribers = chunk.externalSubscribers;
-                    newChunk.playerChunk = chunk.playerChunk;
-                    MultiPaper.runSync(newChunk::loadCallback);
+                ChunkMap chunkMap = level.chunkSource.chunkMap;
+                ChunkHolder holder = MultiPaper.getChunkHolder(world, cx, cz);
+                if (holder == null) {
+                    LOGGER.info("Received chunk data " + world + "," + cx + "," + cz + " but no chunk is loaded here");
+                } else if (holder.getAvailableChunkNow() instanceof LevelChunk) {
+                    LOGGER.info("Received chunk data " + world + "," + cx + "," + cz + " but it is a level chunk (" + holder.getChunkHolderStatus() + ")");
+                } else {
+                    ChunkSerializer.InProgressChunkHolder newChunk = ChunkSerializer.loadChunk(level, level.getPoiManager(), new ChunkPos(cx, cz), tag, true);
+                    LOGGER.info("Received chunk data " + world + "," + cx + "," + cz + " with status " + newChunk.protoChunk.getStatus() + " (old status was " + holder.getChunkHolderStatus() + ")");
+                    holder.replaceProtoChunk(newChunk.protoChunk);
                 }
             }
         } catch (IOException e) {
